import 'package:flutter/material.dart';
import 'package:flutter/gestures.dart';
import 'package:table_calendar/table_calendar.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'dart:convert';
import 'dart:math' as math;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_quill/flutter_quill.dart' as quill;
// quill_delta import removed — access Delta via flutter_quill directly
// pdf/printing used for PdfPreview viewer
import 'package:printing/printing.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:pdf/pdf.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:http/http.dart' as http;
import 'package:google_generative_ai/google_generative_ai.dart' as gemini;
import 'package:google_sign_in/google_sign_in.dart';
import 'package:extension_google_sign_in_as_googleapis_auth/extension_google_sign_in_as_googleapis_auth.dart';
import 'package:googleapis/calendar/v3.dart' as gcal;
import 'package:googleapis/drive/v3.dart' as gdrive;
import 'package:file_picker/file_picker.dart';
import 'package:health/health.dart';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kDebugMode, kIsWeb, TargetPlatform, defaultTargetPlatform;
import 'package:flutter/services.dart' show Clipboard, ClipboardData, MethodChannel, SystemNavigator, rootBundle;
import 'package:record/record.dart';
import 'package:audioplayers/audioplayers.dart' as ap;
import 'package:path_provider/path_provider.dart';
import 'dart:async';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart' as p;
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:local_auth/local_auth.dart';
import 'package:home_widget/home_widget.dart';
import 'dart:io' show Directory, File, FileMode;
import 'package:archive/archive.dart' as archive;
import 'package:share_plus/share_plus.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'dart:ui' as ui show PlatformDispatcher, Gradient;
import 'package:flutter_contacts/flutter_contacts.dart' as contacts_pkg;
import 'package:timezone/data/latest_all.dart' as tz;
import 'package:timezone/timezone.dart' as tz;
import 'package:flutter_timezone/flutter_timezone.dart';

/// Returns true when the Ethos (Bordeaux) theme is active.
bool _isEthosTheme(BuildContext context) {
  final primary = Theme.of(context).colorScheme.primary;
  return primary == const Color(0xFFA3274F);
}

/// Returns true when the Ephemera (diary vintage) theme is active.
bool _isEphemeraTheme(BuildContext context) {
  final primary = Theme.of(context).colorScheme.primary;
  return primary == const Color(0xFF795548);
}

/// Returns true when the Nordic Zen theme is active.
bool _isNordicTheme(BuildContext context) =>
    Theme.of(context).colorScheme.primary == const Color(0xFF78909C);

/// Returns true when the Green Salvia theme is active.
bool _isSalviaTheme(BuildContext context) =>
    Theme.of(context).colorScheme.primary == const Color(0xFF6B8F71);

/// Returns true when the Sakura theme is active.
bool _isSakuraTheme(BuildContext context) =>
    Theme.of(context).colorScheme.primary == const Color(0xFFB5838D);

/// Returns true when the Yellow Note theme is active.
bool _isYellowNoteTheme(BuildContext context) =>
    Theme.of(context).colorScheme.primary == const Color(0xFF1E3A8A);

bool _isBlockNoteTheme(BuildContext context) =>
    Theme.of(context).colorScheme.primary == const Color(0xFFE6A100);

/// Draws horizontal ruled lines (blue) and a double red margin line,
/// simulating classic yellow legal-pad paper.
class _LinedPaperPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    const lineSpacing = 24.0;
    final linePaint = Paint()
      ..color = const Color(0x331E3A8A)
      ..strokeWidth = 0.5;
    for (double y = lineSpacing; y < size.height; y += lineSpacing) {
      canvas.drawLine(Offset(0, y), Offset(size.width, y), linePaint);
    }
    final marginPaint = Paint()
      ..color = const Color(0x33EF4444)
      ..strokeWidth = 0.8;
    canvas.drawLine(const Offset(40, 0), Offset(40, size.height), marginPaint);
    canvas.drawLine(const Offset(42, 0), Offset(42, size.height), marginPaint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

/// Micro-dot texture simulating recycled paper fiber.
class _PaperTexturePainter extends CustomPainter {
  final int seed;
  const _PaperTexturePainter({this.seed = 0});

  @override
  void paint(Canvas canvas, Size size) {
    final rng = math.Random(seed);
    final dotPaint = Paint()..color = const Color(0x0A795548);
    final count = (size.width * size.height / 120).clamp(50, 600).toInt();
    for (int i = 0; i < count; i++) {
      final x = rng.nextDouble() * size.width;
      final y = rng.nextDouble() * size.height;
      final r = 0.4 + rng.nextDouble() * 0.8;
      canvas.drawCircle(Offset(x, y), r, dotPaint);
    }
  }

  @override
  bool shouldRepaint(covariant _PaperTexturePainter old) => old.seed != seed;
}

/// Horizontal ruled lines + double red legal-pad margin with wobble effect.
class _PaperMarginPainter extends CustomPainter {
  final int seed;
  const _PaperMarginPainter({this.seed = 0});

  @override
  void paint(Canvas canvas, Size size) {
    final rng = math.Random(seed);
    const lineSpacing = 22.0;
    // Horizontal blue rules
    final linePaint = Paint()
      ..color = const Color(0x221565C0)
      ..strokeWidth = 0.5;
    for (double y = lineSpacing; y < size.height; y += lineSpacing) {
      final wobble = (rng.nextDouble() - 0.5) * 0.6;
      canvas.drawLine(Offset(0, y + wobble), Offset(size.width, y + wobble), linePaint);
    }
    // Double red margin (legal pad style) with slight wobble
    final marginPaint = Paint()
      ..color = const Color(0x30E53935)
      ..strokeWidth = 0.7;
    final marginPaint2 = Paint()
      ..color = const Color(0x20E53935)
      ..strokeWidth = 0.6;
    const mx1 = 38.0;
    const mx2 = 41.0;
    for (double y = 0; y < size.height; y += 4) {
      final w1 = (rng.nextDouble() - 0.5) * 0.4;
      final w2 = (rng.nextDouble() - 0.5) * 0.4;
      canvas.drawLine(Offset(mx1 + w1, y), Offset(mx1 + w1, y + 4), marginPaint);
      canvas.drawLine(Offset(mx2 + w2, y), Offset(mx2 + w2, y + 4), marginPaint2);
    }
  }

  @override
  bool shouldRepaint(covariant _PaperMarginPainter old) => old.seed != seed;
}

/// Triangle gradient at bottom-right corner for Post-it curl effect.
class _CornerCurlPainter extends CustomPainter {
  final Color baseColor;
  const _CornerCurlPainter({required this.baseColor});

  @override
  void paint(Canvas canvas, Size size) {
    const curlSize = 14.0;
    final path = Path()
      ..moveTo(size.width, size.height - curlSize)
      ..lineTo(size.width, size.height)
      ..lineTo(size.width - curlSize, size.height)
      ..close();
    final gradient = ui.Gradient.linear(
      Offset(size.width, size.height - curlSize),
      Offset(size.width - curlSize, size.height),
      [const Color(0x40000000), const Color(0x08000000)],
    );
    canvas.drawPath(path, Paint()..shader = gradient);
    // Lighter triangle underneath the curl
    final underPath = Path()
      ..moveTo(size.width - curlSize, size.height)
      ..lineTo(size.width, size.height - curlSize)
      ..lineTo(size.width - curlSize + 2, size.height - 2)
      ..close();
    canvas.drawPath(underPath, Paint()..color = const Color(0x18FFFFFF));
  }

  @override
  bool shouldRepaint(covariant _CornerCurlPainter old) => old.baseColor != baseColor;
}

/// Maps a theme mode string to [bgColor, iconCircleColor, separatorColor]
/// for the Flash Notes Shortcuts home-screen widget.
List<int> _widgetColorsForTheme(String mode) {
  const map = <String, List<int>>{
    'default':       [0xFFFFFFFF, 0xFFFFA726, 0x33000000],
    'dark':          [0xFF1C1B1F, 0xFFFFA726, 0x33FFFFFF],
    'ethos':         [0xFFFFF0F3, 0xFFA3274F, 0x33000000],
    'ephemera':      [0xFFF4EBD0, 0xFF795548, 0x33000000],
    'nordic_zen':    [0xFFF0F4F8, 0xFF78909C, 0x33000000],
    'green_salvia':  [0xFFF1F5E8, 0xFF6B8F71, 0x33000000],
    'sakura':        [0xFFFFF5F5, 0xFFB5838D, 0x33000000],
    'spadaccino':    [0xFF0D1B16, 0xFF2E7D5B, 0x33FFFFFF],
    'sogno_re':      [0xFFFFF8E1, 0xFFD32F2F, 0x33000000],
    'mappa_tesoro':  [0xFFFFF8E1, 0xFFE6A800, 0x33000000],
    'fulmine':       [0xFF0D0D1A, 0xFF7C4DFF, 0x33FFFFFF],
    'eremita':       [0xFF1A0A00, 0xFFE65100, 0x33FFFFFF],
    'saggio':        [0xFF1A0F0F, 0xFF8B1A1A, 0x33FFFFFF],
    'cabina_tempo':  [0xFF001529, 0xFF1565C0, 0x33FFFFFF],
    'sottosopra':    [0xFF0A0A0A, 0xFFD50000, 0x33FFFFFF],
    'rifugio':       [0xFF1A1A0A, 0xFF32CD32, 0x33FFFFFF],
    'yellow_note':   [0xFFFEF9C3, 0xFF1E3A8A, 0x33000000],
    'deep_abyss':    [0xFF000000, 0xFF1A237E, 0x33FFFFFF],
    'midnight_forest': [0xFF050A05, 0xFF2E7D32, 0x33FFFFFF],
    'cyberpunk_void':  [0xFF0F0F10, 0xFF00BCD4, 0x33FFFFFF],
    'block_note':      [0xFFFFF8E1, 0xFFE6A100, 0x33000000],
  };
  return map[mode] ?? map['default']!;
}

/// Saves the current theme colours to HomeWidget SharedPreferences and
/// triggers a widget update so the Flash Notes Shortcuts widget matches.
Future<void> _syncThemeToWidget(String mode) async {
  if (kIsWeb || defaultTargetPlatform != TargetPlatform.android) return;
  try {
    final colors = _widgetColorsForTheme(mode);
    await HomeWidget.saveWidgetData('widget_bg', colors[0].toSigned(32));
    await HomeWidget.saveWidgetData('widget_icon_bg', colors[1].toSigned(32));
    await HomeWidget.saveWidgetData('widget_sep', colors[2].toSigned(32));
    await HomeWidget.updateWidget(
      qualifiedAndroidName: 'com.ethosnote.app.widget.FlashNotesShortcutsProvider',
    );
  } catch (e) {
    if (kDebugMode) debugPrint('Widget theme sync: $e');
  }
}

// ── Theme helpers (accent colors, fonts) ──

/// Section accent: 0 = Deep Note, 1 = Calendar, 2 = Flash Notes
Color _sectionAccent(BuildContext context, int section) {
  final v = Theme.of(context).colorScheme.primary.toARGB32();
  const map = <int, List<Color>>{
    0xFFA3274F: [Color(0xFFC0364D), Color(0xFFA3274F), Color(0xFFB8566B)],
    0xFF795548: [Color(0xFF6D4C41), Color(0xFF795548), Color(0xFF8D6E63)],
    0xFF78909C: [Color(0xFF607D8B), Color(0xFF78909C), Color(0xFF90A4AE)],
    0xFF6B8F71: [Color(0xFF5B7F61), Color(0xFF6B8F71), Color(0xFF8BAF90)],
    0xFFB5838D: [Color(0xFFA36B74), Color(0xFFB5838D), Color(0xFFC89FA6)],
    // Oltre l'Oceano
    0xFF1B4D3E: [Color(0xFF2E7D5B), Color(0xFF1B4D3E), Color(0xFF4CAF50)], // Zoro
    0xFFD32F2F: [Color(0xFFC62828), Color(0xFFD32F2F), Color(0xFFEF5350)], // Luffy
    0xFFE6A800: [Color(0xFFFFD700), Color(0xFFE6A800), Color(0xFFFFB300)], // Nami
    // Spirito della Foglia
    0xFF7C4DFF: [Color(0xFF651FFF), Color(0xFF7C4DFF), Color(0xFFB388FF)], // Sasuke
    0xFFE65100: [Color(0xFFE65100), Color(0xFF00BCD4), Color(0xFFFF6D00)], // Naruto
    0xFF691212: [Color(0xFF8B1A1A), Color(0xFF691212), Color(0xFF6B8E23)], // Jiraiya
    // Serie Cult
    0xFF003B6F: [Color(0xFF1565C0), Color(0xFF003B6F), Color(0xFF90CAF9)], // Dr. Who
    0xFFB71C1C: [Color(0xFFD50000), Color(0xFFB71C1C), Color(0xFFFF1744)], // Stranger Things
    0xFF32CD32: [Color(0xFF32CD32), Color(0xFF005FB8), Color(0xFFFFEB3B)], // Fallout
    0xFF1E3A8A: [Color(0xFFEF4444), Color(0xFF1E3A8A), Color(0xFFFFA726)], // Yellow Note
    0xFF1A237E: [Color(0xFF3949AB), Color(0xFF1A237E), Color(0xFF7C4DFF)], // Deep Abyss
    0xFF2E7D32: [Color(0xFF388E3C), Color(0xFF2E7D32), Color(0xFF8D6E63)], // Midnight Forest
    0xFF00BCD4: [Color(0xFF00ACC1), Color(0xFF00BCD4), Color(0xFFFF4081)], // Cyberpunk Void
    0xFFE6A100: [Color(0xFFE53935), Color(0xFFE6A100), Color(0xFFFF7043)], // Block Note
  };
  return map[v]?[section] ?? const [Color(0xFFE53935), Color(0xFF1E88E5), Color(0xFFFFA726)][section];
}

/// Themed font family, or null for system default.
String? _themedFont(BuildContext context) {
  final v = Theme.of(context).colorScheme.primary.toARGB32();
  const map = <int, String>{
    0xFFA3274F: 'Georgia',
    0xFF795548: 'Lora',
    0xFFB5838D: 'Libre Baskerville',
    0xFF691212: 'Caveat', // Jiraiya — calligraphic brush
    0xFF32CD32: 'Share Tech Mono', // Fallout — monospaced terminal
    0xFF1E3A8A: 'Courier Prime', // Yellow Note — typewriter
    0xFF2E7D32: 'Lora', // Midnight Forest — organic
    0xFF00BCD4: 'Share Tech Mono', // Cyberpunk Void — tech
    0xFFE6A100: 'Patrick Hand', // Block Note — handwritten
  };
  return map[v];
}

/// True if the current theme uses a custom primary tint.
bool _hasCustomTheme(BuildContext context) {
  final v = Theme.of(context).colorScheme.primary.toARGB32();
  return const {
    0xFFA3274F, 0xFF795548, 0xFF78909C, 0xFF6B8F71, 0xFFB5838D,
    0xFF1B4D3E, 0xFFD32F2F, 0xFFE6A800, 0xFF7C4DFF, 0xFFE65100,
    0xFF691212, 0xFF003B6F, 0xFFB71C1C, 0xFF32CD32, 0xFF1E3A8A,
    0xFF1A237E, 0xFF2E7D32, 0xFF00BCD4, 0xFFE6A100,
  }.contains(v);
}

/// Quill highlight background for the current theme.
String _themedHighlight(BuildContext context) {
  final v = Theme.of(context).colorScheme.primary.toARGB32();
  const map = <int, String>{
    0xFF795548: '#F4EBD0',
    0xFFA3274F: '#F2D5DC',
    0xFF78909C: '#E3EBF0',
    0xFF6B8F71: '#DCEADE',
    0xFFB5838D: '#F7E7E6',
    0xFF1B4D3E: '#1E5A47', // Zoro — dark green
    0xFFD32F2F: '#FFF9C4', // Luffy — yellow parchment
    0xFFE6A800: '#FFE0B2', // Nami — peach
    0xFF7C4DFF: '#1A1A2E', // Sasuke — deep night
    0xFFE65100: '#1A1A1A', // Naruto — dark
    0xFF691212: '#F5E6C8', // Jiraiya — parchment
    0xFF003B6F: '#0D2137', // Dr. Who — TARDIS dark
    0xFFB71C1C: '#0A0A1A', // Stranger Things — abyss
    0xFF32CD32: '#1A1A1A', // Fallout — terminal dark
    0xFF1E3A8A: '#FEF9C3', // Yellow Note — pad yellow
    0xFF1A237E: '#060606', // Deep Abyss — dark surface
    0xFF2E7D32: '#0A120A', // Midnight Forest — dark green
    0xFF00BCD4: '#141418', // Cyberpunk Void — dark surface
    0xFFE6A100: '#FFF8E1', // Block Note — warm paper
  };
  return map[v] ?? '#FFF9C4';
}

/// Optional paper texture overlay color for editor pages.
Color? _themeOverlayColor(BuildContext context) {
  final v = Theme.of(context).colorScheme.primary.toARGB32();
  const map = <int, Color>{
    0xFF795548: Color(0x06795548),
    0xFF6B8F71: Color(0x062A3B32),
    0xFFB5838D: Color(0x06B5838D),
    0xFFE6A800: Color(0x06E6A800), // Nami — nautical parchment
    0xFF691212: Color(0x08691212), // Jiraiya — scroll texture
    0xFF003B6F: Color(0x06003B6F), // Dr. Who — retro screen
    0xFF32CD32: Color(0x0832CD32), // Fallout — terminal glow
    0xFF1E3A8A: Color(0x061E3A8A), // Yellow Note — subtle paper tint
    0xFF2E7D32: Color(0x06050A05), // Midnight Forest — moss effect
    0xFFE6A100: Color(0x08E6A100), // Block Note — warm paper tint
  };
  return map[v];
}

// ─── Internationalization (i18n) ─────────────────────────────────────────────

String _appLocale = 'it';

String tr(String key) => _translations[key]?[_appLocale] ?? _translations[key]?['it'] ?? key;

/// Translate folder names for display (DB stores Italian keys).
String folderLabel(String folder) {
  const map = {'Generale': 'general', 'Diario del Ciclo': 'cycle_diary_folder'};
  final key = map[folder];
  return key != null ? tr(key) : folder;
}

List<String> localizedMonths() => [
  '', tr('january'), tr('february'), tr('march'), tr('april'), tr('may'), tr('june'),
  tr('july'), tr('august'), tr('september'), tr('october'), tr('november'), tr('december'),
];

List<String> localizedWeekdaysShort() => [tr('mon'), tr('tue'), tr('wed'), tr('thu'), tr('fri'), tr('sat'), tr('sun')];

/// Post-it / sticky-note decoration for Flash Notes paper mode.
const _paperStickyColors = [
  Color(0xFFFFEB3B), // giallo
  Color(0xFFF48FB1), // rosa
  Color(0xFF81D4FA), // azzurro
  Color(0xFFA5D6A7), // verde menta
  Color(0xFFFFCC80), // pesca
];

BoxDecoration _paperStickyDecoration(int colorIndex) {
  final color = _paperStickyColors[colorIndex % _paperStickyColors.length];
  return BoxDecoration(
    color: color,
    borderRadius: const BorderRadius.only(
      topLeft: Radius.circular(2),
      topRight: Radius.circular(4),
      bottomLeft: Radius.circular(3),
      bottomRight: Radius.circular(1),
    ),
    boxShadow: [
      BoxShadow(
        color: const Color(0x33000000),
        offset: const Offset(3, 4),
        blurRadius: 8,
      ),
      BoxShadow(
        color: const Color(0x18000000),
        offset: const Offset(-1, 1),
        blurRadius: 3,
      ),
    ],
  );
}

const _translations = <String, Map<String, String>>{
  // ── Navigation ──
  'calendar': {'it': 'Calendario', 'en': 'Calendar', 'fr': 'Calendrier', 'es': 'Calendario'},

  // ── Connectivity ──
  'offline_mode': {'it': 'Sei offline', 'en': 'You are offline', 'fr': 'Vous êtes hors ligne', 'es': 'Estás sin conexión'},

  // ── Common actions ──
  'save': {'it': 'Salva', 'en': 'Save', 'fr': 'Enregistrer', 'es': 'Guardar'},
  'cancel': {'it': 'Annulla', 'en': 'Cancel', 'fr': 'Annuler', 'es': 'Cancelar'},
  'delete': {'it': 'Elimina', 'en': 'Delete', 'fr': 'Supprimer', 'es': 'Eliminar'},
  'edit': {'it': 'Modifica', 'en': 'Edit', 'fr': 'Modifier', 'es': 'Editar'},
  'create': {'it': 'Crea', 'en': 'Create', 'fr': 'Créer', 'es': 'Crear'},
  'confirm': {'it': 'Conferma', 'en': 'Confirm', 'fr': 'Confirmer', 'es': 'Confirmar'},
  'close': {'it': 'Chiudi', 'en': 'Close', 'fr': 'Fermer', 'es': 'Cerrar'},
  'add': {'it': 'Aggiungi', 'en': 'Add', 'fr': 'Ajouter', 'es': 'Añadir'},
  'search': {'it': 'Cerca', 'en': 'Search', 'fr': 'Rechercher', 'es': 'Buscar'},
  'apply': {'it': 'Applica', 'en': 'Apply', 'fr': 'Appliquer', 'es': 'Aplicar'},
  'insert': {'it': 'Inserisci', 'en': 'Insert', 'fr': 'Insérer', 'es': 'Insertar'},
  'seconds': {'it': 'secondi', 'en': 'seconds', 'fr': 'secondes', 'es': 'segundos'},
  'minutes_before': {'it': 'minuti prima', 'en': 'minutes before', 'fr': 'minutes avant', 'es': 'minutos antes'},
  'empty_action': {'it': 'Svuota', 'en': 'Empty', 'fr': 'Vider', 'es': 'Vaciar'},
  'restore': {'it': 'Ripristina', 'en': 'Restore', 'fr': 'Restaurer', 'es': 'Restaurar'},
  'share': {'it': 'Condividi', 'en': 'Share', 'fr': 'Partager', 'es': 'Compartir'},
  'continue_action': {'it': 'Continua', 'en': 'Continue', 'fr': 'Continuer', 'es': 'Continuar'},
  'select': {'it': 'Seleziona', 'en': 'Select', 'fr': 'Sélectionner', 'es': 'Seleccionar'},
  'remove': {'it': 'Rimuovi', 'en': 'Remove', 'fr': 'Retirer', 'es': 'Quitar'},
  'done': {'it': 'Fatto', 'en': 'Done', 'fr': 'Terminé', 'es': 'Hecho'},
  'back': {'it': 'Indietro', 'en': 'Back', 'fr': 'Retour', 'es': 'Atrás'},
  'all': {'it': 'Tutte', 'en': 'All', 'fr': 'Toutes', 'es': 'Todas'},
  'copy': {'it': 'Copia', 'en': 'Copy', 'fr': 'Copier', 'es': 'Copiar'},
  'yes': {'it': 'Sì', 'en': 'Yes', 'fr': 'Oui', 'es': 'Sí'},
  'no': {'it': 'No', 'en': 'No', 'fr': 'Non', 'es': 'No'},
  'send': {'it': 'Invia', 'en': 'Send', 'fr': 'Envoyer', 'es': 'Enviar'},
  'view': {'it': 'Vedi', 'en': 'View', 'fr': 'Voir', 'es': 'Ver'},
  'rename': {'it': 'Rinomina', 'en': 'Rename', 'fr': 'Renommer', 'es': 'Renombrar'},
  'move': {'it': 'Sposta', 'en': 'Move', 'fr': 'Déplacer', 'es': 'Mover'},
  'pin': {'it': 'Fissa', 'en': 'Pin', 'fr': 'Épingler', 'es': 'Fijar'},
  'unpin': {'it': 'Rimuovi fissata', 'en': 'Unpin', 'fr': 'Désépingler', 'es': 'Desfijar'},
  'pinned': {'it': 'Fissata', 'en': 'Pinned', 'fr': 'Épinglé', 'es': 'Fijado'},
  'reset': {'it': 'Reset', 'en': 'Reset', 'fr': 'Réinitialiser', 'es': 'Restablecer'},
  'download': {'it': 'Scarica', 'en': 'Download', 'fr': 'Télécharger', 'es': 'Descargar'},
  'open': {'it': 'Apri', 'en': 'Open', 'fr': 'Ouvrir', 'es': 'Abrir'},
  'sort': {'it': 'Ordina', 'en': 'Sort', 'fr': 'Trier', 'es': 'Ordenar'},
  'newest_first': {'it': 'Più recenti', 'en': 'Newest first', 'fr': 'Plus récents', 'es': 'Más recientes'},
  'oldest_first': {'it': 'Più vecchi', 'en': 'Oldest first', 'fr': 'Plus anciens', 'es': 'Más antiguos'},
  'alphabetical_az': {'it': 'A-Z', 'en': 'A-Z', 'fr': 'A-Z', 'es': 'A-Z'},
  'alphabetical_za': {'it': 'Z-A', 'en': 'Z-A', 'fr': 'Z-A', 'es': 'Z-A'},

  // ── Months ──
  'january': {'it': 'Gennaio', 'en': 'January', 'fr': 'Janvier', 'es': 'Enero'},
  'february': {'it': 'Febbraio', 'en': 'February', 'fr': 'Février', 'es': 'Febrero'},
  'march': {'it': 'Marzo', 'en': 'March', 'fr': 'Mars', 'es': 'Marzo'},
  'april': {'it': 'Aprile', 'en': 'April', 'fr': 'Avril', 'es': 'Abril'},
  'may': {'it': 'Maggio', 'en': 'May', 'fr': 'Mai', 'es': 'Mayo'},
  'june': {'it': 'Giugno', 'en': 'June', 'fr': 'Juin', 'es': 'Junio'},
  'july': {'it': 'Luglio', 'en': 'July', 'fr': 'Juillet', 'es': 'Julio'},
  'august': {'it': 'Agosto', 'en': 'August', 'fr': 'Août', 'es': 'Agosto'},
  'september': {'it': 'Settembre', 'en': 'September', 'fr': 'Septembre', 'es': 'Septiembre'},
  'october': {'it': 'Ottobre', 'en': 'October', 'fr': 'Octobre', 'es': 'Octubre'},
  'november': {'it': 'Novembre', 'en': 'November', 'fr': 'Novembre', 'es': 'Noviembre'},
  'december': {'it': 'Dicembre', 'en': 'December', 'fr': 'Décembre', 'es': 'Diciembre'},

  // ── Days (short) ──
  'mon': {'it': 'Lun', 'en': 'Mon', 'fr': 'Lun', 'es': 'Lun'},
  'tue': {'it': 'Mar', 'en': 'Tue', 'fr': 'Mar', 'es': 'Mar'},
  'wed': {'it': 'Mer', 'en': 'Wed', 'fr': 'Mer', 'es': 'Mié'},
  'thu': {'it': 'Gio', 'en': 'Thu', 'fr': 'Jeu', 'es': 'Jue'},
  'fri': {'it': 'Ven', 'en': 'Fri', 'fr': 'Ven', 'es': 'Vie'},
  'sat': {'it': 'Sab', 'en': 'Sat', 'fr': 'Sam', 'es': 'Sáb'},
  'sun': {'it': 'Dom', 'en': 'Sun', 'fr': 'Dim', 'es': 'Dom'},

  // ── Days (full) ──
  'monday': {'it': 'Lunedì', 'en': 'Monday', 'fr': 'Lundi', 'es': 'Lunes'},
  'tuesday': {'it': 'Martedì', 'en': 'Tuesday', 'fr': 'Mardi', 'es': 'Martes'},
  'wednesday': {'it': 'Mercoledì', 'en': 'Wednesday', 'fr': 'Mercredi', 'es': 'Miércoles'},
  'thursday': {'it': 'Giovedì', 'en': 'Thursday', 'fr': 'Jeudi', 'es': 'Jueves'},
  'friday': {'it': 'Venerdì', 'en': 'Friday', 'fr': 'Vendredi', 'es': 'Viernes'},
  'saturday': {'it': 'Sabato', 'en': 'Saturday', 'fr': 'Samedi', 'es': 'Sábado'},
  'sunday': {'it': 'Domenica', 'en': 'Sunday', 'fr': 'Dimanche', 'es': 'Domingo'},

  // ── Zodiac ──
  'aries': {'it': 'Ariete', 'en': 'Aries', 'fr': 'Bélier', 'es': 'Aries'},
  'taurus': {'it': 'Toro', 'en': 'Taurus', 'fr': 'Taureau', 'es': 'Tauro'},
  'gemini': {'it': 'Gemelli', 'en': 'Gemini', 'fr': 'Gémeaux', 'es': 'Géminis'},
  'cancer': {'it': 'Cancro', 'en': 'Cancer', 'fr': 'Cancer', 'es': 'Cáncer'},
  'leo': {'it': 'Leone', 'en': 'Leo', 'fr': 'Lion', 'es': 'Leo'},
  'virgo': {'it': 'Vergine', 'en': 'Virgo', 'fr': 'Vierge', 'es': 'Virgo'},
  'libra': {'it': 'Bilancia', 'en': 'Libra', 'fr': 'Balance', 'es': 'Libra'},
  'scorpio': {'it': 'Scorpione', 'en': 'Scorpio', 'fr': 'Scorpion', 'es': 'Escorpio'},
  'sagittarius': {'it': 'Sagittario', 'en': 'Sagittarius', 'fr': 'Sagittaire', 'es': 'Sagitario'},
  'capricorn': {'it': 'Capricorno', 'en': 'Capricorn', 'fr': 'Capricorne', 'es': 'Capricornio'},
  'aquarius': {'it': 'Acquario', 'en': 'Aquarius', 'fr': 'Verseau', 'es': 'Acuario'},
  'pisces': {'it': 'Pesci', 'en': 'Pisces', 'fr': 'Poissons', 'es': 'Piscis'},

  // ── Settings ──
  'settings': {'it': 'Impostazioni', 'en': 'Settings', 'fr': 'Paramètres', 'es': 'Ajustes'},
  'theme': {'it': 'Tema', 'en': 'Theme', 'fr': 'Thème', 'es': 'Tema'},
  'light': {'it': 'Chiaro', 'en': 'Light', 'fr': 'Clair', 'es': 'Claro'},
  'dark': {'it': 'Scuro', 'en': 'Dark', 'fr': 'Sombre', 'es': 'Oscuro'},
  'language': {'it': 'Lingua', 'en': 'Language', 'fr': 'Langue', 'es': 'Idioma'},
  'deep_note_settings': {'it': 'Impostazioni Deep Note', 'en': 'Deep Note Settings', 'fr': 'Paramètres Deep Note', 'es': 'Ajustes Deep Note'},
  'calendar_settings': {'it': 'Impostazioni Calendario', 'en': 'Calendar Settings', 'fr': 'Paramètres Calendrier', 'es': 'Ajustes Calendario'},
  'flash_notes_settings': {'it': 'Impostazioni Flash Notes', 'en': 'Flash Notes Settings', 'fr': 'Paramètres Flash Notes', 'es': 'Ajustes Flash Notes'},
  'trash': {'it': 'Cestino', 'en': 'Trash', 'fr': 'Corbeille', 'es': 'Papelera'},
  'backup': {'it': 'Backup', 'en': 'Backup', 'fr': 'Sauvegarde', 'es': 'Copia de seguridad'},
  'backup_mode': {'it': 'Modalità Backup', 'en': 'Backup Mode', 'fr': 'Mode de sauvegarde', 'es': 'Modo de copia'},
  'local': {'it': 'Locale', 'en': 'Local', 'fr': 'Local', 'es': 'Local'},
  'save_on_device': {'it': 'Salva sul dispositivo', 'en': 'Save on device', 'fr': 'Enregistrer sur l\'appareil', 'es': 'Guardar en dispositivo'},
  'sync_to_cloud': {'it': 'Sincronizza su cloud', 'en': 'Sync to cloud', 'fr': 'Synchroniser sur le cloud', 'es': 'Sincronizar en la nube'},
  'backup_export': {'it': 'Esporta Backup', 'en': 'Export Backup', 'fr': 'Exporter la sauvegarde', 'es': 'Exportar copia'},
  'backup_import': {'it': 'Importa Backup', 'en': 'Import Backup', 'fr': 'Importer la sauvegarde', 'es': 'Importar copia'},
  'backup_exported': {'it': 'Backup esportato con successo', 'en': 'Backup exported successfully', 'fr': 'Sauvegarde exportée avec succès', 'es': 'Copia exportada con éxito'},
  'backup_imported': {'it': 'Backup importato. Riavvia l\'app.', 'en': 'Backup imported. Restart the app.', 'fr': 'Sauvegarde importée. Redémarrez l\'app.', 'es': 'Copia importada. Reinicia la app.'},
  'backup_import_confirm': {'it': 'Importare il backup? I dati attuali verranno sostituiti.', 'en': 'Import backup? Current data will be replaced.', 'fr': 'Importer la sauvegarde ? Les données actuelles seront remplacées.', 'es': '¿Importar copia? Los datos actuales se reemplazarán.'},
  'backup_error': {'it': 'Errore durante il backup', 'en': 'Backup error', 'fr': 'Erreur de sauvegarde', 'es': 'Error de copia'},
  'backup_destination': {'it': 'Destinazione', 'en': 'Destination', 'fr': 'Destination', 'es': 'Destino'},
  'backup_device': {'it': 'Telefono', 'en': 'Device', 'fr': 'Téléphone', 'es': 'Teléfono'},
  'backup_google_drive': {'it': 'Google Drive', 'en': 'Google Drive', 'fr': 'Google Drive', 'es': 'Google Drive'},
  'backup_auto': {'it': 'Backup Automatico', 'en': 'Auto Backup', 'fr': 'Sauvegarde automatique', 'es': 'Backup automático'},
  'backup_auto_off': {'it': 'Off', 'en': 'Off', 'fr': 'Off', 'es': 'Off'},
  'backup_auto_daily': {'it': 'Giorno', 'en': 'Daily', 'fr': 'Jour', 'es': 'Diario'},
  'backup_auto_weekly': {'it': 'Settimana', 'en': 'Weekly', 'fr': 'Semaine', 'es': 'Semanal'},
  'backup_auto_monthly': {'it': 'Mensile', 'en': 'Monthly', 'fr': 'Mensuel', 'es': 'Mensual'},
  'backup_to_drive': {'it': 'Backup su Google Drive', 'en': 'Backup to Google Drive', 'fr': 'Sauvegarde sur Google Drive', 'es': 'Backup en Google Drive'},
  'backup_from_drive': {'it': 'Ripristina da Google Drive', 'en': 'Restore from Google Drive', 'fr': 'Restaurer depuis Google Drive', 'es': 'Restaurar desde Google Drive'},
  'last_backup': {'it': 'Ultimo backup', 'en': 'Last backup', 'fr': 'Dernière sauvegarde', 'es': 'Último backup'},
  'connect_google_drive': {'it': 'Collega Google Drive', 'en': 'Connect Google Drive', 'fr': 'Connecter Google Drive', 'es': 'Conectar Google Drive'},
  'backup_auto_completed': {'it': 'Backup automatico completato', 'en': 'Auto backup completed', 'fr': 'Sauvegarde automatique terminée', 'es': 'Backup automático completado'},
  'backup_dest_confirm_title': {'it': 'Cambiare destinazione?', 'en': 'Change destination?', 'fr': 'Changer la destination ?', 'es': '¿Cambiar destino?'},
  'backup_dest_confirm_body': {'it': 'I prossimi backup verranno salvati su {dest}. I backup precedenti non verranno spostati.', 'en': 'Future backups will be saved to {dest}. Previous backups will not be moved.', 'fr': 'Les prochaines sauvegardes seront enregistrées sur {dest}. Les sauvegardes précédentes ne seront pas déplacées.', 'es': 'Los próximos backups se guardarán en {dest}. Los backups anteriores no se moverán.'},
  'backup_dest_info': {'it': 'I prossimi backup verranno salvati su {dest}', 'en': 'Future backups will be saved to {dest}', 'fr': 'Les prochaines sauvegardes seront enregistrées sur {dest}', 'es': 'Los próximos backups se guardarán en {dest}'},
  'no_backup_found': {'it': 'Nessun backup trovato su Google Drive', 'en': 'No backup found on Google Drive', 'fr': 'Aucune sauvegarde trouvée sur Google Drive', 'es': 'No se encontró backup en Google Drive'},
  'backup_uploading': {'it': 'Caricamento backup su Drive...', 'en': 'Uploading backup to Drive...', 'fr': 'Envoi de la sauvegarde sur Drive...', 'es': 'Subiendo backup a Drive...'},
  'backup_downloading': {'it': 'Download backup da Drive...', 'en': 'Downloading backup from Drive...', 'fr': 'Téléchargement de la sauvegarde depuis Drive...', 'es': 'Descargando backup desde Drive...'},
  'never': {'it': 'Mai', 'en': 'Never', 'fr': 'Jamais', 'es': 'Nunca'},
  'info': {'it': 'Informazioni', 'en': 'Information', 'fr': 'Informations', 'es': 'Información'},
  'version': {'it': 'Versione', 'en': 'Version', 'fr': 'Version', 'es': 'Versión'},
  'add_account': {'it': 'Aggiungi Account', 'en': 'Add Account', 'fr': 'Ajouter un compte', 'es': 'Añadir cuenta'},
  'max_profiles': {'it': 'Massimo 3 profili', 'en': 'Maximum 3 profiles', 'fr': 'Maximum 3 profils', 'es': 'Máximo 3 perfiles'},
  'delete_account': {'it': 'Elimina Account', 'en': 'Delete Account', 'fr': 'Supprimer le compte', 'es': 'Eliminar cuenta'},
  'delete_account_confirm': {'it': 'Sei sicuro di voler eliminare il tuo account? Tutti i dati verranno persi.', 'en': 'Are you sure you want to delete your account? All data will be lost.', 'fr': 'Êtes-vous sûr de vouloir supprimer votre compte ? Toutes les données seront perdues.', 'es': '¿Estás seguro de que quieres eliminar tu cuenta? Todos los datos se perderán.'},

  // ── Profile ──
  'profile': {'it': 'Profilo', 'en': 'Profile', 'fr': 'Profil', 'es': 'Perfil'},
  'profile_photo': {'it': 'Foto Profilo', 'en': 'Profile Photo', 'fr': 'Photo de profil', 'es': 'Foto de perfil'},
  'change_photo': {'it': 'Cambia Foto', 'en': 'Change Photo', 'fr': 'Changer la photo', 'es': 'Cambiar foto'},
  'remove_photo': {'it': 'Rimuovi Foto', 'en': 'Remove Photo', 'fr': 'Supprimer la photo', 'es': 'Quitar foto'},
  'name': {'it': 'Nome', 'en': 'First Name', 'fr': 'Prénom', 'es': 'Nombre'},
  'surname': {'it': 'Cognome', 'en': 'Last Name', 'fr': 'Nom', 'es': 'Apellido'},
  'email': {'it': 'Email', 'en': 'Email', 'fr': 'Email', 'es': 'Email'},
  'phone': {'it': 'Telefono', 'en': 'Phone', 'fr': 'Téléphone', 'es': 'Teléfono'},
  'nickname': {'it': 'Nickname', 'en': 'Nickname', 'fr': 'Pseudo', 'es': 'Apodo'},
  'birth_date': {'it': 'Data di nascita', 'en': 'Date of birth', 'fr': 'Date de naissance', 'es': 'Fecha de nacimiento'},
  'religion': {'it': 'Religione', 'en': 'Religion', 'fr': 'Religion', 'es': 'Religión'},
  'password': {'it': 'Password', 'en': 'Password', 'fr': 'Mot de passe', 'es': 'Contraseña'},
  'edit_profile': {'it': 'Modifica Profilo', 'en': 'Edit Profile', 'fr': 'Modifier le profil', 'es': 'Editar perfil'},
  'years_old': {'it': 'anni', 'en': 'years old', 'fr': 'ans', 'es': 'años'},
  'guest': {'it': 'Ospite', 'en': 'Guest', 'fr': 'Invité', 'es': 'Invitado'},
  'account_security': {'it': 'Cartelle Private', 'en': 'Private Folders', 'fr': 'Dossiers privés', 'es': 'Carpetas privadas'},
  'social_links': {'it': 'Link Social', 'en': 'Social Links', 'fr': 'Liens sociaux', 'es': 'Enlaces sociales'},
  'friends': {'it': 'Amici', 'en': 'Friends', 'fr': 'Amis', 'es': 'Amigos'},
  'photo_history': {'it': 'Cronologia Foto', 'en': 'Photo History', 'fr': 'Historique des photos', 'es': 'Historial de fotos'},
  'add_friend': {'it': 'Aggiungi Amico', 'en': 'Add Friend', 'fr': 'Ajouter un ami', 'es': 'Añadir amigo'},
  'friend_name': {'it': 'Nome amico', 'en': 'Friend name', 'fr': 'Nom de l\'ami', 'es': 'Nombre del amigo'},
  'add_social_link': {'it': 'Aggiungi Link Social', 'en': 'Add Social Link', 'fr': 'Ajouter un lien social', 'es': 'Añadir enlace social'},
  'social_url': {'it': 'URL social (es. instagram.com/...)', 'en': 'Social URL (e.g. instagram.com/...)', 'fr': 'URL social (ex. instagram.com/...)', 'es': 'URL social (ej. instagram.com/...)'},
  'connected': {'it': 'Connesso', 'en': 'Connected', 'fr': 'Connecté', 'es': 'Conectado'},
  'not_connected': {'it': 'Non connesso', 'en': 'Not connected', 'fr': 'Non connecté', 'es': 'No conectado'},
  'connect': {'it': 'Connetti', 'en': 'Connect', 'fr': 'Connecter', 'es': 'Conectar'},
  'disconnect': {'it': 'Disconnetti', 'en': 'Disconnect', 'fr': 'Déconnecter', 'es': 'Desconectar'},

  // ── Calendar ──
  'events': {'it': 'Eventi', 'en': 'Events', 'fr': 'Événements', 'es': 'Eventos'},
  'event': {'it': 'Evento', 'en': 'Event', 'fr': 'Événement', 'es': 'Evento'},
  'new_event': {'it': 'Nuovo Evento', 'en': 'New Event', 'fr': 'Nouvel événement', 'es': 'Nuevo evento'},
  'edit_event': {'it': 'Modifica Evento', 'en': 'Edit Event', 'fr': 'Modifier l\'événement', 'es': 'Editar evento'},
  'event_title': {'it': 'Titolo evento', 'en': 'Event title', 'fr': 'Titre de l\'événement', 'es': 'Título del evento'},
  'start_time': {'it': 'Ora inizio', 'en': 'Start time', 'fr': 'Heure de début', 'es': 'Hora de inicio'},
  'end_time': {'it': 'Ora fine', 'en': 'End time', 'fr': 'Heure de fin', 'es': 'Hora de fin'},
  'calendar_name': {'it': 'Calendario', 'en': 'Calendar', 'fr': 'Calendrier', 'es': 'Calendario'},
  'reminder': {'it': 'Promemoria', 'en': 'Reminder', 'fr': 'Rappel', 'es': 'Recordatorio'},
  'no_reminder': {'it': 'Nessuno', 'en': 'None', 'fr': 'Aucun', 'es': 'Ninguno'},
  '5_min_before': {'it': '5 minuti prima', 'en': '5 minutes before', 'fr': '5 minutes avant', 'es': '5 minutos antes'},
  '15_min_before': {'it': '15 minuti prima', 'en': '15 minutes before', 'fr': '15 minutes avant', 'es': '15 minutos antes'},
  '30_min_before': {'it': '30 minuti prima', 'en': '30 minutes before', 'fr': '30 minutes avant', 'es': '30 minutos antes'},
  '1_hour_before': {'it': '1 ora prima', 'en': '1 hour before', 'fr': '1 heure avant', 'es': '1 hora antes'},
  '1_day_before': {'it': '1 giorno prima', 'en': '1 day before', 'fr': '1 jour avant', 'es': '1 día antes'},
  'personal': {'it': 'Personale', 'en': 'Personal', 'fr': 'Personnel', 'es': 'Personal'},
  'work': {'it': 'Lavoro', 'en': 'Work', 'fr': 'Travail', 'es': 'Trabajo'},
  'family': {'it': 'Famiglia', 'en': 'Family', 'fr': 'Famille', 'es': 'Familia'},
  'study': {'it': 'Studio', 'en': 'Study', 'fr': 'Études', 'es': 'Estudio'},
  'health': {'it': 'Salute', 'en': 'Health', 'fr': 'Santé', 'es': 'Salud'},
  'notes': {'it': 'Note', 'en': 'Notes', 'fr': 'Notes', 'es': 'Notas'},
  'attachment': {'it': 'Allegato', 'en': 'Attachment', 'fr': 'Pièce jointe', 'es': 'Adjunto'},
  'share_with': {'it': 'Condividi con', 'en': 'Share with', 'fr': 'Partager avec', 'es': 'Compartir con'},
  'no_events': {'it': 'Nessun evento', 'en': 'No events', 'fr': 'Aucun événement', 'es': 'Sin eventos'},
  'no_events_hint': {'it': 'Tocca + per aggiungere un evento', 'en': 'Tap + to add an event', 'fr': 'Appuyez sur + pour ajouter', 'es': 'Toca + para añadir un evento'},
  'search_events': {'it': 'Cerca eventi...', 'en': 'Search events...', 'fr': 'Rechercher des événements...', 'es': 'Buscar eventos...'},
  'no_events_for_day': {'it': 'Nessun evento per questo giorno', 'en': 'No events for this day', 'fr': 'Aucun événement pour ce jour', 'es': 'Sin eventos para este día'},
  'today': {'it': 'Oggi', 'en': 'Today', 'fr': 'Aujourd\'hui', 'es': 'Hoy'},
  'tomorrow': {'it': 'Domani', 'en': 'Tomorrow', 'fr': 'Demain', 'es': 'Mañana'},
  'yesterday': {'it': 'Ieri', 'en': 'Yesterday', 'fr': 'Hier', 'es': 'Ayer'},
  'month': {'it': 'Mese', 'en': 'Month', 'fr': 'Mois', 'es': 'Mes'},
  'week': {'it': 'Sett.', 'en': 'Week', 'fr': 'Sem.', 'es': 'Sem.'},
  'split_layout': {'it': 'Split', 'en': 'Split', 'fr': 'Divisé', 'es': 'Dividido'},
  'full_layout': {'it': 'Full', 'en': 'Full', 'fr': 'Plein', 'es': 'Completo'},
  'event_created': {'it': 'Evento creato', 'en': 'Event created', 'fr': 'Événement créé', 'es': 'Evento creado'},
  'event_saved': {'it': 'Evento salvato', 'en': 'Event saved', 'fr': 'Événement enregistré', 'es': 'Evento guardado'},
  'event_deleted': {'it': 'Evento eliminato', 'en': 'Event deleted', 'fr': 'Événement supprimé', 'es': 'Evento eliminado'},
  'delete_event_confirm': {'it': 'Eliminare questo evento?', 'en': 'Delete this event?', 'fr': 'Supprimer cet événement ?', 'es': '¿Eliminar este evento?'},
  'horoscope': {'it': 'Oroscopo', 'en': 'Horoscope', 'fr': 'Horoscope', 'es': 'Horóscopo'},
  'weather': {'it': 'Meteo', 'en': 'Weather', 'fr': 'Météo', 'es': 'Clima'},
  'holidays': {'it': 'Festività', 'en': 'Holidays', 'fr': 'Jours fériés', 'es': 'Festivos'},

  // ── Calendar Settings ──
  'show_horoscope': {'it': 'Mostra Oroscopo', 'en': 'Show Horoscope', 'fr': 'Afficher l\'horoscope', 'es': 'Mostrar horóscopo'},
  'show_weather': {'it': 'Mostra Meteo', 'en': 'Show Weather', 'fr': 'Afficher la météo', 'es': 'Mostrar clima'},
  'weather_in_calendar': {'it': 'Visualizza le previsioni nel calendario', 'en': 'Show forecast in calendar', 'fr': 'Afficher les prévisions dans le calendrier', 'es': 'Mostrar pronóstico en el calendario'},
  'weather_city': {'it': 'Città meteo', 'en': 'Weather city', 'fr': 'Ville météo', 'es': 'Ciudad del clima'},
  'show_zodiac': {'it': 'Mostra Segno Zodiacale', 'en': 'Show Zodiac Sign', 'fr': 'Afficher le signe du zodiaque', 'es': 'Mostrar signo zodiacal'},
  'zodiac_display': {'it': 'Visualizzazione Zodiacale', 'en': 'Zodiac Display', 'fr': 'Affichage du zodiaque', 'es': 'Visualización del zodíaco'},
  'icon_and_text': {'it': 'Icona e testo', 'en': 'Icon and text', 'fr': 'Icône et texte', 'es': 'Icono y texto'},
  'icon_only': {'it': 'Solo icona', 'en': 'Icon only', 'fr': 'Icône seule', 'es': 'Solo icono'},
  'text_only': {'it': 'Solo testo', 'en': 'Text only', 'fr': 'Texte seul', 'es': 'Solo texto'},
  'show_next_month': {'it': 'Anteprima Mese Successivo', 'en': 'Next Month Preview', 'fr': 'Aperçu mois suivant', 'es': 'Vista previa mes siguiente'},
  'calendar_layout': {'it': 'Layout Calendario', 'en': 'Calendar Layout', 'fr': 'Disposition du calendrier', 'es': 'Diseño del calendario'},
  'calendar_view': {'it': 'Vista Calendario', 'en': 'Calendar View', 'fr': 'Vue du calendrier', 'es': 'Vista del calendario'},
  'alert_sound': {'it': 'Suono Avviso', 'en': 'Alert Sound', 'fr': 'Son d\'alerte', 'es': 'Sonido de alerta'},
  'default_alert': {'it': 'Predefinito', 'en': 'Default', 'fr': 'Par défaut', 'es': 'Predeterminado'},
  'calendar_color': {'it': 'Colore Calendario', 'en': 'Calendar Color', 'fr': 'Couleur du calendrier', 'es': 'Color del calendario'},
  'font_family': {'it': 'Famiglia Font', 'en': 'Font Family', 'fr': 'Famille de police', 'es': 'Familia de fuente'},
  'header_font_size': {'it': 'Dimensione Font Intestazione', 'en': 'Header Font Size', 'fr': 'Taille de police de l\'en-tête', 'es': 'Tamaño de fuente del encabezado'},
  'header_color': {'it': 'Colore Intestazione', 'en': 'Header Color', 'fr': 'Couleur de l\'en-tête', 'es': 'Color del encabezado'},
  'alerts': {'it': 'Avvisi', 'en': 'Alerts', 'fr': 'Alertes', 'es': 'Alertas'},
  'colors_and_fonts': {'it': 'Colori e Font', 'en': 'Colors & Fonts', 'fr': 'Couleurs et polices', 'es': 'Colores y fuentes'},
  'cycle_tracking': {'it': 'Tracciamento Ciclo', 'en': 'Cycle Tracking', 'fr': 'Suivi du cycle', 'es': 'Seguimiento del ciclo'},
  'show_cycle_tracking': {'it': 'Mostra Tracciamento Ciclo', 'en': 'Show Cycle Tracking', 'fr': 'Afficher le suivi du cycle', 'es': 'Mostrar seguimiento del ciclo'},
  'cycle_length': {'it': 'Durata Ciclo (giorni)', 'en': 'Cycle Length (days)', 'fr': 'Durée du cycle (jours)', 'es': 'Duración del ciclo (días)'},
  'period_length': {'it': 'Durata Mestruazione (giorni)', 'en': 'Period Length (days)', 'fr': 'Durée des règles (jours)', 'es': 'Duración del periodo (días)'},
  'mark_period_day': {'it': 'Segna giorno ciclo', 'en': 'Mark period day', 'fr': 'Marquer jour de règles', 'es': 'Marcar día del periodo'},
  'unmark_period_day': {'it': 'Rimuovi giorno ciclo', 'en': 'Unmark period day', 'fr': 'Retirer jour de règles', 'es': 'Quitar día del periodo'},
  'period_day': {'it': 'Giorno ciclo', 'en': 'Period day', 'fr': 'Jour de règles', 'es': 'Día del periodo'},
  'fertile_window': {'it': 'Finestra fertile', 'en': 'Fertile window', 'fr': 'Fenêtre de fertilité', 'es': 'Ventana fértil'},
  'predicted_period': {'it': 'Ciclo previsto', 'en': 'Predicted period', 'fr': 'Règles prévues', 'es': 'Periodo previsto'},
  'ovulation_day': {'it': 'Giorno ovulazione', 'en': 'Ovulation day', 'fr': 'Jour d\'ovulation', 'es': 'Día de ovulación'},
  'cycle_duration_days': {'it': 'Durata media del flusso', 'en': 'Average flow duration', 'fr': 'Durée moyenne du flux', 'es': 'Duración media del flujo'},
  'cycle_reminder': {'it': 'Promemoria giorno prima', 'en': 'Reminder day before', 'fr': 'Rappel la veille', 'es': 'Recordatorio el día antes'},
  'cycle_reminder_sub': {'it': 'Notifica il giorno prima del ciclo previsto', 'en': 'Notification the day before the predicted period', 'fr': 'Notification la veille des règles prévues', 'es': 'Notificación el día antes del periodo previsto'},
  'next_cycle_predicted': {'it': 'Prossimo ciclo previsto', 'en': 'Next predicted period', 'fr': 'Prochaines règles prévues', 'es': 'Próximo periodo previsto'},
  'cycle_diary_created': {'it': 'Report ciclo creato', 'en': 'Cycle report created', 'fr': 'Rapport de cycle créé', 'es': 'Informe del ciclo creado'},
  'no_cycle_data': {'it': 'Segna i giorni del ciclo nel calendario per attivare le previsioni', 'en': 'Mark period days on the calendar to enable predictions', 'fr': 'Marquez les jours de règles sur le calendrier pour activer les prévisions', 'es': 'Marca los días del periodo en el calendario para activar las predicciones'},
  'cycle_report': {'it': 'Report Ciclo', 'en': 'Cycle Report', 'fr': 'Rapport du Cycle', 'es': 'Informe del Ciclo'},
  'cycle_report_fill': {'it': 'Compila il Report del Ciclo', 'en': 'Fill in the Cycle Report', 'fr': 'Remplir le rapport du cycle', 'es': 'Rellenar el informe del ciclo'},
  'cycle_report_fill_sub': {'it': 'Hai 2 giorni per compilarlo', 'en': 'You have 2 days to fill it in', 'fr': 'Vous avez 2 jours pour le remplir', 'es': 'Tienes 2 días para rellenarlo'},
  'cycle_q_timing': {'it': 'Quando è arrivato il ciclo?', 'en': 'When did your period arrive?', 'fr': 'Quand tes règles sont arrivées ?', 'es': '¿Cuándo llegó tu periodo?'},
  'cycle_q_timing_early': {'it': 'In anticipo', 'en': 'Early', 'fr': 'En avance', 'es': 'Temprano'},
  'cycle_q_timing_ontime': {'it': 'Puntuale', 'en': 'On time', 'fr': 'À l\'heure', 'es': 'Puntual'},
  'cycle_q_timing_late': {'it': 'In ritardo', 'en': 'Late', 'fr': 'En retard', 'es': 'Tarde'},
  'cycle_q_flow': {'it': 'Flusso', 'en': 'Flow', 'fr': 'Flux', 'es': 'Flujo'},
  'cycle_q_flow_light': {'it': 'Poco', 'en': 'Light', 'fr': 'Léger', 'es': 'Poco'},
  'cycle_q_flow_medium': {'it': 'Medio', 'en': 'Medium', 'fr': 'Moyen', 'es': 'Medio'},
  'cycle_q_flow_heavy': {'it': 'Molto', 'en': 'Heavy', 'fr': 'Abondant', 'es': 'Mucho'},
  'cycle_q_flow_very_heavy': {'it': 'Moltissimo', 'en': 'Very heavy', 'fr': 'Très abondant', 'es': 'Muchísimo'},
  'cycle_q_symptoms': {'it': 'Sintomi', 'en': 'Symptoms', 'fr': 'Symptômes', 'es': 'Síntomas'},
  'cycle_q_energy': {'it': 'Livelli di energia durante il ciclo?', 'en': 'Energy levels during your period?', 'fr': 'Niveaux d\'énergie pendant les règles ?', 'es': '¿Niveles de energía durante el periodo?'},
  'cycle_q_energy_low': {'it': 'Poco', 'en': 'Low', 'fr': 'Faible', 'es': 'Bajo'},
  'cycle_q_energy_normal': {'it': 'Normale', 'en': 'Normal', 'fr': 'Normal', 'es': 'Normal'},
  'cycle_q_energy_high': {'it': 'Molta', 'en': 'High', 'fr': 'Élevé', 'es': 'Alto'},
  'cycle_q_cravings': {'it': 'Di cosa ti è venuta voglia?', 'en': 'What did you crave?', 'fr': 'De quoi avais-tu envie ?', 'es': '¿De qué tuviste antojo?'},
  'cycle_q_cravings_other': {'it': 'Altro...', 'en': 'Other...', 'fr': 'Autre...', 'es': 'Otro...'},
  'cycle_q_sleep': {'it': 'Sonno', 'en': 'Sleep', 'fr': 'Sommeil', 'es': 'Sueño'},
  'cycle_q_sleep_normal': {'it': 'Normale', 'en': 'Normal', 'fr': 'Normal', 'es': 'Normal'},
  'cycle_q_sleep_deep': {'it': 'Profondo', 'en': 'Deep', 'fr': 'Profond', 'es': 'Profundo'},
  'cycle_q_sleep_restless': {'it': 'Irrequieto', 'en': 'Restless', 'fr': 'Agité', 'es': 'Inquieto'},
  'cycle_q_sleep_insomnia': {'it': 'Insonnia', 'en': 'Insomnia', 'fr': 'Insomnie', 'es': 'Insomnio'},
  'cycle_q_emotions': {'it': 'Emozioni dominanti', 'en': 'Dominant emotions', 'fr': 'Émotions dominantes', 'es': 'Emociones dominantes'},
  'cycle_q_emotions_calm': {'it': 'Calma', 'en': 'Calm', 'fr': 'Calme', 'es': 'Calma'},
  'cycle_q_emotions_irritable': {'it': 'Irritabilità', 'en': 'Irritability', 'fr': 'Irritabilité', 'es': 'Irritabilidad'},
  'cycle_q_emotions_sensitive': {'it': 'Sensibilità', 'en': 'Sensitivity', 'fr': 'Sensibilité', 'es': 'Sensibilidad'},
  'cycle_q_emotions_sad': {'it': 'Tristezza', 'en': 'Sadness', 'fr': 'Tristesse', 'es': 'Tristeza'},
  'cycle_q_notes': {'it': 'Appunti', 'en': 'Notes', 'fr': 'Notes', 'es': 'Notas'},
  'cycle_q_notes_hint': {'it': 'Scrivi quello che vuoi...', 'en': 'Write whatever you want...', 'fr': 'Écris ce que tu veux...', 'es': 'Escribe lo que quieras...'},
  'cycle_report_saved': {'it': 'Report ciclo salvato', 'en': 'Cycle report saved', 'fr': 'Rapport du cycle sauvegardé', 'es': 'Informe del ciclo guardado'},
  'cycle_set_next_date': {'it': 'Data prevista prossimo ciclo', 'en': 'Expected next period date', 'fr': 'Date prévue des prochaines règles', 'es': 'Fecha prevista del próximo periodo'},
  'cycle_set_next_date_sub': {'it': 'Imposta quando prevedi il prossimo ciclo', 'en': 'Set when you expect your next period', 'fr': 'Définir quand vous attendez vos prochaines règles', 'es': 'Establece cuándo esperas tu próximo periodo'},
  'cycle_test_questionnaire': {'it': 'Prova questionario', 'en': 'Test questionnaire', 'fr': 'Tester le questionnaire', 'es': 'Probar cuestionario'},
  'cycle_ended_notif': {'it': 'Il tuo ciclo è terminato — Come è andata?', 'en': 'Your period ended — How did it go?', 'fr': 'Tes règles sont terminées — Comment ça s\'est passé ?', 'es': 'Tu periodo terminó — ¿Cómo te fue?'},
  'cycle_missing': {'it': 'Ciclo mancante', 'en': 'Missing period', 'fr': 'Règles manquées', 'es': 'Periodo faltante'},
  'cycle_missing_why': {'it': 'Perché non hai segnato il ciclo?', 'en': 'Why didn\'t you mark your period?', 'fr': 'Pourquoi n\'as-tu pas marqué tes règles ?', 'es': '¿Por qué no marcaste tu periodo?'},
  'cycle_missing_arrived': {'it': 'È arrivato ma non l\'ho segnato', 'en': 'It arrived but I didn\'t mark it', 'fr': 'Il est arrivé mais je ne l\'ai pas marqué', 'es': 'Llegó pero no lo marqué'},
  'cycle_missing_not_yet': {'it': 'Non è ancora arrivato', 'en': 'It hasn\'t arrived yet', 'fr': 'Il n\'est pas encore arrivé', 'es': 'Aún no ha llegado'},
  'cycle_missing_pregnant': {'it': 'Sono incinta', 'en': 'I\'m pregnant', 'fr': 'Je suis enceinte', 'es': 'Estoy embarazada'},
  'cycle_missing_other': {'it': 'Altro', 'en': 'Other', 'fr': 'Autre', 'es': 'Otro'},
  'cycle_mark_days_or_skip': {'it': 'Vuoi segnare i giorni del ciclo prima di compilare il report?', 'en': 'Do you want to mark the cycle days before filling in the report?', 'fr': 'Veux-tu marquer les jours du cycle avant de remplir le rapport ?', 'es': '¿Quieres marcar los días del periodo antes de rellenar el informe?'},
  'cycle_mark_days': {'it': 'Segna i giorni', 'en': 'Mark the days', 'fr': 'Marquer les jours', 'es': 'Marcar los días'},
  'cycle_skip_to_report': {'it': 'Vai al questionario', 'en': 'Go to questionnaire', 'fr': 'Aller au questionnaire', 'es': 'Ir al cuestionario'},
  'cycle_predictions_disabled': {'it': 'Le previsioni ciclo sono state disattivate', 'en': 'Cycle predictions have been disabled', 'fr': 'Les prévisions de cycle ont été désactivées', 'es': 'Las predicciones del ciclo han sido desactivadas'},
  'cycle_diary_folder': {'it': 'Diario del Ciclo', 'en': 'Cycle Diary', 'fr': 'Journal du Cycle', 'es': 'Diario del Ciclo'},

  // ── Deep Note ──
  'new_note': {'it': 'Nuova nota', 'en': 'New note', 'fr': 'Nouvelle note', 'es': 'Nueva nota'},
  'no_notes': {'it': 'Nessuna nota', 'en': 'No notes', 'fr': 'Aucune note', 'es': 'Sin notas'},
  'no_notes_yet': {'it': 'Nessuna nota ancora.\nTocca + per iniziare!', 'en': 'No notes yet.\nTap + to get started!', 'fr': 'Aucune note pour l\'instant.\nAppuyez sur + pour commencer !', 'es': 'Sin notas aún.\n¡Toca + para empezar!'},
  'folder': {'it': 'Cartella', 'en': 'Folder', 'fr': 'Dossier', 'es': 'Carpeta'},
  'folders': {'it': 'Cartelle', 'en': 'Folders', 'fr': 'Dossiers', 'es': 'Carpetas'},
  'general': {'it': 'Generale', 'en': 'General', 'fr': 'Général', 'es': 'General'},
  'private': {'it': 'Privata', 'en': 'Private', 'fr': 'Privé', 'es': 'Privada'},
  'new_folder': {'it': 'Nuova Cartella', 'en': 'New Folder', 'fr': 'Nouveau dossier', 'es': 'Nueva carpeta'},
  'folder_name': {'it': 'Nome cartella', 'en': 'Folder name', 'fr': 'Nom du dossier', 'es': 'Nombre de la carpeta'},
  'move_to_folder': {'it': 'Sposta in cartella', 'en': 'Move to folder', 'fr': 'Déplacer vers le dossier', 'es': 'Mover a carpeta'},
  'change_folder': {'it': 'Cambia cartella', 'en': 'Change folder', 'fr': 'Changer de dossier', 'es': 'Cambiar carpeta'},
  'account': {'it': 'Account', 'en': 'Account', 'fr': 'Compte', 'es': 'Cuenta'},
  'untitled': {'it': 'Senza titolo', 'en': 'Untitled', 'fr': 'Sans titre', 'es': 'Sin título'},
  'title': {'it': 'Titolo', 'en': 'Title', 'fr': 'Titre', 'es': 'Título'},
  'content': {'it': 'Contenuto', 'en': 'Content', 'fr': 'Contenu', 'es': 'Contenido'},
  'search_notes': {'it': 'Cerca deep note...', 'en': 'Search deep notes...', 'fr': 'Rechercher deep notes...', 'es': 'Buscar deep notes...'},
  'delete_note_confirm': {'it': 'Eliminare questa nota?', 'en': 'Delete this note?', 'fr': 'Supprimer cette note ?', 'es': '¿Eliminar esta nota?'},
  'note_deleted': {'it': 'Nota eliminata', 'en': 'Note deleted', 'fr': 'Note supprimée', 'es': 'Nota eliminada'},
  'notes_deleted': {'it': 'Note eliminate', 'en': 'Notes deleted', 'fr': 'Notes supprimées', 'es': 'Notas eliminadas'},
  'permanently_deleted': {'it': 'Eliminato definitivamente', 'en': 'Permanently deleted', 'fr': 'Supprimé définitivement', 'es': 'Eliminado permanentemente'},
  'note_moved_to_trash': {'it': 'Nota spostata nel cestino', 'en': 'Note moved to trash', 'fr': 'Note déplacée dans la corbeille', 'es': 'Nota movida a la papelera'},
  'open_in_deep_note': {'it': 'Apri in Deep Note', 'en': 'Open in Deep Note', 'fr': 'Ouvrir dans Deep Note', 'es': 'Abrir en Deep Note'},
  'create_event': {'it': 'Crea Evento', 'en': 'Create Event', 'fr': 'Créer un événement', 'es': 'Crear evento'},
  'header': {'it': 'Intestazione', 'en': 'Header', 'fr': 'En-tête', 'es': 'Encabezado'},
  'footer': {'it': 'Piè di pagina', 'en': 'Footer', 'fr': 'Pied de page', 'es': 'Pie de página'},
  'pdf': {'it': 'PDF', 'en': 'PDF', 'fr': 'PDF', 'es': 'PDF'},
  'export_pdf': {'it': 'Esporta PDF', 'en': 'Export PDF', 'fr': 'Exporter en PDF', 'es': 'Exportar PDF'},
  'pdf_show_logo': {'it': 'Logo Deep Note nel PDF', 'en': 'Deep Note logo in PDF', 'fr': 'Logo Deep Note dans le PDF', 'es': 'Logo Deep Note en PDF'},
  'pdf_show_logo_desc': {'it': 'Mostra il logo in basso a destra di ogni pagina', 'en': 'Show logo at the bottom right of each page', 'fr': 'Afficher le logo en bas à droite de chaque page', 'es': 'Mostrar el logo en la parte inferior derecha de cada página'},
  'print': {'it': 'Stampa', 'en': 'Print', 'fr': 'Imprimer', 'es': 'Imprimir'},
  'pin_security': {'it': 'PIN di sicurezza', 'en': 'Security PIN', 'fr': 'PIN de sécurité', 'es': 'PIN de seguridad'},
  'enter_pin': {'it': 'Inserisci PIN', 'en': 'Enter PIN', 'fr': 'Entrez le PIN', 'es': 'Introduce el PIN'},
  'wrong_pin': {'it': 'PIN errato', 'en': 'Wrong PIN', 'fr': 'PIN incorrect', 'es': 'PIN incorrecto'},
  'grid_view': {'it': 'Griglia', 'en': 'Grid', 'fr': 'Grille', 'es': 'Cuadrícula'},
  'list_view': {'it': 'Lista', 'en': 'List', 'fr': 'Liste', 'es': 'Lista'},

  // ── Deep Note Settings ──
  'show_private_folder': {'it': 'Mostra Cartella Privata', 'en': 'Show Private Folder', 'fr': 'Afficher le dossier privé', 'es': 'Mostrar carpeta privada'},
  'security_pin': {'it': 'PIN Sicurezza', 'en': 'Security PIN', 'fr': 'PIN de sécurité', 'es': 'PIN de seguridad'},
  'pdf_save_mode': {'it': 'Salvataggio PDF', 'en': 'PDF Save Mode', 'fr': 'Mode de sauvegarde PDF', 'es': 'Modo de guardado PDF'},
  'enable_trash': {'it': 'Abilita Cestino', 'en': 'Enable Trash', 'fr': 'Activer la corbeille', 'es': 'Activar papelera'},
  'trash_retention': {'it': 'Giorni conservazione cestino', 'en': 'Trash retention days', 'fr': 'Jours de conservation de la corbeille', 'es': 'Días de retención de papelera'},
  'downloaded_fonts': {'it': 'Font Scaricati', 'en': 'Downloaded Fonts', 'fr': 'Polices téléchargées', 'es': 'Fuentes descargadas'},
  'custom_templates': {'it': 'Template Personalizzati', 'en': 'Custom Templates', 'fr': 'Modèles personnalisés', 'es': 'Plantillas personalizadas'},
  'template': {'it': 'Template', 'en': 'Template', 'fr': 'Modèle', 'es': 'Plantilla'},

  // ── Templates ──
  'formal_letter': {'it': 'Lettera Formale', 'en': 'Formal Letter', 'fr': 'Lettre formelle', 'es': 'Carta formal'},
  'business_letter': {'it': 'Lettera Commerciale', 'en': 'Business Letter', 'fr': 'Lettre commerciale', 'es': 'Carta comercial'},
  'quote_letter': {'it': 'Preventivo', 'en': 'Quote', 'fr': 'Devis', 'es': 'Presupuesto'},
  'reminder_letter': {'it': 'Sollecito', 'en': 'Reminder', 'fr': 'Relance', 'es': 'Recordatorio'},

  // ── Flash Notes ──
  'flash_note': {'it': 'Flash Note', 'en': 'Flash Note', 'fr': 'Flash Note', 'es': 'Flash Note'},
  'new_flash_note': {'it': 'Nuova flash note...', 'en': 'New flash note...', 'fr': 'Nouvelle flash note...', 'es': 'Nueva flash note...'},
  'no_flash_notes': {'it': 'Nessuna flash note', 'en': 'No flash notes', 'fr': 'Aucune flash note', 'es': 'Sin flash notes'},
  'no_flash_notes_yet': {'it': 'Nessuna flash note ancora.\nScrivi la tua prima nota veloce!', 'en': 'No flash notes yet.\nWrite your first quick note!', 'fr': 'Aucune flash note pour l\'instant.\nÉcrivez votre première note rapide !', 'es': 'Sin flash notes aún.\n¡Escribe tu primera nota rápida!'},
  'search_flash_notes': {'it': 'Cerca flash notes...', 'en': 'Search flash notes...', 'fr': 'Rechercher des flash notes...', 'es': 'Buscar flash notes...'},
  'delete_flash_confirm': {'it': 'Eliminare questa flash note?', 'en': 'Delete this flash note?', 'fr': 'Supprimer cette flash note ?', 'es': '¿Eliminar esta flash note?'},

  // ── Flash Notes Settings ──
  'gemini_ai': {'it': 'Gemini AI', 'en': 'Gemini AI', 'fr': 'Gemini AI', 'es': 'Gemini AI'},
  'enable_gemini': {'it': 'Abilita Gemini AI', 'en': 'Enable Gemini AI', 'fr': 'Activer Gemini AI', 'es': 'Activar Gemini AI'},
  'api_key': {'it': 'Chiave API', 'en': 'API Key', 'fr': 'Clé API', 'es': 'Clave API'},
  'auto_save': {'it': 'Salvataggio Automatico', 'en': 'Auto Save', 'fr': 'Sauvegarde automatique', 'es': 'Guardado automático'},
  'auto_save_never': {'it': 'Sempre lì', 'en': 'Always there', 'fr': 'Toujours là', 'es': 'Siempre ahí'},
  'no_auto_save': {'it': 'Nessun salvataggio automatico', 'en': 'No auto save', 'fr': 'Pas de sauvegarde automatique', 'es': 'Sin guardado automático'},
  'auto_save_weekly': {'it': 'Settimanale', 'en': 'Weekly', 'fr': 'Hebdomadaire', 'es': 'Semanal'},
  'auto_save_weekly_desc': {'it': 'Salva in Deep Note ogni settimana', 'en': 'Save to Deep Note every week', 'fr': 'Enregistrer dans Deep Note chaque semaine', 'es': 'Guardar en Deep Note cada semana'},
  'auto_save_monthly': {'it': 'Mensile', 'en': 'Monthly', 'fr': 'Mensuel', 'es': 'Mensual'},
  'auto_save_monthly_desc': {'it': 'Salva in Deep Note ogni mese', 'en': 'Save to Deep Note every month', 'fr': 'Enregistrer dans Deep Note chaque mois', 'es': 'Guardar en Deep Note cada mes'},
  'formatting_preset': {'it': 'Preset Formattazione', 'en': 'Formatting Preset', 'fr': 'Préréglage de mise en forme', 'es': 'Ajuste de formato'},
  'simple': {'it': 'Semplice', 'en': 'Simple', 'fr': 'Simple', 'es': 'Simple'},
  'markdown': {'it': 'Markdown', 'en': 'Markdown', 'fr': 'Markdown', 'es': 'Markdown'},
  'rich': {'it': 'Ricco', 'en': 'Rich', 'fr': 'Riche', 'es': 'Rico'},
  'ai_correction_level': {'it': 'Livello Correzione AI', 'en': 'AI Correction Level', 'fr': 'Niveau de correction IA', 'es': 'Nivel de corrección IA'},
  'note_style': {'it': 'Stile Note', 'en': 'Note Style', 'fr': 'Style des notes', 'es': 'Estilo de notas'},
  'note_style_modern': {'it': 'Moderno', 'en': 'Modern', 'fr': 'Moderne', 'es': 'Moderno'},
  'note_style_paper': {'it': 'Paper & Sticky', 'en': 'Paper & Sticky', 'fr': 'Paper & Sticky', 'es': 'Paper & Sticky'},
  'note_style_paper_desc': {'it': 'Aspetto Post-it con texture carta riciclata', 'en': 'Post-it look with recycled paper texture', 'fr': 'Aspect Post-it avec texture papier recyclé', 'es': 'Aspecto Post-it con textura de papel reciclado'},
  'grouping_mode': {'it': 'Modalità Raggruppamento', 'en': 'Grouping Mode', 'fr': 'Mode de regroupement', 'es': 'Modo de agrupación'},
  'daily': {'it': 'Giornaliero', 'en': 'Daily', 'fr': 'Quotidien', 'es': 'Diario'},
  'weekly': {'it': 'Settimanale', 'en': 'Weekly', 'fr': 'Hebdomadaire', 'es': 'Semanal'},
  'monthly': {'it': 'Mensile', 'en': 'Monthly', 'fr': 'Mensuel', 'es': 'Mensual'},

  // ── Photo Recognition ──
  'photo_recognition': {'it': 'Riconoscimento Foto AI', 'en': 'AI Photo Recognition', 'fr': 'Reconnaissance photo IA', 'es': 'Reconocimiento de fotos IA'},
  'photo_recognition_desc': {'it': 'Analizza le foto con Gemini per estrarre dati e salvarli in Deep Note', 'en': 'Analyze photos with Gemini to extract data and save to Deep Note', 'fr': 'Analyser les photos avec Gemini pour extraire des données et enregistrer dans Deep Note', 'es': 'Analizar fotos con Gemini para extraer datos y guardar en Deep Note'},
  'analyzing_photo': {'it': 'Analisi foto in corso...', 'en': 'Analyzing photo...', 'fr': 'Analyse de la photo...', 'es': 'Analizando foto...'},
  'photo_recognized': {'it': 'Foto riconosciuta', 'en': 'Photo recognized', 'fr': 'Photo reconnue', 'es': 'Foto reconocida'},
  'gemini_not_configured': {'it': 'Configura Gemini AI nelle impostazioni Flash Notes per usare il riconoscimento foto', 'en': 'Configure Gemini AI in Flash Notes settings to use photo recognition', 'fr': 'Configurez Gemini AI dans les paramètres Flash Notes pour utiliser la reconnaissance photo', 'es': 'Configura Gemini AI en los ajustes de Flash Notes para usar el reconocimiento de fotos'},
  'photo_recognition_failed': {'it': 'Riconoscimento foto fallito. Controlla la API key di Gemini.', 'en': 'Photo recognition failed. Check your Gemini API key.', 'fr': 'Reconnaissance photo échouée. Vérifiez votre clé API Gemini.', 'es': 'Reconocimiento de foto fallido. Comprueba tu clave API de Gemini.'},
  'photo_normal': {'it': 'Foto normale — nessun documento rilevato', 'en': 'Normal photo — no document detected', 'fr': 'Photo normale — aucun document détecté', 'es': 'Foto normal — ningún documento detectado'},
  'server_busy': {'it': 'Server Gemini sovraccarico. Riprova tra qualche secondo.', 'en': 'Gemini server overloaded. Try again in a few seconds.', 'fr': 'Serveur Gemini surchargé. Réessayez dans quelques secondes.', 'es': 'Servidor Gemini sobrecargado. Intenta de nuevo en unos segundos.'},
  'quota_exceeded': {'it': 'Quota API Gemini esaurita. Attendi qualche minuto o verifica il tuo piano.', 'en': 'Gemini API quota exceeded. Wait a few minutes or check your plan.', 'fr': 'Quota API Gemini épuisée. Attendez quelques minutes ou vérifiez votre plan.', 'es': 'Cuota de API Gemini agotada. Espera unos minutos o verifica tu plan.'},
  'business_card': {'it': 'Biglietto da Visita', 'en': 'Business Card', 'fr': 'Carte de visite', 'es': 'Tarjeta de visita'},
  'receipt': {'it': 'Ricevuta', 'en': 'Receipt', 'fr': 'Reçu', 'es': 'Recibo'},
  'document': {'it': 'Documento', 'en': 'Document', 'fr': 'Document', 'es': 'Documento'},
  'handwritten_note': {'it': 'Appunto scritto a mano', 'en': 'Handwritten note', 'fr': 'Note manuscrite', 'es': 'Nota manuscrita'},
  'normal_photo': {'it': 'Foto normale', 'en': 'Normal photo', 'fr': 'Photo normale', 'es': 'Foto normal'},
  'save_to_deep_note': {'it': 'Salva in Deep Note', 'en': 'Save to Deep Note', 'fr': 'Enregistrer dans Deep Note', 'es': 'Guardar en Deep Note'},
  'keep_as_flash': {'it': 'Mantieni come Flash Note', 'en': 'Keep as Flash Note', 'fr': 'Garder comme Flash Note', 'es': 'Mantener como Flash Note'},
  'category_detected': {'it': 'Categoria rilevata', 'en': 'Category detected', 'fr': 'Catégorie détectée', 'es': 'Categoría detectada'},
  'recognition_failed': {'it': 'Riconoscimento non riuscito', 'en': 'Recognition failed', 'fr': 'Reconnaissance échouée', 'es': 'Reconocimiento fallido'},
  'extracted_data': {'it': 'Dati estratti', 'en': 'Extracted data', 'fr': 'Données extraites', 'es': 'Datos extraídos'},
  'saved_to_deep_note': {'it': 'Salvato in Deep Note', 'en': 'Saved to Deep Note', 'fr': 'Enregistré dans Deep Note', 'es': 'Guardado en Deep Note'},
  'save_to_contacts': {'it': 'Salva in Rubrica', 'en': 'Save to Contacts', 'fr': 'Enregistrer dans les contacts', 'es': 'Guardar en contactos'},
  'saved_to_contacts': {'it': 'Contatto salvato in rubrica', 'en': 'Contact saved', 'fr': 'Contact enregistré', 'es': 'Contacto guardado'},
  'contact_form_title': {'it': 'Nuovo Contatto', 'en': 'New Contact', 'fr': 'Nouveau contact', 'es': 'Nuevo contacto'},
  'company': {'it': 'Azienda', 'en': 'Company', 'fr': 'Entreprise', 'es': 'Empresa'},
  'role_title': {'it': 'Ruolo', 'en': 'Role', 'fr': 'Rôle', 'es': 'Cargo'},
  'address': {'it': 'Indirizzo', 'en': 'Address', 'fr': 'Adresse', 'es': 'Dirección'},
  'street': {'it': 'Via', 'en': 'Street', 'fr': 'Rue', 'es': 'Calle'},
  'city': {'it': 'Città', 'en': 'City', 'fr': 'Ville', 'es': 'Ciudad'},
  'postal_code': {'it': 'CAP', 'en': 'Postal Code', 'fr': 'Code postal', 'es': 'Código postal'},
  'province': {'it': 'Provincia', 'en': 'Province', 'fr': 'Province', 'es': 'Provincia'},
  'add_phone': {'it': 'Aggiungi telefono', 'en': 'Add phone', 'fr': 'Ajouter téléphone', 'es': 'Añadir teléfono'},
  'add_email': {'it': 'Aggiungi email', 'en': 'Add email', 'fr': 'Ajouter email', 'es': 'Añadir email'},
  'website': {'it': 'Sito Web', 'en': 'Website', 'fr': 'Site web', 'es': 'Sitio web'},
  'contacts_permission_denied': {'it': 'Permesso contatti negato', 'en': 'Contacts permission denied', 'fr': 'Autorisation contacts refusée', 'es': 'Permiso de contactos denegado'},

  // ── Trash ──
  'empty_trash': {'it': 'Svuota Cestino', 'en': 'Empty Trash', 'fr': 'Vider la corbeille', 'es': 'Vaciar papelera'},
  'empty_trash_confirm': {'it': 'Svuotare il cestino? Tutti gli elementi verranno eliminati definitivamente.', 'en': 'Empty trash? All items will be permanently deleted.', 'fr': 'Vider la corbeille ? Tous les éléments seront définitivement supprimés.', 'es': '¿Vaciar papelera? Todos los elementos se eliminarán permanentemente.'},
  'no_trash': {'it': 'Il cestino è vuoto', 'en': 'Trash is empty', 'fr': 'La corbeille est vide', 'es': 'La papelera está vacía'},
  'restore_note': {'it': 'Ripristina nota', 'en': 'Restore note', 'fr': 'Restaurer la note', 'es': 'Restaurar nota'},
  'delete_permanently': {'it': 'Elimina definitivamente', 'en': 'Delete permanently', 'fr': 'Supprimer définitivement', 'es': 'Eliminar permanentemente'},
  'deleted_on': {'it': 'Eliminata il', 'en': 'Deleted on', 'fr': 'Supprimé le', 'es': 'Eliminado el'},
  'note_restored': {'it': 'Nota ripristinata', 'en': 'Note restored', 'fr': 'Note restaurée', 'es': 'Nota restaurada'},
  'event_restored': {'it': 'Evento ripristinato', 'en': 'Event restored', 'fr': 'Événement restauré', 'es': 'Evento restaurado'},

  // ── Dialogs & messages ──
  'error': {'it': 'Errore', 'en': 'Error', 'fr': 'Erreur', 'es': 'Error'},
  'success': {'it': 'Successo', 'en': 'Success', 'fr': 'Succès', 'es': 'Éxito'},
  'warning': {'it': 'Attenzione', 'en': 'Warning', 'fr': 'Attention', 'es': 'Advertencia'},
  'loading': {'it': 'Caricamento...', 'en': 'Loading...', 'fr': 'Chargement...', 'es': 'Cargando...'},
  'no_results': {'it': 'Nessun risultato', 'en': 'No results', 'fr': 'Aucun résultat', 'es': 'Sin resultados'},
  'file_too_large': {'it': 'File troppo grande (max 20MB)', 'en': 'File too large (max 20MB)', 'fr': 'Fichier trop volumineux (max 20Mo)', 'es': 'Archivo demasiado grande (máx 20MB)'},
  'copied_to_clipboard': {'it': 'Copiato negli appunti', 'en': 'Copied to clipboard', 'fr': 'Copié dans le presse-papiers', 'es': 'Copiado al portapapeles'},
  'photo_error': {'it': 'Errore nel caricamento della foto', 'en': 'Error loading photo', 'fr': 'Erreur de chargement de la photo', 'es': 'Error al cargar la foto'},
  'delete_all_data': {'it': 'Tutti i dati verranno eliminati', 'en': 'All data will be deleted', 'fr': 'Toutes les données seront supprimées', 'es': 'Todos los datos se eliminarán'},
  'reason_for_leaving': {'it': 'Motivo della cancellazione', 'en': 'Reason for leaving', 'fr': 'Motif de la suppression', 'es': 'Motivo de la cancelación'},
  'not_using_anymore': {'it': 'Non uso più l\'app', 'en': 'I no longer use the app', 'fr': 'Je n\'utilise plus l\'application', 'es': 'Ya no uso la app'},
  'found_better_app': {'it': 'Ho trovato un\'app migliore', 'en': 'I found a better app', 'fr': 'J\'ai trouvé une meilleure application', 'es': 'Encontré una app mejor'},
  'privacy_concerns': {'it': 'Problemi di privacy', 'en': 'Privacy concerns', 'fr': 'Problèmes de confidentialité', 'es': 'Problemas de privacidad'},
  'too_many_bugs': {'it': 'Troppi bug', 'en': 'Too many bugs', 'fr': 'Trop de bugs', 'es': 'Demasiados errores'},
  'other': {'it': 'Altro', 'en': 'Other', 'fr': 'Autre', 'es': 'Otro'},

  // ── Voice / Audio ──
  'voice_note': {'it': 'Nota vocale', 'en': 'Voice note', 'fr': 'Note vocale', 'es': 'Nota de voz'},
  'voice_note_saved': {'it': 'Nota vocale salvata', 'en': 'Voice note saved', 'fr': 'Note vocale enregistrée', 'es': 'Nota de voz guardada'},
  'recording': {'it': 'Registrazione...', 'en': 'Recording...', 'fr': 'Enregistrement...', 'es': 'Grabando...'},
  'stop_recording': {'it': 'Ferma registrazione', 'en': 'Stop recording', 'fr': 'Arrêter l\'enregistrement', 'es': 'Detener grabación'},
  'play': {'it': 'Riproduci', 'en': 'Play', 'fr': 'Lire', 'es': 'Reproducir'},
  'pause': {'it': 'Pausa', 'en': 'Pause', 'fr': 'Pause', 'es': 'Pausar'},

  // ── Color picker ──
  'pick_color': {'it': 'Scegli Colore', 'en': 'Pick Color', 'fr': 'Choisir la couleur', 'es': 'Elegir color'},
  'hex_color': {'it': 'Codice HEX', 'en': 'HEX Code', 'fr': 'Code HEX', 'es': 'Código HEX'},

  // ── Misc ──
  'undo': {'it': 'Annulla', 'en': 'Undo', 'fr': 'Annuler', 'es': 'Deshacer'},
  'confirm_delete': {'it': 'Conferma eliminazione', 'en': 'Confirm deletion', 'fr': 'Confirmer la suppression', 'es': 'Confirmar eliminación'},
  'n_notes': {'it': '{n} note', 'en': '{n} notes', 'fr': '{n} notes', 'es': '{n} notas'},
  'n_accounts': {'it': '{n} account', 'en': '{n} accounts', 'fr': '{n} comptes', 'es': '{n} cuentas'},
  'switch_account': {'it': 'Cambia account', 'en': 'Switch account', 'fr': 'Changer de compte', 'es': 'Cambiar cuenta'},
  'active': {'it': 'Attivo', 'en': 'Active', 'fr': 'Actif', 'es': 'Activo'},
  'inactive': {'it': 'Inattivo', 'en': 'Inactive', 'fr': 'Inactif', 'es': 'Inactivo'},
  'preset': {'it': 'Preset', 'en': 'Preset', 'fr': 'Préréglage', 'es': 'Ajuste'},
  'choose_preset': {'it': 'Scegli preset', 'en': 'Choose preset', 'fr': 'Choisir un préréglage', 'es': 'Elegir ajuste'},
  'color': {'it': 'Colore', 'en': 'Color', 'fr': 'Couleur', 'es': 'Color'},
  'font': {'it': 'Font', 'en': 'Font', 'fr': 'Police', 'es': 'Fuente'},
  'size': {'it': 'Dimensione', 'en': 'Size', 'fr': 'Taille', 'es': 'Tamaño'},
  'add_link': {'it': 'Aggiungi link', 'en': 'Add link', 'fr': 'Ajouter un lien', 'es': 'Añadir enlace'},
  'url': {'it': 'URL', 'en': 'URL', 'fr': 'URL', 'es': 'URL'},
  'link': {'it': 'Link', 'en': 'Link', 'fr': 'Lien', 'es': 'Enlace'},
  'text': {'it': 'Testo', 'en': 'Text', 'fr': 'Texte', 'es': 'Texto'},
  'bold': {'it': 'Grassetto', 'en': 'Bold', 'fr': 'Gras', 'es': 'Negrita'},
  'subtitle': {'it': 'Sottotitolo', 'en': 'Subtitle', 'fr': 'Sous-titre', 'es': 'Subtítulo'},
  'highlight': {'it': 'Evidenzia', 'en': 'Highlight', 'fr': 'Surligner', 'es': 'Resaltar'},
  'italic': {'it': 'Corsivo', 'en': 'Italic', 'fr': 'Italique', 'es': 'Cursiva'},
  'underline': {'it': 'Sottolineato', 'en': 'Underline', 'fr': 'Souligné', 'es': 'Subrayado'},
  'strikethrough': {'it': 'Barrato', 'en': 'Strikethrough', 'fr': 'Barré', 'es': 'Tachado'},
  'bullet_list': {'it': 'Elenco puntato', 'en': 'Bullet list', 'fr': 'Liste à puces', 'es': 'Lista con viñetas'},
  'numbered_list': {'it': 'Elenco numerato', 'en': 'Numbered list', 'fr': 'Liste numérotée', 'es': 'Lista numerada'},
  'text_color': {'it': 'Colore testo', 'en': 'Text color', 'fr': 'Couleur du texte', 'es': 'Color de texto'},
  'background_color': {'it': 'Colore sfondo', 'en': 'Background color', 'fr': 'Couleur d\'arrière-plan', 'es': 'Color de fondo'},
  'align_left': {'it': 'Allinea a sinistra', 'en': 'Align left', 'fr': 'Aligner à gauche', 'es': 'Alinear a la izquierda'},
  'align_center': {'it': 'Allinea al centro', 'en': 'Align center', 'fr': 'Centrer', 'es': 'Centrar'},
  'align_right': {'it': 'Allinea a destra', 'en': 'Align right', 'fr': 'Aligner à droite', 'es': 'Alinear a la derecha'},
  'clear_format': {'it': 'Cancella formattazione', 'en': 'Clear formatting', 'fr': 'Effacer la mise en forme', 'es': 'Borrar formato'},
  'indent': {'it': 'Rientro', 'en': 'Indent', 'fr': 'Retrait', 'es': 'Sangría'},
  'image': {'it': 'Immagine', 'en': 'Image', 'fr': 'Image', 'es': 'Imagen'},
  'insert_image': {'it': 'Inserisci immagine', 'en': 'Insert image', 'fr': 'Insérer une image', 'es': 'Insertar imagen'},

  // ── Event presets ──
  'meeting': {'it': 'Riunione', 'en': 'Meeting', 'fr': 'Réunion', 'es': 'Reunión'},
  'birthday': {'it': 'Compleanno', 'en': 'Birthday', 'fr': 'Anniversaire', 'es': 'Cumpleaños'},
  'appointment': {'it': 'Appuntamento', 'en': 'Appointment', 'fr': 'Rendez-vous', 'es': 'Cita'},
  'deadline': {'it': 'Scadenza', 'en': 'Deadline', 'fr': 'Échéance', 'es': 'Fecha límite'},
  'trip': {'it': 'Viaggio', 'en': 'Trip', 'fr': 'Voyage', 'es': 'Viaje'},
  'sport': {'it': 'Sport', 'en': 'Sport', 'fr': 'Sport', 'es': 'Deporte'},

  // ── Religions ──
  'catholic': {'it': 'Cattolica', 'en': 'Catholic', 'fr': 'Catholique', 'es': 'Católica'},
  'orthodox': {'it': 'Ortodossa', 'en': 'Orthodox', 'fr': 'Orthodoxe', 'es': 'Ortodoxa'},
  'protestant': {'it': 'Protestante', 'en': 'Protestant', 'fr': 'Protestante', 'es': 'Protestante'},
  'jewish': {'it': 'Ebraica', 'en': 'Jewish', 'fr': 'Juive', 'es': 'Judía'},
  'islamic': {'it': 'Islamica', 'en': 'Islamic', 'fr': 'Islamique', 'es': 'Islámica'},
  'buddhist': {'it': 'Buddista', 'en': 'Buddhist', 'fr': 'Bouddhiste', 'es': 'Budista'},
  'hindu': {'it': 'Induista', 'en': 'Hindu', 'fr': 'Hindoue', 'es': 'Hindú'},
  'none_religion': {'it': 'Nessuna', 'en': 'None', 'fr': 'Aucune', 'es': 'Ninguna'},

  // ── Account deletion dialog reasons ──
  'confirm_with_password': {'it': 'Conferma con password', 'en': 'Confirm with password', 'fr': 'Confirmer avec le mot de passe', 'es': 'Confirmar con contraseña'},
  'enter_password': {'it': 'Inserisci la tua password', 'en': 'Enter your password', 'fr': 'Entrez votre mot de passe', 'es': 'Introduce tu contraseña'},
  'account_deleted': {'it': 'Account eliminato', 'en': 'Account deleted', 'fr': 'Compte supprimé', 'es': 'Cuenta eliminada'},

  // ── Horoscope ──
  'daily_horoscope': {'it': 'Oroscopo del giorno', 'en': 'Daily horoscope', 'fr': 'Horoscope du jour', 'es': 'Horóscopo del día'},
  'horoscope_not_available': {'it': 'Oroscopo non disponibile', 'en': 'Horoscope not available', 'fr': 'Horoscope non disponible', 'es': 'Horóscopo no disponible'},
  'loading_horoscope': {'it': 'Caricamento oroscopo...', 'en': 'Loading horoscope...', 'fr': 'Chargement de l\'horoscope...', 'es': 'Cargando horóscopo...'},

  // ── Google integrations ──
  'google_calendar': {'it': 'Google Calendar', 'en': 'Google Calendar', 'fr': 'Google Calendar', 'es': 'Google Calendar'},
  'google_drive': {'it': 'Google Drive', 'en': 'Google Drive', 'fr': 'Google Drive', 'es': 'Google Drive'},

  // ── Misc UI ──
  'completed': {'it': 'Completato', 'en': 'Completed', 'fr': 'Terminé', 'es': 'Completado'},
  'not_completed': {'it': 'Non completato', 'en': 'Not completed', 'fr': 'Non terminé', 'es': 'No completado'},
  'mark_completed': {'it': 'Segna come completato', 'en': 'Mark as completed', 'fr': 'Marquer comme terminé', 'es': 'Marcar como completado'},
  'mark_not_completed': {'it': 'Segna come non completato', 'en': 'Mark as not completed', 'fr': 'Marquer comme non terminé', 'es': 'Marcar como no completado'},
  'add_note': {'it': 'Aggiungi nota', 'en': 'Add note', 'fr': 'Ajouter une note', 'es': 'Añadir nota'},
  'choose_calendar': {'it': 'Scegli calendario', 'en': 'Choose calendar', 'fr': 'Choisir le calendrier', 'es': 'Elegir calendario'},
  'choose_reminder': {'it': 'Scegli promemoria', 'en': 'Choose reminder', 'fr': 'Choisir le rappel', 'es': 'Elegir recordatorio'},
  'select_date': {'it': 'Seleziona data', 'en': 'Select date', 'fr': 'Sélectionner la date', 'es': 'Seleccionar fecha'},
  'select_time': {'it': 'Seleziona ora', 'en': 'Select time', 'fr': 'Sélectionner l\'heure', 'es': 'Seleccionar hora'},
  'no_title': {'it': 'Senza titolo', 'en': 'No title', 'fr': 'Sans titre', 'es': 'Sin título'},
  'add_attachment': {'it': 'Aggiungi allegato', 'en': 'Add attachment', 'fr': 'Ajouter une pièce jointe', 'es': 'Añadir adjunto'},
  'share_event': {'it': 'Condividi evento', 'en': 'Share event', 'fr': 'Partager l\'événement', 'es': 'Compartir evento'},
  'add_person': {'it': 'Aggiungi persona', 'en': 'Add person', 'fr': 'Ajouter une personne', 'es': 'Añadir persona'},
  'person_name': {'it': 'Nome persona', 'en': 'Person name', 'fr': 'Nom de la personne', 'es': 'Nombre de la persona'},
  'ask_gemini': {'it': 'Chiedi a Gemini', 'en': 'Ask Gemini', 'fr': 'Demander à Gemini', 'es': 'Preguntar a Gemini'},
  'ai_response': {'it': 'Risposta AI', 'en': 'AI Response', 'fr': 'Réponse IA', 'es': 'Respuesta IA'},
  'type_message': {'it': 'Scrivi un messaggio...', 'en': 'Type a message...', 'fr': 'Écrivez un message...', 'es': 'Escribe un mensaje...'},
  'empty_note': {'it': 'Nota vuota', 'en': 'Empty note', 'fr': 'Note vide', 'es': 'Nota vacía'},
  'set_pin': {'it': 'Imposta PIN', 'en': 'Set PIN', 'fr': 'Définir le PIN', 'es': 'Establecer PIN'},
  'change_pin': {'it': 'Cambia PIN', 'en': 'Change PIN', 'fr': 'Changer le PIN', 'es': 'Cambiar PIN'},
  'pin_set': {'it': 'PIN impostato', 'en': 'PIN set', 'fr': 'PIN défini', 'es': 'PIN establecido'},
  'download_font': {'it': 'Scarica Font', 'en': 'Download Font', 'fr': 'Télécharger la police', 'es': 'Descargar fuente'},
  'font_name': {'it': 'Nome del font', 'en': 'Font name', 'fr': 'Nom de la police', 'es': 'Nombre de la fuente'},
  'font_downloaded': {'it': 'Font scaricato', 'en': 'Font downloaded', 'fr': 'Police téléchargée', 'es': 'Fuente descargada'},
  'add_template': {'it': 'Aggiungi Template', 'en': 'Add Template', 'fr': 'Ajouter un modèle', 'es': 'Añadir plantilla'},
  'template_name': {'it': 'Nome template', 'en': 'Template name', 'fr': 'Nom du modèle', 'es': 'Nombre de la plantilla'},
  'delete_font': {'it': 'Elimina Font', 'en': 'Delete Font', 'fr': 'Supprimer la police', 'es': 'Eliminar fuente'},
  'n_days': {'it': '{n} giorni', 'en': '{n} days', 'fr': '{n} jours', 'es': '{n} días'},
  'select_religion': {'it': 'Seleziona religione', 'en': 'Select religion', 'fr': 'Sélectionner la religion', 'es': 'Seleccionar religión'},

  // --- Empty states ---
  'trash_empty': {'it': 'Cestino vuoto', 'en': 'Trash empty', 'fr': 'Corbeille vide', 'es': 'Papelera vacía'},
  'no_email': {'it': 'Nessuna email', 'en': 'No email', 'fr': 'Pas d\'email', 'es': 'Sin email'},
  'no_active_integrations': {'it': 'Nessuna integrazione attiva', 'en': 'No active integrations', 'fr': 'Aucune intégration active', 'es': 'Sin integraciones activas'},
  'no_extra_fonts': {'it': 'Nessun font aggiuntivo scaricato', 'en': 'No extra fonts downloaded', 'fr': 'Aucune police supplémentaire', 'es': 'Sin fuentes adicionales'},
  'no_custom_templates': {'it': 'Nessun template personalizzato', 'en': 'No custom templates', 'fr': 'Aucun modèle personnalisé', 'es': 'Sin plantillas personalizadas'},
  'no_results_for': {'it': 'Nessun risultato per', 'en': 'No results for', 'fr': 'Aucun résultat pour', 'es': 'Sin resultados para'},
  'no_deep_notes': {'it': 'Nessuna Deep Note', 'en': 'No Deep Notes', 'fr': 'Aucune Deep Note', 'es': 'Sin Deep Notes'},
  'write_first_quick_note': {'it': 'Scrivi la tua prima nota rapida!', 'en': 'Write your first quick note!', 'fr': 'Écrivez votre première note rapide !', 'es': '¡Escribe tu primera nota rápida!'},
  'create_first_note': {'it': 'Crea la tua prima nota!', 'en': 'Create your first note!', 'fr': 'Créez votre première note !', 'es': '¡Crea tu primera nota!'},

  // --- Status ---
  'not_set_m': {'it': 'Non impostato', 'en': 'Not set', 'fr': 'Non défini', 'es': 'No establecido'},
  'not_set_f': {'it': 'Non impostata', 'en': 'Not set', 'fr': 'Non définie', 'es': 'No establecida'},
  'wrong_password': {'it': 'Password errata', 'en': 'Wrong password', 'fr': 'Mot de passe incorrect', 'es': 'Contraseña incorrecta'},
  'connected_success': {'it': 'connesso!', 'en': 'connected!', 'fr': 'connecté !', 'es': '¡conectado!'},
  'auth_failed': {'it': 'Autorizzazione non riuscita', 'en': 'Authorization failed', 'fr': 'Échec de l\'autorisation', 'es': 'Error de autorización'},
  'disconnected': {'it': 'disconnesso', 'en': 'disconnected', 'fr': 'déconnecté', 'es': 'desconectado'},
  'health_connected': {'it': 'Salute connessa!', 'en': 'Health connected!', 'fr': 'Santé connectée !', 'es': '¡Salud conectada!'},
  'health_disconnected': {'it': 'Salute disconnessa', 'en': 'Health disconnected', 'fr': 'Santé déconnectée', 'es': 'Salud desconectada'},
  'available_ios_android': {'it': 'Disponibile su iOS e Android', 'en': 'Available on iOS and Android', 'fr': 'Disponible sur iOS et Android', 'es': 'Disponible en iOS y Android'},
  'not_available_web': {'it': 'Non disponibile sul web', 'en': 'Not available on web', 'fr': 'Non disponible sur le web', 'es': 'No disponible en la web'},
  'password_updated': {'it': 'Password aggiornata', 'en': 'Password updated', 'fr': 'Mot de passe mis à jour', 'es': 'Contraseña actualizada'},
  'profile_copied': {'it': 'Profilo copiato negli appunti (vCard)', 'en': 'Profile copied to clipboard (vCard)', 'fr': 'Profil copié dans le presse-papiers (vCard)', 'es': 'Perfil copiado al portapapeles (vCard)'},
  'welcome_pro': {'it': 'Benvenuto in Ethos Note PRO!', 'en': 'Welcome to Ethos Note PRO!', 'fr': 'Bienvenue dans Ethos Note PRO !', 'es': '¡Bienvenido a Ethos Note PRO!'},

  // --- Time formatting ---
  'days_ago': {'it': 'giorni fa', 'en': 'days ago', 'fr': 'jours', 'es': 'días atrás'},
  'min_before': {'it': 'min prima', 'en': 'min before', 'fr': 'min avant', 'es': 'min antes'},
  'hours_before': {'it': 'ore prima', 'en': 'hours before', 'fr': 'heures avant', 'es': 'horas antes'},
  'hours_min_before': {'it': 'ore {m} min prima', 'en': 'hours {m} min before', 'fr': 'heures {m} min avant', 'es': 'horas {m} min antes'},
  'day_before': {'it': '1 giorno prima', 'en': '1 day before', 'fr': '1 jour avant', 'es': '1 día antes'},
  'days_before': {'it': 'giorni prima', 'en': 'days before', 'fr': 'jours avant', 'es': 'días antes'},
  'n_events': {'it': '{n} evento', 'en': '{n} event', 'fr': '{n} événement', 'es': '{n} evento'},
  'n_events_plural': {'it': '{n} eventi', 'en': '{n} events', 'fr': '{n} événements', 'es': '{n} eventos'},

  // --- Calendar settings constants ---
  '10_min_before': {'it': '10 minuti prima', 'en': '10 min before', 'fr': '10 min avant', 'es': '10 min antes'},
  'vibration_only': {'it': 'Solo Vibrazione', 'en': 'Vibration only', 'fr': 'Vibration uniquement', 'es': 'Solo vibración'},
  'sound_only': {'it': 'Solo Suono', 'en': 'Sound only', 'fr': 'Son uniquement', 'es': 'Solo sonido'},
  'bell': {'it': 'Campanella', 'en': 'Bell', 'fr': 'Cloche', 'es': 'Campana'},
  'melody': {'it': 'Melodia', 'en': 'Melody', 'fr': 'Mélodie', 'es': 'Melodía'},
  '3_seconds': {'it': '3 secondi', 'en': '3 seconds', 'fr': '3 secondes', 'es': '3 segundos'},
  'italic_font': {'it': 'Corsivo', 'en': 'Italic', 'fr': 'Italique', 'es': 'Cursiva'},
  'font_preview': {'it': 'Anteprima: 1 2 3 4 5 Gennaio 2026', 'en': 'Preview: 1 2 3 4 5 January 2026', 'fr': 'Aperçu : 1 2 3 4 5 Janvier 2026', 'es': 'Vista previa: 1 2 3 4 5 Enero 2026'},

  // --- Event editor ---
  '1_week_before': {'it': '1 settimana prima', 'en': '1 week before', 'fr': '1 semaine avant', 'es': '1 semana antes'},
  'date_and_time': {'it': 'Data e Ora', 'en': 'Date and Time', 'fr': 'Date et heure', 'es': 'Fecha y hora'},
  'alert': {'it': 'Avviso', 'en': 'Alert', 'fr': 'Alerte', 'es': 'Alerta'},
  'custom_duration': {'it': 'Durata Personalizzata', 'en': 'Custom Duration', 'fr': 'Durée personnalisée', 'es': 'Duración personalizada'},
  'insert_seconds': {'it': 'Inserisci i secondi', 'en': 'Enter seconds', 'fr': 'Entrez les secondes', 'es': 'Introduce los segundos'},
  'custom_alert_time': {'it': 'Tempo di Avviso Personalizzato', 'en': 'Custom Alert Time', 'fr': 'Temps d\'alerte personnalisé', 'es': 'Tiempo de alerta personalizado'},
  'insert_minutes': {'it': 'Inserisci i minuti', 'en': 'Enter minutes', 'fr': 'Entrez les minutes', 'es': 'Introduce los minutos'},
  'custom': {'it': 'Personalizzato', 'en': 'Custom', 'fr': 'Personnalisé', 'es': 'Personalizado'},
  'select_multiple_alerts': {'it': 'Puoi selezionare più avvisi contemporaneamente', 'en': 'You can select multiple alerts', 'fr': 'Vous pouvez sélectionner plusieurs alertes', 'es': 'Puedes seleccionar varias alertas'},

  // --- Settings descriptions ---
  'google_cal_desc': {'it': 'Collega Google Calendar per sincronizzare i tuoi eventi in modo bidirezionale.', 'en': 'Connect Google Calendar to sync your events bidirectionally.', 'fr': 'Connectez Google Calendar pour synchroniser vos événements.', 'es': 'Conecta Google Calendar para sincronizar tus eventos.'},
  'next_month_lighter': {'it': 'I giorni del mese successivo appaiono più chiari', 'en': 'Next month days appear lighter', 'fr': 'Les jours du mois suivant apparaissent plus clairs', 'es': 'Los días del mes siguiente aparecen más claros'},
  'city_hint': {'it': 'es: Roma, Milano, Napoli', 'en': 'e.g. London, Paris, NYC', 'fr': 'ex : Paris, Lyon, Marseille', 'es': 'ej: Madrid, Barcelona, Sevilla'},
  'other_none': {'it': 'Altra/Nessuna', 'en': 'Other/None', 'fr': 'Autre/Aucune', 'es': 'Otra/Ninguna'},
  'cycle_privacy': {'it': 'I dati del ciclo sono privati e non vengono mai condivisi.', 'en': 'Cycle data is private and never shared.', 'fr': 'Les données du cycle sont privées et jamais partagées.', 'es': 'Los datos del ciclo son privados y nunca se comparten.'},
  'health_connected_desc': {'it': 'Passi, battito cardiaco, sonno e SpO2 visibili nel calendario', 'en': 'Steps, heart rate, sleep, and SpO2 visible in calendar', 'fr': 'Pas, fréquence cardiaque, sommeil et SpO2 visibles dans le calendrier', 'es': 'Pasos, frecuencia cardíaca, sueño y SpO2 visibles en el calendario'},
  'health_connect_desc': {'it': 'Collega per vedere i dati salute nel calendario', 'en': 'Connect to see health data in calendar', 'fr': 'Connectez pour voir les données santé dans le calendrier', 'es': 'Conecta para ver los datos de salud en el calendario'},
  'health_web_warning': {'it': 'L\'integrazione salute funziona su iOS (Apple Health) e Android (Health Connect). Sul web non è disponibile.', 'en': 'Health integration works on iOS (Apple Health) and Android (Health Connect). Not available on web.', 'fr': 'L\'intégration santé fonctionne sur iOS (Apple Health) et Android (Health Connect). Non disponible sur le web.', 'es': 'La integración de salud funciona en iOS (Apple Health) y Android (Health Connect). No disponible en la web.'},
  'health_privacy': {'it': 'I dati vengono letti dal dispositivo e non vengono mai inviati a server esterni.', 'en': 'Data is read from the device and never sent to external servers.', 'fr': 'Les données sont lues depuis l\'appareil et jamais envoyées à des serveurs externes.', 'es': 'Los datos se leen del dispositivo y nunca se envían a servidores externos.'},
  'api_key_privacy': {'it': 'La chiave API viene salvata localmente sul dispositivo', 'en': 'API key is saved locally on the device', 'fr': 'La clé API est sauvegardée localement sur l\'appareil', 'es': 'La clave API se guarda localmente en el dispositivo'},
  'ai_formatting_desc': {'it': 'Titolo, paragrafi, elenchi e controllo ortografico automatico', 'en': 'Title, paragraphs, lists and automatic spellcheck', 'fr': 'Titre, paragraphes, listes et correction orthographique automatique', 'es': 'Título, párrafos, listas y corrección ortográfica automática'},
  'requires_gemini': {'it': 'Richiede Gemini AI attivo', 'en': 'Requires Gemini AI active', 'fr': 'Nécessite Gemini AI actif', 'es': 'Requiere Gemini AI activo'},
  'custom_ai_instructions': {'it': 'Dai istruzioni personalizzate all\'AI', 'en': 'Give custom instructions to AI', 'fr': 'Donnez des instructions personnalisées à l\'IA', 'es': 'Da instrucciones personalizadas a la IA'},
  'keep_notes_for': {'it': 'Conserva note per', 'en': 'Keep notes for', 'fr': 'Conserver les notes pendant', 'es': 'Conservar notas durante'},
  'trash_auto_delete': {'it': 'Le note nel cestino verranno eliminate automaticamente dopo {n} giorni', 'en': 'Notes in trash will be automatically deleted after {n} days', 'fr': 'Les notes dans la corbeille seront supprimées automatiquement après {n} jours', 'es': 'Las notas en la papelera se eliminarán automáticamente después de {n} días'},
  'deletion_in_days': {'it': 'Eliminazione tra {n} giorni', 'en': 'Deletion in {n} days', 'fr': 'Suppression dans {n} jours', 'es': 'Eliminación en {n} días'},
  'expiring_today': {'it': 'In scadenza oggi', 'en': 'Expiring today', 'fr': 'Expire aujourd\'hui', 'es': 'Expira hoy'},
  'n_days_label': {'it': '{n} giorni', 'en': '{n} days', 'fr': '{n} jours', 'es': '{n} días'},

  // --- AI labels ---
  'summary_label': {'it': 'Riassunto', 'en': 'Summary', 'fr': 'Résumé', 'es': 'Resumen'},
  'rewrite_label': {'it': 'Riscrittura', 'en': 'Rewrite', 'fr': 'Réécriture', 'es': 'Reescritura'},
  'spelling_only': {'it': 'Solo ortografia', 'en': 'Spelling only', 'fr': 'Orthographe uniquement', 'es': 'Solo ortografía'},
  'spelling_punctuation': {'it': 'Ortografia e punteggiatura', 'en': 'Spelling and punctuation', 'fr': 'Orthographe et ponctuation', 'es': 'Ortografía y puntuación'},
  'light_summary': {'it': 'Riassunto leggero', 'en': 'Light summary', 'fr': 'Résumé léger', 'es': 'Resumen ligero'},
  'reformulation': {'it': 'Riformulazione', 'en': 'Reformulation', 'fr': 'Reformulation', 'es': 'Reformulación'},
  'full_rewrite': {'it': 'Riscrittura completa', 'en': 'Full rewrite', 'fr': 'Réécriture complète', 'es': 'Reescritura completa'},
  'ai_summary': {'it': 'Riassunto AI', 'en': 'AI Summary', 'fr': 'Résumé IA', 'es': 'Resumen IA'},
  'ai_transcription': {'it': 'Trascrizione AI', 'en': 'AI Transcription', 'fr': 'Transcription IA', 'es': 'Transcripción IA'},
  'ai_correction': {'it': 'Correzione AI', 'en': 'AI Correction', 'fr': 'Correction IA', 'es': 'Corrección IA'},
  'ai_key_points': {'it': 'Punti Chiave AI', 'en': 'AI Key Points', 'fr': 'Points clés IA', 'es': 'Puntos clave IA'},
  'summarize': {'it': 'Riassumi', 'en': 'Summarize', 'fr': 'Résumer', 'es': 'Resumir'},
  'key_points': {'it': 'Punti Chiave', 'en': 'Key Points', 'fr': 'Points clés', 'es': 'Puntos clave'},

  // --- Flash/Deep Note UI ---
  'unsaved_changes': {'it': 'Modifiche non salvate', 'en': 'Unsaved changes', 'fr': 'Modifications non enregistrées', 'es': 'Cambios sin guardar'},
  'save_changes_question': {'it': 'Vuoi salvare le modifiche?', 'en': 'Do you want to save the changes?', 'fr': 'Voulez-vous enregistrer les modifications ?', 'es': '¿Deseas guardar los cambios?'},
  'discard': {'it': 'Scarta', 'en': 'Discard', 'fr': 'Annuler', 'es': 'Descartar'},
  'transcribe_voice_note': {'it': 'Trascrivi nota vocale', 'en': 'Transcribe voice note', 'fr': 'Transcrire la note vocale', 'es': 'Transcribir nota de voz'},
  'convert_audio_to_text': {'it': 'Converti l\'audio in testo', 'en': 'Convert audio to text', 'fr': 'Convertir l\'audio en texte', 'es': 'Convertir audio a texto'},
  'smart_summary': {'it': 'Riassunto intelligente', 'en': 'Smart summary', 'fr': 'Résumé intelligent', 'es': 'Resumen inteligente'},
  'create_brief_summary': {'it': 'Crea un riassunto breve del testo', 'en': 'Create a brief summary of the text', 'fr': 'Créer un bref résumé du texte', 'es': 'Crear un resumen breve del texto'},
  'create_brief_content_summary': {'it': 'Crea un riassunto breve del contenuto', 'en': 'Create a brief summary of the content', 'fr': 'Créer un bref résumé du contenu', 'es': 'Crear un resumen breve del contenido'},
  'no_text_recognized': {'it': 'Nessun testo riconosciuto', 'en': 'No text recognized', 'fr': 'Aucun texte reconnu', 'es': 'Ningún texto reconocido'},
  'open_as_text_note': {'it': 'Apri come nota di testo', 'en': 'Open as text note', 'fr': 'Ouvrir comme note de texte', 'es': 'Abrir como nota de texto'},
  'notification_denied': {'it': 'Permesso notifiche negato. Vai in Impostazioni → App → Ethos Note → Notifiche e attivale.', 'en': 'Notification permission denied. Go to Settings → App → Ethos Note → Notifications and enable them.', 'fr': 'Autorisation refusée. Allez dans Paramètres → App → Ethos Note → Notifications et activez-les.', 'es': 'Permiso de notificaciones denegado. Ve a Ajustes → App → Ethos Note → Notificaciones y actívalas.'},
  'notification_sent': {'it': 'Notifica inviata! Controlla la barra notifiche.', 'en': 'Notification sent! Check the notification bar.', 'fr': 'Notification envoyée ! Vérifiez la barre de notifications.', 'es': '¡Notificación enviada! Revisa la barra de notificaciones.'},
  'notification_error': {'it': 'Errore nell\'invio. Controlla le impostazioni del telefono.', 'en': 'Send error. Check phone settings.', 'fr': 'Erreur d\'envoi. Vérifiez les paramètres du téléphone.', 'es': 'Error de envío. Revisa los ajustes del teléfono.'},
  'test_notifications': {'it': 'Testa notifiche', 'en': 'Test notifications', 'fr': 'Tester les notifications', 'es': 'Probar notificaciones'},
  'show_holidays_subtitle': {'it': 'Mostra festività religiose nel calendario', 'en': 'Show religious holidays in the calendar', 'fr': 'Afficher les fêtes religieuses dans le calendrier', 'es': 'Mostrar festividades religiosas en el calendario'},
  'city_not_found': {'it': 'non trovata', 'en': 'not found', 'fr': 'introuvable', 'es': 'no encontrada'},
  'stop': {'it': 'Ferma', 'en': 'Stop', 'fr': 'Arrêter', 'es': 'Detener'},
  'photo': {'it': 'Foto', 'en': 'Photo', 'fr': 'Photo', 'es': 'Foto'},
  'add_caption': {'it': 'Aggiungi didascalia...', 'en': 'Add caption...', 'fr': 'Ajouter une légende...', 'es': 'Añadir descripción...'},
  'gallery': {'it': 'Galleria', 'en': 'Gallery', 'fr': 'Galerie', 'es': 'Galería'},
  'camera': {'it': 'Fotocamera', 'en': 'Camera', 'fr': 'Appareil photo', 'es': 'Cámara'},
  'open_pdf': {'it': 'Apri PDF', 'en': 'Open PDF', 'fr': 'Ouvrir PDF', 'es': 'Abrir PDF'},
  'from_file': {'it': 'Da File', 'en': 'From File', 'fr': 'Depuis un fichier', 'es': 'Desde archivo'},
  'from_google_drive': {'it': 'Da Google Drive', 'en': 'From Google Drive', 'fr': 'Depuis Google Drive', 'es': 'Desde Google Drive'},
  'no_pdf_found': {'it': 'Nessun PDF trovato', 'en': 'No PDF found', 'fr': 'Aucun PDF trouvé', 'es': 'Ningún PDF encontrado'},
  'loading_pdf': {'it': 'Caricamento PDF...', 'en': 'Loading PDF...', 'fr': 'Chargement du PDF...', 'es': 'Cargando PDF...'},
  'write_action': {'it': 'Scrivi', 'en': 'Write', 'fr': 'Écrire', 'es': 'Escribir'},
  'audio': {'it': 'Audio', 'en': 'Audio', 'fr': 'Audio', 'es': 'Audio'},
  'by_day': {'it': 'Per giorno', 'en': 'By day', 'fr': 'Par jour', 'es': 'Por día'},
  'by_week': {'it': 'Per settimana', 'en': 'By week', 'fr': 'Par semaine', 'es': 'Por semana'},
  'by_month': {'it': 'Per mese', 'en': 'By month', 'fr': 'Par mois', 'es': 'Por mes'},
  'by_year': {'it': 'Per anno', 'en': 'By year', 'fr': 'Par année', 'es': 'Por año'},
  'all_items': {'it': 'Tutte', 'en': 'All', 'fr': 'Toutes', 'es': 'Todas'},
  'preview': {'it': 'Anteprima', 'en': 'Preview', 'fr': 'Aperçu', 'es': 'Vista previa'},
  'tap_to_stop': {'it': 'Tocca per fermare', 'en': 'Tap to stop', 'fr': 'Appuyez pour arrêter', 'es': 'Toca para detener'},
  'tap_to_record': {'it': 'Tocca per registrare', 'en': 'Tap to record', 'fr': 'Appuyez pour enregistrer', 'es': 'Toca para grabar'},
  'max_2_minutes': {'it': 'Max 2 minuti', 'en': 'Max 2 minutes', 'fr': 'Max 2 minutes', 'es': 'Máx. 2 minutos'},
  'note_label': {'it': 'Nota', 'en': 'Note', 'fr': 'Note', 'es': 'Nota'},
  'created_on': {'it': 'Creata il', 'en': 'Created on', 'fr': 'Créée le', 'es': 'Creada el'},
  'at_time': {'it': 'alle', 'en': 'at', 'fr': 'à', 'es': 'a las'},
  'write_note_here': {'it': 'Scrivi qui la tua nota...', 'en': 'Write your note here...', 'fr': 'Écrivez votre note ici...', 'es': 'Escribe tu nota aquí...'},
  'quick_colors': {'it': 'Rapidi', 'en': 'Quick', 'fr': 'Rapides', 'es': 'Rápidos'},
  'write_quick_idea': {'it': 'Scrivi la tua idea veloce...', 'en': 'Write your quick idea...', 'fr': 'Écrivez votre idée rapide...', 'es': 'Escribe tu idea rápida...'},

  // --- Health card ---
  'sleep': {'it': 'Sonno', 'en': 'Sleep', 'fr': 'Sommeil', 'es': 'Sueño'},
  'steps': {'it': 'Passi', 'en': 'Steps', 'fr': 'Pas', 'es': 'Pasos'},
  'calories': {'it': 'Calorie', 'en': 'Calories', 'fr': 'Calories', 'es': 'Calorías'},
  'water': {'it': 'Acqua', 'en': 'Water', 'fr': 'Eau', 'es': 'Agua'},
  'health_ios_android': {'it': 'Disponibile su iOS (Apple Health) e Android (Health Connect)', 'en': 'Available on iOS (Apple Health) and Android (Health Connect)', 'fr': 'Disponible sur iOS (Apple Health) et Android (Health Connect)', 'es': 'Disponible en iOS (Apple Health) y Android (Health Connect)'},
  'tap_connect_apple': {'it': 'Tocca per collegare Apple Health', 'en': 'Tap to connect Apple Health', 'fr': 'Appuyez pour connecter Apple Health', 'es': 'Toca para conectar Apple Health'},
  'tap_connect_health': {'it': 'Tocca per collegare Health Connect', 'en': 'Tap to connect Health Connect', 'fr': 'Appuyez pour connecter Health Connect', 'es': 'Toca para conectar Health Connect'},
  'weight': {'it': 'Peso', 'en': 'Weight', 'fr': 'Poids', 'es': 'Peso'},

  // --- Integrations ---
  'integrations': {'it': 'Integrazioni', 'en': 'Integrations', 'fr': 'Intégrations', 'es': 'Integraciones'},

  // --- PRO dialog ---
  'per_month': {'it': '/mese', 'en': '/month', 'fr': '/mois', 'es': '/mes'},
  'pro_benefits': {'it': 'Vantaggi PRO:', 'en': 'PRO Benefits:', 'fr': 'Avantages PRO :', 'es': 'Beneficios PRO:'},
  'business_profile': {'it': 'Profilo Business', 'en': 'Business Profile', 'fr': 'Profil Business', 'es': 'Perfil Business'},
  'group_sharing': {'it': 'Condivisione con gruppi di lavoro', 'en': 'Sharing with work groups', 'fr': 'Partage avec les groupes de travail', 'es': 'Compartir con grupos de trabajo'},
  'calendar_notes_sharing': {'it': 'Condivisione calendario e note', 'en': 'Calendar and notes sharing', 'fr': 'Partage du calendrier et des notes', 'es': 'Compartir calendario y notas'},
  'advanced_editor': {'it': 'Editor avanzato stile Word', 'en': 'Advanced Word-style editor', 'fr': 'Éditeur avancé style Word', 'es': 'Editor avanzado estilo Word'},
  'full_text_formatting': {'it': 'Formattazione testo completa', 'en': 'Full text formatting', 'fr': 'Formatage complet du texte', 'es': 'Formato de texto completo'},
  'tables_media': {'it': 'Tabelle e inserimento media', 'en': 'Tables and media insertion', 'fr': 'Tableaux et insertion de médias', 'es': 'Tablas e inserción de medios'},
  'unlimited_backup': {'it': 'Backup cloud illimitato', 'en': 'Unlimited cloud backup', 'fr': 'Sauvegarde cloud illimitée', 'es': 'Backup en la nube ilimitado'},
  'multi_device_sync': {'it': 'Sincronizzazione multi-dispositivo', 'en': 'Multi-device sync', 'fr': 'Synchronisation multi-appareils', 'es': 'Sincronización multi-dispositivo'},

  // --- Religion display ---

  // --- SnackBar messages ---
  'error_loading_photo': {'it': 'Errore nel caricamento foto', 'en': 'Error loading photo', 'fr': 'Erreur de chargement de la photo', 'es': 'Error al cargar la foto'},
  'health_available_mobile': {'it': 'Integrazione salute disponibile su iOS e Android', 'en': 'Health integration available on iOS and Android', 'fr': 'Intégration santé disponible sur iOS et Android', 'es': 'Integración de salud disponible en iOS y Android'},
  'template_coming': {'it': 'Creazione template in arrivo!', 'en': 'Template creation coming soon!', 'fr': 'Création de modèles bientôt disponible !', 'es': '¡Creación de plantillas próximamente!'},
  'note_replaced': {'it': 'Nota sostituita', 'en': 'Note replaced', 'fr': 'Note remplacée', 'es': 'Nota reemplazada'},
  'ai_error': {'it': 'Errore AI', 'en': 'AI Error', 'fr': 'Erreur IA', 'es': 'Error IA'},
  'photo_coming': {'it': 'Funzione foto in arrivo!', 'en': 'Photo feature coming soon!', 'fr': 'Fonction photo bientôt disponible !', 'es': '¡Función de foto próximamente!'},
  'audio_not_available': {'it': 'Audio non disponibile', 'en': 'Audio not available', 'fr': 'Audio non disponible', 'es': 'Audio no disponible'},
  'mic_permission_denied': {'it': 'Permesso microfono non concesso', 'en': 'Microphone permission denied', 'fr': 'Permission du microphone refusée', 'es': 'Permiso de micrófono denegado'},
  'pins_no_match': {'it': 'I PIN non corrispondono o sono troppo corti', 'en': 'PINs don\'t match or are too short', 'fr': 'Les PIN ne correspondent pas ou sont trop courts', 'es': 'Los PIN no coinciden o son muy cortos'},
  'note_moved_private': {'it': 'Nota spostata in Privata', 'en': 'Note moved to Private', 'fr': 'Note déplacée dans Privé', 'es': 'Nota movida a Privada'},
  'configure_gemini': {'it': 'Configura nelle Integrazioni', 'en': 'Configure in Integrations', 'fr': 'Configurer dans les Intégrations', 'es': 'Configurar en Integraciones'},
  'event_save_error': {'it': 'Errore nel salvataggio dell\'evento', 'en': 'Error saving event', 'fr': 'Erreur lors de l\'enregistrement de l\'événement', 'es': 'Error al guardar el evento'},
  'event_added_on': {'it': 'aggiunto il', 'en': 'added on', 'fr': 'ajouté le', 'es': 'añadido el'},

  // --- Misc ---
  'created_by_ethos': {'it': 'Creato da Ethos Note', 'en': 'Created by Ethos Note', 'fr': 'Créé par Ethos Note', 'es': 'Creado por Ethos Note'},
  'private_folder': {'it': 'Privata', 'en': 'Private', 'fr': 'Privé', 'es': 'Privada'},
  'move_to_private': {'it': 'Sposta in Privata', 'en': 'Move to Private', 'fr': 'Déplacer dans Privé', 'es': 'Mover a Privada'},
  'shared_folder': {'it': 'Cartella condivisa', 'en': 'Shared folder', 'fr': 'Dossier partagé', 'es': 'Carpeta compartida'},
  'add_people': {'it': 'Aggiungi persone che possono vedere e modificare', 'en': 'Add people who can view and edit', 'fr': 'Ajouter des personnes qui peuvent voir et modifier', 'es': 'Añadir personas que pueden ver y editar'},
  'collaborator_email': {'it': 'Email collaboratore', 'en': 'Collaborator email', 'fr': 'Email du collaborateur', 'es': 'Email del colaborador'},
  'enter_title': {'it': 'Inserisci il titolo...', 'en': 'Enter title...', 'fr': 'Entrez le titre...', 'es': 'Introduce el título...'},
  'header_hint': {'it': 'Nome, indirizzo, contatti...', 'en': 'Name, address, contacts...', 'fr': 'Nom, adresse, contacts...', 'es': 'Nombre, dirección, contactos...'},
  'footer_hint': {'it': 'P.IVA, CF, PEC...', 'en': 'VAT, Tax ID, PEC...', 'fr': 'TVA, SIRET, email certifié...', 'es': 'CIF, NIF, email certificado...'},
  'color_hex_hint': {'it': 'es. FF5722', 'en': 'e.g. FF5722', 'fr': 'ex. FF5722', 'es': 'ej. FF5722'},
  'link_text': {'it': 'Testo del link', 'en': 'Link text', 'fr': 'Texte du lien', 'es': 'Texto del enlace'},
  'link_text_hint': {'it': 'Es: Clicca qui', 'en': 'E.g.: Click here', 'fr': 'Ex : Cliquez ici', 'es': 'Ej: Haz clic aquí'},
  'insert_link': {'it': 'Inserisci Link', 'en': 'Insert Link', 'fr': 'Insérer un lien', 'es': 'Insertar enlace'},
  'apply_template_q': {'it': 'Applicare', 'en': 'Apply', 'fr': 'Appliquer', 'es': 'Aplicar'},
  'template_replace_warning': {'it': 'Il contenuto attuale verrà sostituito con il template selezionato.', 'en': 'Current content will be replaced with the selected template.', 'fr': 'Le contenu actuel sera remplacé par le modèle sélectionné.', 'es': 'El contenido actual será reemplazado por la plantilla seleccionada.'},
  'google_cal_connected': {'it': 'Google Calendar connesso!', 'en': 'Google Calendar connected!', 'fr': 'Google Calendar connecté !', 'es': '¡Google Calendar conectado!'},
  'access_cancelled': {'it': 'Accesso annullato o non riuscito', 'en': 'Access cancelled or failed', 'fr': 'Accès annulé ou échoué', 'es': 'Acceso cancelado o fallido'},
  'google_edit_hint': {'it': 'Modifica gli eventi Google direttamente su Google Calendar', 'en': 'Edit Google events directly on Google Calendar', 'fr': 'Modifiez les événements Google directement sur Google Calendar', 'es': 'Edita los eventos de Google directamente en Google Calendar'},
  'synced_google': {'it': 'sincronizzato con Google Calendar', 'en': 'synced with Google Calendar', 'fr': 'synchronisé avec Google Calendar', 'es': 'sincronizado con Google Calendar'},

  // --- Deletion reasons ---
  'privacy_issues': {'it': 'Problemi di privacy', 'en': 'Privacy issues', 'fr': 'Problèmes de confidentialité', 'es': 'Problemas de privacidad'},
  'optional_comment': {'it': 'Commento opzionale...', 'en': 'Optional comment...', 'fr': 'Commentaire optionnel...', 'es': 'Comentario opcional...'},

  // --- Profile ---
  'register_email': {'it': 'Registrati con Email', 'en': 'Register with Email', 'fr': 'S\'inscrire par email', 'es': 'Registrarse con email'},
  'register': {'it': 'Registrati', 'en': 'Register', 'fr': 'S\'inscrire', 'es': 'Registrarse'},
  'email_hint': {'it': 'tuaemail@esempio.com', 'en': 'your@email.com', 'fr': 'votre@email.com', 'es': 'tu@email.com'},
  'nickname_hint': {'it': 'es. marco_r', 'en': 'e.g. john_d', 'fr': 'ex. jean_d', 'es': 'ej. juan_r'},
  'phone_number': {'it': 'Numero di telefono', 'en': 'Phone number', 'fr': 'Numéro de téléphone', 'es': 'Número de teléfono'},
  'current_password': {'it': 'Password attuale', 'en': 'Current password', 'fr': 'Mot de passe actuel', 'es': 'Contraseña actual'},
  'new_password': {'it': 'Nuova password', 'en': 'New password', 'fr': 'Nouveau mot de passe', 'es': 'Nueva contraseña'},
  'change_password': {'it': 'Cambia Password', 'en': 'Change Password', 'fr': 'Changer le mot de passe', 'es': 'Cambiar contraseña'},
  'url_or_username': {'it': 'URL o username', 'en': 'URL or username', 'fr': 'URL ou nom d\'utilisateur', 'es': 'URL o nombre de usuario'},
  'new_account': {'it': 'Nuovo Account', 'en': 'New Account', 'fr': 'Nouveau compte', 'es': 'Nueva cuenta'},
  'add_social': {'it': 'Aggiungi Link Social', 'en': 'Add Social Link', 'fr': 'Ajouter un lien social', 'es': 'Añadir enlace social'},
  'photo_profile': {'it': 'Foto Profilo', 'en': 'Profile Photo', 'fr': 'Photo de profil', 'es': 'Foto de perfil'},
  'secondary_accounts': {'it': 'Account secondari', 'en': 'Secondary accounts', 'fr': 'Comptes secondaires', 'es': 'Cuentas secundarias'},
  'phone_label': {'it': 'Telefono', 'en': 'Phone', 'fr': 'Téléphone', 'es': 'Teléfono'},
  // Task 2: folder/group deletion
  'delete_folder_confirm': {'it': 'Eliminare la cartella', 'en': 'Delete folder', 'fr': 'Supprimer le dossier', 'es': 'Eliminar carpeta'},
  'notes_moved_to_general': {'it': '{n} note verranno spostate in "Generale"', 'en': '{n} notes will be moved to "Generale"', 'fr': '{n} notes seront déplacées dans "Generale"', 'es': '{n} notas se moverán a "Generale"'},
  'delete_group_confirm': {'it': 'Eliminare tutte le note del gruppo', 'en': 'Delete all notes in group', 'fr': 'Supprimer toutes les notes du groupe', 'es': 'Eliminar todas las notas del grupo'},
  // Task 3: multi-select
  'selected': {'it': 'selezionate', 'en': 'selected', 'fr': 'sélectionnées', 'es': 'seleccionadas'},
  'select_all': {'it': 'Seleziona tutto', 'en': 'Select all', 'fr': 'Tout sélectionner', 'es': 'Seleccionar todo'},
  'deselect_all': {'it': 'Deseleziona tutto', 'en': 'Deselect all', 'fr': 'Tout désélectionner', 'es': 'Deseleccionar todo'},
  'delete_selected_confirm': {'it': 'Eliminare le note selezionate', 'en': 'Delete selected notes', 'fr': 'Supprimer les notes sélectionnées', 'es': 'Eliminar notas seleccionadas'},
  // Task 4: notifications
  'event_in': {'it': 'Evento tra', 'en': 'Event in', 'fr': 'Événement dans', 'es': 'Evento en'},
  'minutes': {'it': 'minuti', 'en': 'minutes', 'fr': 'minutes', 'es': 'minutos'},
  // Task 7: audio note viewer
  'transcription': {'it': 'Trascrizione', 'en': 'Transcription', 'fr': 'Transcription', 'es': 'Transcripción'},
  'transcribe': {'it': 'Trascrivi', 'en': 'Transcribe', 'fr': 'Transcrire', 'es': 'Transcribir'},
  'configure_gemini_first': {'it': 'Configura prima l\'API Gemini nelle impostazioni', 'en': 'Configure Gemini API in settings first', 'fr': 'Configurez d\'abord l\'API Gemini dans les paramètres', 'es': 'Configura primero la API de Gemini en los ajustes'},
  // Task 10: event preview
  'complete': {'it': 'Completa', 'en': 'Complete', 'fr': 'Terminer', 'es': 'Completar'},
  'shared': {'it': 'condiviso', 'en': 'shared', 'fr': 'partagé', 'es': 'compartido'},
  // Round 2 translations
  'chinese': {'it': 'Cinese', 'en': 'Chinese', 'fr': 'Chinoise', 'es': 'China'},
  'chinese_zodiac': {'it': 'Zodiaco Cinese', 'en': 'Chinese Zodiac', 'fr': 'Zodiaque Chinois', 'es': 'Zodíaco Chino'},
  'show_chinese_zodiac': {'it': 'Mostra zodiaco cinese', 'en': 'Show Chinese zodiac', 'fr': 'Afficher le zodiaque chinois', 'es': 'Mostrar zodíaco chino'},
  'ethos_aura': {'it': 'Ethos Aura', 'en': 'Ethos Aura', 'fr': 'Ethos Aura', 'es': 'Ethos Aura'},
  'ethos_aura_desc': {'it': 'Funzionalità premium per la tua esperienza', 'en': 'Premium features for your experience', 'fr': 'Fonctionnalités premium pour votre expérience', 'es': 'Funciones premium para tu experiencia'},
  'unlock': {'it': 'Sblocca', 'en': 'Unlock', 'fr': 'Débloquer', 'es': 'Desbloquear'},
  'purchased': {'it': 'Acquistato', 'en': 'Purchased', 'fr': 'Acheté', 'es': 'Comprado'},
  'unlock_horoscope': {'it': 'Sblocca Oroscopo', 'en': 'Unlock Horoscope', 'fr': 'Débloquer Horoscope', 'es': 'Desbloquear Horóscopo'},
  'unlock_unlimited_voice': {'it': 'Sblocca note vocali illimitate', 'en': 'Unlock unlimited voice notes', 'fr': 'Débloquer notes vocales illimitées', 'es': 'Desbloquear notas de voz ilimitadas'},
  'unlock_photo_recognition': {'it': 'Riconoscimento Foto AI', 'en': 'AI Photo Recognition', 'fr': 'Reconnaissance photo IA', 'es': 'Reconocimiento de fotos IA'},
  'unlock_paper_sticky': {'it': 'Stile Paper & Sticky', 'en': 'Paper & Sticky Style', 'fr': 'Style Paper & Sticky', 'es': 'Estilo Paper & Sticky'},
  'unlock_cycle_tracking': {'it': 'Tracciamento Ciclo', 'en': 'Cycle Tracking', 'fr': 'Suivi du cycle', 'es': 'Seguimiento del ciclo'},
  'ephemera_theme': {'it': 'Ephemera', 'en': 'Ephemera', 'fr': 'Ephemera', 'es': 'Ephemera'},
  'unlock_ephemera_theme': {'it': 'Tema Ephemera', 'en': 'Ephemera Theme', 'fr': 'Thème Ephemera', 'es': 'Tema Ephemera'},
  'ephemera_theme_desc': {'it': 'L\'anima del diario: palette crema e seppia', 'en': 'The soul of a diary: cream and sepia palette', 'fr': 'L\'âme du journal: palette crème et sépia', 'es': 'El alma del diario: paleta crema y sepia'},
  'theme_locked': {'it': 'Tema bloccato', 'en': 'Theme locked', 'fr': 'Thème verrouillé', 'es': 'Tema bloqueado'},
  'theme_catalog': {'it': 'Catalogo Temi', 'en': 'Theme Catalog', 'fr': 'Catalogue de thèmes', 'es': 'Catálogo de temas'},
  'theme_catalog_desc': {'it': 'Temi premium per personalizzare l\'app', 'en': 'Premium themes to customize the app', 'fr': 'Thèmes premium pour personnaliser l\'app', 'es': 'Temas premium para personalizar la app'},
  'no_themes_purchased': {'it': 'Nessun tema acquistato', 'en': 'No themes purchased', 'fr': 'Aucun thème acheté', 'es': 'Ningún tema comprado'},
  'browse_themes': {'it': 'Sfoglia i temi disponibili su Ethos Aura', 'en': 'Browse available themes on Ethos Aura', 'fr': 'Parcourir les thèmes disponibles sur Ethos Aura', 'es': 'Explorar temas disponibles en Ethos Aura'},
  'active_theme': {'it': 'Attivo', 'en': 'Active', 'fr': 'Actif', 'es': 'Activo'},
  'nordic_zen_theme': {'it': 'Nordic Zen', 'en': 'Nordic Zen', 'fr': 'Nordic Zen', 'es': 'Nordic Zen'},
  'unlock_nordic_zen': {'it': 'Tema Nordic Zen', 'en': 'Nordic Zen Theme', 'fr': 'Thème Nordic Zen', 'es': 'Tema Nordic Zen'},
  'nordic_zen_desc': {'it': 'Minimalismo scandinavo con trasparenze ghiaccio', 'en': 'Scandinavian minimalism with icy transparency', 'fr': 'Minimalisme scandinave avec transparence glacée', 'es': 'Minimalismo escandinavo con transparencia helada'},
  'green_salvia_theme': {'it': 'Green Salvia', 'en': 'Green Salvia', 'fr': 'Green Salvia', 'es': 'Green Salvia'},
  'unlock_green_salvia': {'it': 'Tema Green Salvia', 'en': 'Green Salvia Theme', 'fr': 'Thème Green Salvia', 'es': 'Tema Green Salvia'},
  'green_salvia_desc': {'it': 'Equilibrio botanico: palette verde salvia rilassante', 'en': 'Botanical balance: relaxing sage green palette', 'fr': 'Équilibre botanique: palette vert sauge relaxante', 'es': 'Equilibrio botánico: paleta verde salvia relajante'},
  'sakura_theme': {'it': 'Sakura', 'en': 'Sakura', 'fr': 'Sakura', 'es': 'Sakura'},
  'unlock_sakura': {'it': 'Tema Sakura', 'en': 'Sakura Theme', 'fr': 'Thème Sakura', 'es': 'Tema Sakura'},
  'sakura_desc': {'it': 'Eleganza sofisticata in rosa polveroso e malva', 'en': 'Sophisticated elegance in dusty rose and mauve', 'fr': 'Élégance sophistiquée en rose poudré et mauve', 'es': 'Elegancia sofisticada en rosa empolvado y malva'},
  // Collezione Oltre l'Oceano (One Piece)
  'spadaccino_theme': {'it': 'Spadaccino Errante', 'en': 'Wandering Swordsman', 'fr': 'Spadassin Errant', 'es': 'Espadachín Errante'},
  'spadaccino_desc': {'it': 'Dojo d\'acciaio: austero, tagliente, disciplinato', 'en': 'Steel dojo: austere, sharp, disciplined', 'fr': 'Dojo d\'acier: austère, tranchant, discipliné', 'es': 'Dojo de acero: austero, afilado, disciplinado'},
  'sogno_re_theme': {'it': 'Sogno del Re', 'en': 'King\'s Dream', 'fr': 'Rêve du Roi', 'es': 'Sueño del Rey'},
  'sogno_re_desc': {'it': 'Esplosivo, dinamico, pieno di energia solare', 'en': 'Explosive, dynamic, full of solar energy', 'fr': 'Explosif, dynamique, plein d\'énergie solaire', 'es': 'Explosivo, dinámico, lleno de energía solar'},
  'mappa_tesoro_theme': {'it': 'Mappa del Tesoro', 'en': 'Treasure Map', 'fr': 'Carte au Trésor', 'es': 'Mapa del Tesoro'},
  'mappa_tesoro_desc': {'it': 'Elegante, cartografico e prezioso', 'en': 'Elegant, cartographic and precious', 'fr': 'Élégant, cartographique et précieux', 'es': 'Elegante, cartográfico y precioso'},
  // Collezione Spirito della Foglia (Naruto)
  'fulmine_theme': {'it': 'Fulmine Vendicatore', 'en': 'Avenging Lightning', 'fr': 'Foudre Vengeresse', 'es': 'Rayo Vengador'},
  'fulmine_desc': {'it': 'Oscuro, freddo e tecnologico', 'en': 'Dark, cold and technological', 'fr': 'Sombre, froid et technologique', 'es': 'Oscuro, frío y tecnológico'},
  'eremita_theme': {'it': 'Eremita Volpe', 'en': 'Fox Hermit', 'fr': 'Ermite Renard', 'es': 'Ermitaño Zorro'},
  'eremita_desc': {'it': 'Il calore del fuoco e la determinazione', 'en': 'The warmth of fire and determination', 'fr': 'La chaleur du feu et la détermination', 'es': 'El calor del fuego y la determinación'},
  'saggio_theme': {'it': 'Saggio dei Rospi', 'en': 'Toad Sage', 'fr': 'Sage des Crapauds', 'es': 'Sabio de los Sapos'},
  'saggio_desc': {'it': 'Tradizionale, antico e leggendario', 'en': 'Traditional, ancient and legendary', 'fr': 'Traditionnel, ancien et légendaire', 'es': 'Tradicional, antiguo y legendario'},
  // Collezione Serie Cult
  'cabina_theme': {'it': 'Cabina del Tempo', 'en': 'Time Cabin', 'fr': 'Cabine du Temps', 'es': 'Cabina del Tiempo'},
  'cabina_desc': {'it': 'Un viaggio tra spazio e tempo anni \'60', 'en': 'A journey through 60s space and time', 'fr': 'Un voyage dans l\'espace-temps des années 60', 'es': 'Un viaje por el espacio-tiempo de los 60'},
  'sottosopra_theme': {'it': 'Sottosopra', 'en': 'Upside Down', 'fr': 'Monde Inversé', 'es': 'Mundo del Revés'},
  'sottosopra_desc': {'it': 'Misterioso, anni \'80 e inquietante', 'en': 'Mysterious, 80s and eerie', 'fr': 'Mystérieux, années 80 et inquiétant', 'es': 'Misterioso, años 80 e inquietante'},
  'rifugio_theme': {'it': 'Rifugio Atomico', 'en': 'Atomic Shelter', 'fr': 'Refuge Atomique', 'es': 'Refugio Atómico'},
  'rifugio_desc': {'it': 'Post-apocalittico e industriale', 'en': 'Post-apocalyptic and industrial', 'fr': 'Post-apocalyptique et industriel', 'es': 'Postapocalíptico e industrial'},
  'yellow_note_theme': {'it': 'Yellow Note', 'en': 'Yellow Note', 'fr': 'Yellow Note', 'es': 'Yellow Note'},
  'yellow_note_desc': {'it': 'Blocco note giallo, penna a sfera e nostalgia analogica', 'en': 'Yellow notepad, ballpoint pen and analog nostalgia', 'fr': 'Bloc-notes jaune, stylo bille et nostalgie analogique', 'es': 'Bloc de notas amarillo, bolígrafo y nostalgia analógica'},
  'collection_oceano': {'it': 'Oltre l\'Oceano', 'en': 'Beyond the Ocean', 'fr': 'Au-delà de l\'Océan', 'es': 'Más allá del Océano'},
  'collection_foglia': {'it': 'Spirito della Foglia', 'en': 'Spirit of the Leaf', 'fr': 'Esprit de la Feuille', 'es': 'Espíritu de la Hoja'},
  'collection_cult': {'it': 'Serie Cult', 'en': 'Cult Series', 'fr': 'Séries Cultes', 'es': 'Series de Culto'},
  'collection_notte': {'it': 'Notte Profonda', 'en': 'Deep Night', 'fr': 'Nuit Profonde', 'es': 'Noche Profunda'},
  'deep_abyss_theme': {'it': 'Deep Abyss', 'en': 'Deep Abyss', 'fr': 'Deep Abyss', 'es': 'Deep Abyss'},
  'deep_abyss_desc': {'it': 'Nero OLED puro, minimalismo spettrale e bagliori indaco', 'en': 'Pure OLED black, spectral minimalism and indigo glow', 'fr': 'Noir OLED pur, minimalisme spectral et lueur indigo', 'es': 'Negro OLED puro, minimalismo espectral y brillo índigo'},
  'midnight_forest_theme': {'it': 'Midnight Forest', 'en': 'Midnight Forest', 'fr': 'Midnight Forest', 'es': 'Midnight Forest'},
  'midnight_forest_desc': {'it': 'Verde notte organico, toni bronzo e atmosfera rilassante', 'en': 'Organic night green, bronze tones and relaxing atmosphere', 'fr': 'Vert nuit organique, tons bronze et atmosphère relaxante', 'es': 'Verde noche orgánico, tonos bronce y atmósfera relajante'},
  'cyberpunk_void_theme': {'it': 'Cyberpunk Void', 'en': 'Cyberpunk Void', 'fr': 'Cyberpunk Void', 'es': 'Cyberpunk Void'},
  'cyberpunk_void_desc': {'it': 'Neon ciano e magenta su antracite futuristico', 'en': 'Neon cyan and magenta on futuristic anthracite', 'fr': 'Néon cyan et magenta sur anthracite futuriste', 'es': 'Neón cian y magenta sobre antracita futurista'},
  'block_note_theme': {'it': 'Like a Block Note', 'en': 'Like a Block Note', 'fr': 'Like a Block Note', 'es': 'Like a Block Note'},
  'block_note_desc': {'it': 'Carta riciclata, post-it colorati e margine legale sbavato', 'en': 'Recycled paper, colorful post-its and smudged legal margin', 'fr': 'Papier recyclé, post-its colorés et marge légale bavée', 'es': 'Papel reciclado, post-its coloridos y margen legal difuminado'},
  'unlock_unlimited_profiles': {'it': 'Sblocca profili illimitati', 'en': 'Unlock unlimited profiles', 'fr': 'Débloquer profils illimités', 'es': 'Desbloquear perfiles ilimitados'},
  'max_duration': {'it': 'Durata massima', 'en': 'Max duration', 'fr': 'Durée maximale', 'es': 'Duración máxima'},
  'unlimited': {'it': 'Illimitata', 'en': 'Unlimited', 'fr': 'Illimitée', 'es': 'Ilimitada'},
  'compact_calendar': {'it': 'Calendario compatto', 'en': 'Compact calendar', 'fr': 'Calendrier compact', 'es': 'Calendario compacto'},
  'confirm_purchase': {'it': 'Conferma acquisto', 'en': 'Confirm purchase', 'fr': 'Confirmer l\'achat', 'es': 'Confirmar compra'},
  'purchase_confirm_msg': {'it': 'Vuoi acquistare questa funzionalità?', 'en': 'Do you want to purchase this feature?', 'fr': 'Voulez-vous acheter cette fonctionnalité?', 'es': '¿Deseas comprar esta función?'},
  'purchase_success': {'it': 'Acquisto completato!', 'en': 'Purchase completed!', 'fr': 'Achat terminé!', 'es': '¡Compra completada!'},
  'voice_duration': {'it': 'Durata nota vocale', 'en': 'Voice note duration', 'fr': 'Durée note vocale', 'es': 'Duración nota de voz'},
  'horoscope_locked': {'it': 'Oroscopo bloccato', 'en': 'Horoscope locked', 'fr': 'Horoscope verrouillé', 'es': 'Horóscopo bloqueado'},
  'unlock_to_read': {'it': 'Sblocca per leggere l\'oroscopo completo', 'en': 'Unlock to read the full horoscope', 'fr': 'Débloquez pour lire l\'horoscope complet', 'es': 'Desbloquea para leer el horóscopo completo'},
  // Samsung Health guide
  'samsung_health_guide': {'it': 'Guida Samsung Health', 'en': 'Samsung Health Guide', 'fr': 'Guide Samsung Health', 'es': 'Guía Samsung Health'},
  'samsung_health_guide_desc': {'it': 'Come collegare Samsung Health a Health Connect', 'en': 'How to connect Samsung Health to Health Connect', 'fr': 'Comment connecter Samsung Health à Health Connect', 'es': 'Cómo conectar Samsung Health a Health Connect'},
  'samsung_step_1': {
    'it': '1. Apri Samsung Health sul telefono',
    'en': '1. Open Samsung Health on your phone',
    'fr': '1. Ouvrez Samsung Health sur votre téléphone',
    'es': '1. Abre Samsung Health en tu teléfono',
  },
  'samsung_step_2': {
    'it': '2. Vai in Impostazioni (⚙️ in alto a destra)',
    'en': '2. Go to Settings (⚙️ top right)',
    'fr': '2. Allez dans Paramètres (⚙️ en haut à droite)',
    'es': '2. Ve a Ajustes (⚙️ arriba a la derecha)',
  },
  'samsung_step_3': {
    'it': '3. Tocca "App e servizi connessi"',
    'en': '3. Tap "Connected apps and services"',
    'fr': '3. Appuyez sur "Applications et services connectés"',
    'es': '3. Toca "Apps y servicios conectados"',
  },
  'samsung_step_4': {
    'it': '4. Attiva la sincronizzazione con Health Connect',
    'en': '4. Enable sync with Health Connect',
    'fr': '4. Activez la synchronisation avec Health Connect',
    'es': '4. Activa la sincronización con Health Connect',
  },
  'samsung_step_5': {
    'it': '5. Seleziona tutti i tipi di dati da condividere (passi, sonno, battito, ecc.)',
    'en': '5. Select all data types to share (steps, sleep, heart rate, etc.)',
    'fr': '5. Sélectionnez tous les types de données à partager (pas, sommeil, fréquence cardiaque, etc.)',
    'es': '5. Selecciona todos los tipos de datos a compartir (pasos, sueño, ritmo cardíaco, etc.)',
  },
  'samsung_step_6': {
    'it': '6. Torna qui e premi "Connetti Health Connect"',
    'en': '6. Come back here and tap "Connect Health Connect"',
    'fr': '6. Revenez ici et appuyez sur "Connecter Health Connect"',
    'es': '6. Vuelve aquí y pulsa "Conectar Health Connect"',
  },
  'samsung_note_install': {
    'it': 'Se non hai Health Connect, scaricalo gratis dal Google Play Store.',
    'en': 'If you don\'t have Health Connect, download it free from Google Play Store.',
    'fr': 'Si vous n\'avez pas Health Connect, téléchargez-le gratuitement depuis le Google Play Store.',
    'es': 'Si no tienes Health Connect, descárgalo gratis desde Google Play Store.',
  },
  'samsung_note_sync': {
    'it': 'I dati si sincronizzano automaticamente dopo il collegamento. Potrebbe servire qualche minuto.',
    'en': 'Data syncs automatically after linking. It may take a few minutes.',
    'fr': 'Les données se synchronisent automatiquement après la liaison. Cela peut prendre quelques minutes.',
    'es': 'Los datos se sincronizan automáticamente después de vincular. Puede tardar unos minutos.',
  },
  'health_connect_not_installed': {
    'it': 'Health Connect non trovato. Installa o aggiorna Health Connect dal Play Store e riprova.',
    'en': 'Health Connect not found. Install or update Health Connect from Play Store and try again.',
    'fr': 'Health Connect introuvable. Installez ou mettez à jour Health Connect depuis le Play Store et réessayez.',
    'es': 'Health Connect no encontrado. Instala o actualiza Health Connect desde Play Store e intenta de nuevo.',
  },
  'auth_denied_msg': {
    'it': 'Autorizzazione negata. Assicurati di concedere tutti i permessi richiesti nella schermata di Health Connect.',
    'en': 'Authorization denied. Make sure to grant all requested permissions in the Health Connect screen.',
    'fr': 'Autorisation refusée. Assurez-vous d\'accorder toutes les autorisations demandées dans l\'écran Health Connect.',
    'es': 'Autorización denegada. Asegúrate de conceder todos los permisos solicitados en la pantalla de Health Connect.',
  },
  'health_error_generic': {
    'it': 'Errore di connessione. Verifica che Health Connect sia installato e aggiornato.',
    'en': 'Connection error. Verify that Health Connect is installed and up to date.',
    'fr': 'Erreur de connexion. Vérifiez que Health Connect est installé et à jour.',
    'es': 'Error de conexión. Verifica que Health Connect esté instalado y actualizado.',
  },
  'biometric_auth': {
    'it': 'Autenticazione biometrica',
    'en': 'Biometric authentication',
    'fr': 'Authentification biométrique',
    'es': 'Autenticación biométrica',
  },
  'biometric_desc': {
    'it': 'Usa Face ID o impronta digitale per sbloccare la cartella privata',
    'en': 'Use Face ID or fingerprint to unlock the private folder',
    'fr': 'Utilisez Face ID ou empreinte digitale pour déverrouiller le dossier privé',
    'es': 'Usa Face ID o huella digital para desbloquear la carpeta privada',
  },
  'biometric_reason': {
    'it': 'Autenticati per accedere alla cartella privata',
    'en': 'Authenticate to access the private folder',
    'fr': 'Authentifiez-vous pour accéder au dossier privé',
    'es': 'Autentícate para acceder a la carpeta privada',
  },
  'biometric_not_available': {
    'it': 'Autenticazione biometrica non disponibile su questo dispositivo',
    'en': 'Biometric authentication not available on this device',
    'fr': 'Authentification biométrique non disponible sur cet appareil',
    'es': 'Autenticación biométrica no disponible en este dispositivo',
  },
  'pin_exactly_4': {
    'it': 'PIN di 4 cifre',
    'en': '4-digit PIN',
    'fr': 'PIN à 4 chiffres',
    'es': 'PIN de 4 dígitos',
  },
  'enable_biometric': {
    'it': 'Attivare la biometria?',
    'en': 'Enable biometrics?',
    'fr': 'Activer la biométrie ?',
    'es': '¿Activar biometría?',
  },
  'no_thanks': {
    'it': 'No grazie',
    'en': 'No thanks',
    'fr': 'Non merci',
    'es': 'No gracias',
  },
  'enable': {
    'it': 'Attiva',
    'en': 'Enable',
    'fr': 'Activer',
    'es': 'Activar',
  },
  'pin_must_be_4': {
    'it': 'Il PIN deve essere di 4 cifre',
    'en': 'PIN must be 4 digits',
    'fr': 'Le PIN doit comporter 4 chiffres',
    'es': 'El PIN debe tener 4 dígitos',
  },
  'settings_section': {
    'it': 'Impostazioni',
    'en': 'Settings',
    'fr': 'Paramètres',
    'es': 'Configuración',
  },
  'app_section': {
    'it': 'App',
    'en': 'App',
    'fr': 'App',
    'es': 'App',
  },
  'other_section': {
    'it': 'Altro',
    'en': 'Other',
    'fr': 'Autre',
    'es': 'Otros',
  },
  'export_as_pdf': {
    'it': 'Esporta PDF',
    'en': 'Export PDF',
    'fr': 'Exporter PDF',
    'es': 'Exportar PDF',
  },
  'exporting_pdf': {
    'it': 'Generazione PDF...',
    'en': 'Generating PDF...',
    'fr': 'Génération PDF...',
    'es': 'Generando PDF...',
  },
  'image_too_large': {
    'it': 'Immagine troppo grande (max 2MB)',
    'en': 'Image too large (max 2MB)',
    'fr': 'Image trop grande (max 2 Mo)',
    'es': 'Imagen demasiado grande (máx 2MB)',
  },
  'folder_options': {
    'it': 'Opzioni Cartella',
    'en': 'Folder Options',
    'fr': 'Options du dossier',
    'es': 'Opciones de carpeta',
  },
  'edit_folder': {
    'it': 'Modifica Cartella',
    'en': 'Edit Folder',
    'fr': 'Modifier le dossier',
    'es': 'Editar carpeta',
  },
  'make_private': {
    'it': 'Rendi Privata',
    'en': 'Make Private',
    'fr': 'Rendre privé',
    'es': 'Hacer privada',
  },
  'folder_is_private': {
    'it': 'Cartella protetta da PIN',
    'en': 'Folder protected by PIN',
    'fr': 'Dossier protégé par PIN',
    'es': 'Carpeta protegida por PIN',
  },
  'cannot_delete_builtin': {
    'it': 'Cartella predefinita',
    'en': 'Built-in folder',
    'fr': 'Dossier prédéfini',
    'es': 'Carpeta predeterminada',
  },
  'recurrence': {
    'it': 'Ricorrenza',
    'en': 'Recurrence',
    'fr': 'Récurrence',
    'es': 'Recurrencia',
  },
  'no_recurrence': {
    'it': 'Nessuna',
    'en': 'None',
    'fr': 'Aucune',
    'es': 'Ninguna',
  },
  'yearly': {
    'it': 'Annuale',
    'en': 'Yearly',
    'fr': 'Annuel',
    'es': 'Anual',
  },
  'recurring_event': {
    'it': 'Evento ricorrente',
    'en': 'Recurring event',
    'fr': 'Événement récurrent',
    'es': 'Evento recurrente',
  },
  'repeat_until': {
    'it': 'Ripeti fino a',
    'en': 'Repeat until',
    'fr': 'Répéter jusqu\'à',
    'es': 'Repetir hasta',
  },
  'voice_note_title': {
    'it': 'Titolo nota vocale',
    'en': 'Voice note title',
    'fr': 'Titre note vocale',
    'es': 'Título nota de voz',
  },
  'optional_title': {
    'it': 'Titolo (opzionale)',
    'en': 'Title (optional)',
    'fr': 'Titre (optionnel)',
    'es': 'Título (opcional)',
  },
  'attach_photo': {
    'it': 'Allega foto',
    'en': 'Attach photo',
    'fr': 'Joindre photo',
    'es': 'Adjuntar foto',
  },
  'title_format': {
    'it': 'Formato titolo',
    'en': 'Title format',
    'fr': 'Format du titre',
    'es': 'Formato título',
  },
  'all_caps': {
    'it': 'TUTTO MAIUSCOLO',
    'en': 'ALL CAPS',
    'fr': 'TOUT EN MAJUSCULES',
    'es': 'TODO MAYÚSCULAS',
  },
  'capitalize_words': {
    'it': 'Prime Lettere Maiuscole',
    'en': 'Capitalize Words',
    'fr': 'Majuscules Initiales',
    'es': 'Capitalizar Palabras',
  },
  'text_align': {
    'it': 'Allineamento',
    'en': 'Alignment',
    'fr': 'Alignement',
    'es': 'Alineación',
  },
  'cycle_period': {
    'it': 'Periodo del ciclo',
    'en': 'Cycle period',
    'fr': 'Période du cycle',
    'es': 'Período del ciclo',
  },
  'cycle_period_days': {
    'it': 'Durata ciclo (giorni)',
    'en': 'Cycle duration (days)',
    'fr': 'Durée du cycle (jours)',
    'es': 'Duración del ciclo (días)',
  },
  'flow_intensity': {
    'it': 'Intensità flusso',
    'en': 'Flow intensity',
    'fr': 'Intensité du flux',
    'es': 'Intensidad del flujo',
  },
  'flow_light': {
    'it': 'Poco',
    'en': 'Light',
    'fr': 'Léger',
    'es': 'Ligero',
  },
  'flow_medium': {
    'it': 'Medio',
    'en': 'Medium',
    'fr': 'Moyen',
    'es': 'Medio',
  },
  'flow_heavy': {
    'it': 'Tanto',
    'en': 'Heavy',
    'fr': 'Abondant',
    'es': 'Abundante',
  },
  'flow_very_heavy': {
    'it': 'Abbondante',
    'en': 'Very heavy',
    'fr': 'Très abondant',
    'es': 'Muy abundante',
  },
  'health_goals_met': {
    'it': 'Obiettivi raggiunti!',
    'en': 'Goals met!',
    'fr': 'Objectifs atteints !',
    'es': '¡Objetivos cumplidos!',
  },
  'export_note_pdf': {
    'it': 'Esporta PDF',
    'en': 'Export PDF',
    'fr': 'Exporter PDF',
    'es': 'Exportar PDF',
  },
  'emoji_icon': {
    'it': 'Emoji',
    'en': 'Emoji',
    'fr': 'Emoji',
    'es': 'Emoji',
  },
  'checklist': {
    'it': 'Lista di controllo',
    'en': 'Checklist',
    'fr': 'Liste de contrôle',
    'es': 'Lista de verificación',
  },
  'add_item': {
    'it': 'Aggiungi elemento',
    'en': 'Add item',
    'fr': 'Ajouter un élément',
    'es': 'Añadir elemento',
  },
  'completed_count': {
    'it': '{done}/{total} completati',
    'en': '{done}/{total} completed',
    'fr': '{done}/{total} terminés',
    'es': '{done}/{total} completados',
  },
  'predicted_cycle': {
    'it': 'Ciclo previsto',
    'en': 'Predicted cycle',
    'fr': 'Cycle prévu',
    'es': 'Ciclo previsto',
  },
  'forever': {
    'it': 'Per sempre',
    'en': 'Forever',
    'fr': 'Pour toujours',
    'es': 'Para siempre',
  },
  'general_settings': {'it': 'Impostazioni Generali', 'en': 'General Settings', 'fr': 'Paramètres généraux', 'es': 'Ajustes generales'},
  'biometric_lock': {'it': 'Blocco Biometrico', 'en': 'Biometric Lock', 'fr': 'Verrouillage biométrique', 'es': 'Bloqueo biométrico'},
  'pin_and_biometric_lock': {'it': 'PIN e Blocco Biometrico', 'en': 'PIN & Biometric Lock', 'fr': 'PIN et verrouillage biométrique', 'es': 'PIN y bloqueo biométrico'},
  'set_pin_to_enable': {'it': 'Imposta un PIN per attivare il blocco', 'en': 'Set a PIN to enable lock', 'fr': 'Définissez un PIN pour activer le verrouillage', 'es': 'Establece un PIN para activar el bloqueo'},
  'enter_4_digit_pin': {'it': 'Inserisci PIN a 4 cifre', 'en': 'Enter 4-digit PIN', 'fr': 'Entrez un PIN à 4 chiffres', 'es': 'Introduce un PIN de 4 dígitos'},
  'confirm_4_digit_pin': {'it': 'Conferma PIN a 4 cifre', 'en': 'Confirm 4-digit PIN', 'fr': 'Confirmez le PIN à 4 chiffres', 'es': 'Confirma el PIN de 4 dígitos'},
  'pin_created': {'it': 'PIN creato', 'en': 'PIN created', 'fr': 'PIN créé', 'es': 'PIN creado'},
  'authenticate_to_change': {'it': 'Autenticati per modificare', 'en': 'Authenticate to change', 'fr': 'Authentifiez-vous pour modifier', 'es': 'Autentícate para modificar'},
  'lock_deep_note': {'it': 'Blocca Deep Note', 'en': 'Lock Deep Note', 'fr': 'Verrouiller Deep Note', 'es': 'Bloquear Deep Note'},
  'lock_deep_note_desc': {'it': 'Richiedi autenticazione biometrica per accedere a Deep Note', 'en': 'Require biometric authentication to access Deep Note', 'fr': 'Exiger une authentification biométrique pour accéder à Deep Note', 'es': 'Requerir autenticación biométrica para acceder a Deep Note'},
  'lock_flash_notes': {'it': 'Blocca Flash Notes', 'en': 'Lock Flash Notes', 'fr': 'Verrouiller Flash Notes', 'es': 'Bloquear Flash Notes'},
  'lock_flash_notes_desc': {'it': 'Richiedi autenticazione biometrica per accedere a Flash Notes', 'en': 'Require biometric authentication to access Flash Notes', 'fr': 'Exiger une authentification biométrique pour accéder à Flash Notes', 'es': 'Requerir autenticación biométrica para acceder a Flash Notes'},
  'save_flash_to_deep': {'it': 'Salvataggio in Deep Note', 'en': 'Save to Deep Note', 'fr': 'Sauvegarde dans Deep Note', 'es': 'Guardar en Deep Note'},
  'ai_formatting': {'it': 'Formattazione AI', 'en': 'AI Formatting', 'fr': 'Formatage IA', 'es': 'Formato IA'},
  'simple_formatting': {'it': 'Semplice', 'en': 'Simple', 'fr': 'Simple', 'es': 'Simple'},
  'advanced_formatting': {'it': 'Avanzata', 'en': 'Advanced', 'fr': 'Avancé', 'es': 'Avanzado'},
  'simple_formatting_desc': {'it': 'Corregge ortografia e punteggiatura', 'en': 'Corrects spelling and punctuation', 'fr': 'Corrige l\'orthographe et la ponctuation', 'es': 'Corrige ortografía y puntuación'},
  'advanced_formatting_desc': {'it': 'Formattazione completa con titolo, paragrafi ed elenchi', 'en': 'Full formatting with title, paragraphs and lists', 'fr': 'Formatage complet avec titre, paragraphes et listes', 'es': 'Formato completo con título, párrafos y listas'},
  'current_pin': {'it': 'PIN attuale', 'en': 'Current PIN', 'fr': 'PIN actuel', 'es': 'PIN actual'},
  'new_pin': {'it': 'Nuovo PIN', 'en': 'New PIN', 'fr': 'Nouveau PIN', 'es': 'Nuevo PIN'},
  'confirm_pin': {'it': 'Conferma PIN', 'en': 'Confirm PIN', 'fr': 'Confirmer le PIN', 'es': 'Confirmar PIN'},
  'pins_dont_match': {'it': 'I PIN non corrispondono', 'en': 'PINs don\'t match', 'fr': 'Les PIN ne correspondent pas', 'es': 'Los PIN no coinciden'},
  'import_template': {'it': 'Importa Template', 'en': 'Import Template', 'fr': 'Importer un modèle', 'es': 'Importar plantilla'},
  'create_template': {'it': 'Crea Template', 'en': 'Create Template', 'fr': 'Créer un modèle', 'es': 'Crear plantilla'},
  'auth_required': {'it': 'Autenticazione richiesta', 'en': 'Authentication required', 'fr': 'Authentification requise', 'es': 'Autenticación requerida'},
  'auth_to_access': {'it': 'Autenticati per accedere', 'en': 'Authenticate to access', 'fr': 'Authentifiez-vous pour accéder', 'es': 'Autentíquese para acceder'},

  // ── Welcome / Auth ──
  'welcome_title': {'it': 'Benvenuto su Ethos Note', 'en': 'Welcome to Ethos Note', 'fr': 'Bienvenue sur Ethos Note', 'es': 'Bienvenido a Ethos Note'},
  'welcome_subtitle': {'it': 'Le tue note, il tuo calendario, tutto in un posto', 'en': 'Your notes, your calendar, all in one place', 'fr': 'Vos notes, votre calendrier, tout en un seul endroit', 'es': 'Tus notas, tu calendario, todo en un lugar'},
  'sign_in_google': {'it': 'Accedi con Google', 'en': 'Sign in with Google', 'fr': 'Se connecter avec Google', 'es': 'Iniciar sesión con Google'},
  'continue_without_account': {'it': 'Continua senza account', 'en': 'Continue without account', 'fr': 'Continuer sans compte', 'es': 'Continuar sin cuenta'},
  'sign_out': {'it': 'Esci', 'en': 'Sign out', 'fr': 'Se déconnecter', 'es': 'Cerrar sesión'},
  'signed_in_as': {'it': 'Accesso come', 'en': 'Signed in as', 'fr': 'Connecté en tant que', 'es': 'Conectado como'},
  'welcome_feature_1': {'it': 'Note ricche con editor avanzato', 'en': 'Rich notes with advanced editor', 'fr': 'Notes riches avec éditeur avancé', 'es': 'Notas ricas con editor avanzado'},
  'welcome_feature_2': {'it': 'Calendario con sync Google', 'en': 'Calendar with Google sync', 'fr': 'Calendrier avec sync Google', 'es': 'Calendario con sincronización Google'},
  'welcome_feature_3': {'it': 'Flash Notes con AI', 'en': 'Flash Notes with AI', 'fr': 'Flash Notes avec IA', 'es': 'Flash Notes con IA'},

  // ── Hardcoded string fixes ──
  'redo': {'it': 'Ripeti', 'en': 'Redo', 'fr': 'Rétablir', 'es': 'Rehacer'},
  'ok': {'it': 'OK', 'en': 'OK', 'fr': 'OK', 'es': 'OK'},
  'cut': {'it': 'Taglia', 'en': 'Cut', 'fr': 'Couper', 'es': 'Cortar'},
  'paste': {'it': 'Incolla', 'en': 'Paste', 'fr': 'Coller', 'es': 'Pegar'},
  'show_label': {'it': 'Mostra', 'en': 'Show', 'fr': 'Afficher', 'es': 'Mostrar'},
  'hide_label': {'it': 'Nascondi', 'en': 'Hide', 'fr': 'Masquer', 'es': 'Ocultar'},
  'list_view_tooltip': {'it': 'Vista elenco', 'en': 'List view', 'fr': 'Vue liste', 'es': 'Vista lista'},
  'grid_view_tooltip': {'it': 'Vista griglia', 'en': 'Grid view', 'fr': 'Vue grille', 'es': 'Vista cuadrícula'},
  'enter_api_key': {'it': 'Inserisci API Key', 'en': 'Enter API Key', 'fr': 'Entrer la clé API', 'es': 'Introducir clave API'},
  'edit_api_key': {'it': 'Modifica API Key', 'en': 'Edit API Key', 'fr': 'Modifier la clé API', 'es': 'Editar clave API'},
  'api_key_copied': {'it': 'API Key copiata', 'en': 'API Key copied', 'fr': 'Clé API copiée', 'es': 'Clave API copiada'},
  'paste_gemini_api_key': {'it': 'Incolla la tua chiave API di Gemini ottenuta da Google AI Studio.', 'en': 'Paste your Gemini API key obtained from Google AI Studio.', 'fr': 'Collez votre clé API Gemini obtenue sur Google AI Studio.', 'es': 'Pega tu clave API de Gemini obtenida en Google AI Studio.'},
  'auth_for_api_key': {'it': 'Autenticati per accedere alla API Key', 'en': 'Authenticate to access the API Key', 'fr': 'Authentifiez-vous pour accéder à la clé API', 'es': 'Autentícate para acceder a la clave API'},
  'photo_in_pdf': {'it': 'Foto nel PDF', 'en': 'Photos in PDF', 'fr': 'Photos dans le PDF', 'es': 'Fotos en PDF'},
  'photo_in_pdf_question': {'it': 'Come vuoi le foto nel PDF?', 'en': 'How do you want photos in the PDF?', 'fr': 'Comment voulez-vous les photos dans le PDF ?', 'es': '¿Cómo quieres las fotos en el PDF?'},
  'same_page': {'it': 'Stessa pagina', 'en': 'Same page', 'fr': 'Même page', 'es': 'Misma página'},
  'separate_page': {'it': 'Pagina separata', 'en': 'Separate page', 'fr': 'Page séparée', 'es': 'Página separada'},
  'create_pdf': {'it': 'Crea PDF', 'en': 'Create PDF', 'fr': 'Créer PDF', 'es': 'Crear PDF'},
  'correct': {'it': 'Correggi', 'en': 'Correct', 'fr': 'Corriger', 'es': 'Corregir'},
  'correct_and_format': {'it': 'Correggi e formatta', 'en': 'Correct and format', 'fr': 'Corriger et formater', 'es': 'Corregir y formatear'},
  'move_to_deep_note': {'it': 'Sposta in Deep Note', 'en': 'Move to Deep Note', 'fr': 'Déplacer vers Deep Note', 'es': 'Mover a Deep Note'},
  'cycle_label': {'it': 'Ciclo', 'en': 'Period', 'fr': 'Règles', 'es': 'Periodo'},
  'remove_cycle': {'it': 'Rimuovi ciclo', 'en': 'Remove period', 'fr': 'Retirer les règles', 'es': 'Quitar periodo'},
  'mark_cycle': {'it': 'Segna ciclo', 'en': 'Mark period', 'fr': 'Marquer les règles', 'es': 'Marcar periodo'},
  'scheduled_test': {'it': 'Test programmato', 'en': 'Scheduled test', 'fr': 'Test programmé', 'es': 'Prueba programada'},
  'scheduled_notification_10s': {'it': 'Notifica programmata tra 10 secondi...', 'en': 'Scheduled notification in 10 seconds...', 'fr': 'Notification programmée dans 10 secondes...', 'es': 'Notificación programada en 10 segundos...'},
  'notification_schedule_error': {'it': 'Errore: controlla i permessi notifiche e sveglie esatte.', 'en': 'Error: check notification and exact alarm permissions.', 'fr': 'Erreur : vérifiez les autorisations de notifications et d\'alarmes exactes.', 'es': 'Error: comprueba los permisos de notificaciones y alarmas exactas.'},
  'app_will_close_reopen': {'it': 'L\'app verrà chiusa. Riaprila per vedere i dati importati.', 'en': 'The app will close. Reopen it to see imported data.', 'fr': 'L\'app va se fermer. Rouvrez-la pour voir les données importées.', 'es': 'La app se cerrará. Ábrela de nuevo para ver los datos importados.'},
  'transcription_in_progress': {'it': 'Trascrizione in corso...', 'en': 'Transcription in progress...', 'fr': 'Transcription en cours...', 'es': 'Transcripción en curso...'},
  'apply_transcription': {'it': 'Applica trascrizione', 'en': 'Apply transcription', 'fr': 'Appliquer la transcription', 'es': 'Aplicar transcripción'},
  'apply_correction': {'it': 'Applica correzione', 'en': 'Apply correction', 'fr': 'Appliquer la correction', 'es': 'Aplicar corrección'},
  'align_left_short': {'it': 'Sinistra', 'en': 'Left', 'fr': 'Gauche', 'es': 'Izquierda'},
  'align_center_short': {'it': 'Centro', 'en': 'Center', 'fr': 'Centre', 'es': 'Centro'},
  'align_right_short': {'it': 'Destra', 'en': 'Right', 'fr': 'Droite', 'es': 'Derecha'},
};

// ─── SQLite Database Helper ──────────────────────────────────────────────────

class DatabaseHelper {
  static final DatabaseHelper _instance = DatabaseHelper._internal();
  factory DatabaseHelper() => _instance;
  DatabaseHelper._internal();

  static Database? _database;
  static bool _webMode = false;
  static void enableWebMode() => _webMode = true;
  bool get isWebMode => _webMode;

  // ── Web-mode in-memory storage ──
  static final List<ProNote> _wProNotes = [];
  static final List<FlashNote> _wFlashNotes = [];
  static final Map<String, List<CalendarEventFull>> _wEvents = {};
  static UserProfile? _wProfile;
  static final List<TrashedNote> _wTrashed = [];
  static final Map<String, FolderStyle> _wFolders = {};
  static final Map<String, String> _wSettings = {};
  static final Map<String, String> _wCache = {};
  static final Set<String> _wCycleDays = {};
  static int _wAutoId = 1;
  static int _nextId() => _wAutoId++;

  Future<Database> get database async {
    if (_webMode) throw StateError('Web mode — use CRUD methods directly');
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  Future<void> close() async {
    if (_database != null) {
      await _database!.close();
      _database = null;
    }
  }

  Future<Database> _initDatabase() async {
    final dbPath = await getDatabasesPath();
    final path = p.join(dbPath, 'ethos_note.db');
    return await openDatabase(
      path,
      version: 9,
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    if (oldVersion < 2) {
      await db.execute('ALTER TABLE flash_notes ADD COLUMN image_base64 TEXT');
    }
    if (oldVersion < 3) {
      await db.execute('ALTER TABLE custom_folders ADD COLUMN is_private INTEGER DEFAULT 0');
    }
    if (oldVersion < 4) {
      await db.execute('ALTER TABLE calendar_events ADD COLUMN recurrence TEXT');
      await db.execute('ALTER TABLE calendar_events ADD COLUMN recurrence_end_date TEXT');
      await db.execute('ALTER TABLE cycle_days ADD COLUMN flow_intensity TEXT DEFAULT \'medium\'');
      await db.execute('ALTER TABLE custom_folders ADD COLUMN emoji_icon TEXT');
    }
    if (oldVersion < 5) {
      await db.execute('ALTER TABLE user_profile ADD COLUMN lock_deep_note INTEGER DEFAULT 0');
      await db.execute('ALTER TABLE user_profile ADD COLUMN lock_flash_notes INTEGER DEFAULT 0');
    }
    if (oldVersion < 6) {
      await db.execute('ALTER TABLE pro_notes ADD COLUMN image_base64 TEXT');
    }
    if (oldVersion < 7) {
      await db.execute('ALTER TABLE pro_notes ADD COLUMN updated_at INTEGER');
    }
    if (oldVersion < 8) {
      await db.execute('ALTER TABLE flash_notes ADD COLUMN image_path TEXT');
      await db.execute('ALTER TABLE pro_notes ADD COLUMN image_path TEXT');
    }
    if (oldVersion < 9) {
      await db.execute('ALTER TABLE flash_notes ADD COLUMN is_pinned INTEGER NOT NULL DEFAULT 0');
      await db.execute('ALTER TABLE pro_notes ADD COLUMN is_pinned INTEGER NOT NULL DEFAULT 0');
    }
  }

  Future<void> _onCreate(Database db, int version) async {
    await db.execute('''
      CREATE TABLE pro_notes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL, content TEXT NOT NULL, content_delta TEXT,
        header_text TEXT, footer_text TEXT, template_preset TEXT,
        folder TEXT NOT NULL DEFAULT 'Generale',
        linked_date INTEGER, created_at INTEGER NOT NULL,
        image_base64 TEXT, updated_at INTEGER, image_path TEXT,
        is_pinned INTEGER NOT NULL DEFAULT 0
      )
    ''');
    await db.execute('CREATE INDEX idx_pro_notes_folder ON pro_notes(folder)');
    await db.execute('CREATE INDEX idx_pro_notes_created_at ON pro_notes(created_at)');

    await db.execute('''
      CREATE TABLE flash_notes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        content TEXT NOT NULL, audio_path TEXT, audio_duration_ms INTEGER,
        image_base64 TEXT, created_at INTEGER NOT NULL, image_path TEXT,
        is_pinned INTEGER NOT NULL DEFAULT 0
      )
    ''');
    await db.execute('CREATE INDEX idx_flash_notes_created_at ON flash_notes(created_at)');

    await db.execute('''
      CREATE TABLE calendar_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL, start_time INTEGER NOT NULL, end_time INTEGER NOT NULL,
        date_key TEXT NOT NULL, calendar TEXT NOT NULL DEFAULT 'Personale',
        reminder TEXT, preset TEXT, attachment_path TEXT, attachment_base64 TEXT,
        notes TEXT, is_completed INTEGER NOT NULL DEFAULT 0,
        google_event_id TEXT, shared_with TEXT,
        recurrence TEXT, recurrence_end_date TEXT
      )
    ''');
    await db.execute('CREATE INDEX idx_calendar_events_date_key ON calendar_events(date_key)');

    await db.execute('''
      CREATE TABLE user_profile (
        id INTEGER PRIMARY KEY DEFAULT 1,
        nome TEXT, cognome TEXT, email TEXT, data_nascita INTEGER,
        is_pro INTEGER DEFAULT 0, photo_path TEXT, photo_base64 TEXT,
        google_calendar_connected INTEGER DEFAULT 0, google_drive_connected INTEGER DEFAULT 0,
        gemini_connected INTEGER DEFAULT 0, backup_mode TEXT DEFAULT 'local',
        religione TEXT DEFAULT 'Cattolica', telefono TEXT, password TEXT,
        social_links TEXT, friends TEXT, old_photos TEXT, accounts TEXT,
        active_account_index INTEGER DEFAULT 0, nickname TEXT,
        lock_deep_note INTEGER DEFAULT 0, lock_flash_notes INTEGER DEFAULT 0
      )
    ''');

    await db.execute('''
      CREATE TABLE trashed_notes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        type TEXT NOT NULL, note_json TEXT NOT NULL, deleted_at INTEGER NOT NULL
      )
    ''');
    await db.execute('CREATE INDEX idx_trashed_notes_deleted_at ON trashed_notes(deleted_at)');

    await db.execute('''
      CREATE TABLE custom_folders (
        name TEXT PRIMARY KEY,
        icon_code INTEGER NOT NULL, color_value INTEGER NOT NULL,
        is_custom INTEGER DEFAULT 1, is_shared INTEGER DEFAULT 0, is_private INTEGER DEFAULT 0, shared_emails TEXT,
        emoji_icon TEXT
      )
    ''');

    await db.execute('CREATE TABLE settings (key TEXT PRIMARY KEY, value TEXT NOT NULL)');
    await db.execute('CREATE TABLE cache (key TEXT PRIMARY KEY, value TEXT NOT NULL, updated_at INTEGER NOT NULL)');
    await db.execute('CREATE TABLE cycle_days (day_key TEXT PRIMARY KEY, flow_intensity TEXT DEFAULT \'medium\')');
  }

  // ── Pro Notes CRUD ──

  Future<int> insertProNote(ProNote note) async {
    if (_webMode) { final id = _nextId(); _wProNotes.insert(0, ProNote(id: id, title: note.title, content: note.content, contentDelta: note.contentDelta, headerText: note.headerText, footerText: note.footerText, templatePreset: note.templatePreset, folder: note.folder, linkedDate: note.linkedDate, imageBase64: note.imageBase64, imagePath: note.imagePath, createdAt: note.createdAt)); return id; }
    final db = await database;
    return await db.insert('pro_notes', note.toDbMap());
  }

  Future<List<ProNote>> getAllProNotes() async {
    if (_webMode) return List.of(_wProNotes);
    final db = await database;
    // Load without image_base64 first to avoid CursorWindow overflow
    final maps = await db.query('pro_notes',
      columns: ['id', 'title', 'content', 'content_delta', 'header_text', 'footer_text',
                 'template_preset', 'folder', 'linked_date', 'created_at', 'updated_at', 'image_path', 'is_pinned'],
      orderBy: 'created_at DESC',
    );
    final notes = <ProNote>[];
    for (final m in maps) {
      final noteId = m['id'] as int?;
      final imgPath = m['image_path'] as String?;
      String? imgB64;
      // Only load base64 if no file path exists (legacy data)
      if (noteId != null && (imgPath == null || imgPath.isEmpty)) {
        try {
          final imgRows = await db.query('pro_notes',
            columns: ['image_base64'],
            where: 'id = ?', whereArgs: [noteId],
          );
          if (imgRows.isNotEmpty) imgB64 = imgRows.first['image_base64'] as String?;
        } catch (_) {}
      }
      notes.add(ProNote(
        id: noteId,
        title: m['title'] as String,
        content: m['content'] as String,
        contentDelta: m['content_delta'] as String?,
        headerText: m['header_text'] as String?,
        footerText: m['footer_text'] as String?,
        templatePreset: m['template_preset'] as String?,
        folder: (m['folder'] as String?) ?? 'Generale',
        linkedDate: m['linked_date'] != null ? DateTime.fromMillisecondsSinceEpoch(m['linked_date'] as int) : null,
        createdAt: DateTime.fromMillisecondsSinceEpoch(m['created_at'] as int),
        updatedAt: m['updated_at'] != null ? DateTime.fromMillisecondsSinceEpoch(m['updated_at'] as int) : null,
        imageBase64: imgB64,
        imagePath: imgPath,
        isPinned: (m['is_pinned'] as int?) == 1,
      ));
    }
    return notes;
  }

  Future<int> updateProNote(int id, ProNote note) async {
    if (_webMode) { final i = _wProNotes.indexWhere((n) => n.id == id); if (i >= 0) _wProNotes[i] = ProNote(id: id, title: note.title, content: note.content, contentDelta: note.contentDelta, headerText: note.headerText, footerText: note.footerText, templatePreset: note.templatePreset, folder: note.folder, linkedDate: note.linkedDate, imageBase64: note.imageBase64, imagePath: note.imagePath, createdAt: note.createdAt, isPinned: note.isPinned); return 1; }
    final db = await database;
    return await db.update('pro_notes', note.toDbMap(), where: 'id = ?', whereArgs: [id]);
  }

  Future<int> deleteProNote(int id) async {
    if (_webMode) { _wProNotes.removeWhere((n) => n.id == id); return 1; }
    final db = await database;
    return await db.delete('pro_notes', where: 'id = ?', whereArgs: [id]);
  }

  // ── Flash Notes CRUD ──

  Future<int> insertFlashNote(FlashNote note) async {
    if (_webMode) { final id = _nextId(); _wFlashNotes.insert(0, FlashNote(id: id, content: note.content, audioPath: note.audioPath, audioDurationMs: note.audioDurationMs, imageBase64: note.imageBase64, imagePath: note.imagePath, createdAt: note.createdAt)); return id; }
    final db = await database;
    return await db.insert('flash_notes', note.toDbMap());
  }

  Future<List<FlashNote>> getAllFlashNotes() async {
    if (_webMode) return List.of(_wFlashNotes);
    final db = await database;
    // Load without image_base64 first to avoid CursorWindow overflow
    final maps = await db.query('flash_notes',
      columns: ['id', 'content', 'created_at', 'audio_path', 'audio_duration_ms', 'image_path', 'is_pinned'],
      orderBy: 'created_at DESC',
    );
    final notes = <FlashNote>[];
    for (final m in maps) {
      final noteId = m['id'] as int?;
      final imgPath = m['image_path'] as String?;
      String? imgB64;
      // Only load base64 if no file path exists (legacy data)
      if (noteId != null && (imgPath == null || imgPath.isEmpty)) {
        try {
          final imgRows = await db.query('flash_notes',
            columns: ['image_base64'],
            where: 'id = ?', whereArgs: [noteId],
          );
          if (imgRows.isNotEmpty) imgB64 = imgRows.first['image_base64'] as String?;
        } catch (_) {}
      }
      notes.add(FlashNote(
        id: noteId,
        content: m['content'] as String,
        createdAt: DateTime.fromMillisecondsSinceEpoch(m['created_at'] as int),
        audioPath: m['audio_path'] as String?,
        audioDurationMs: m['audio_duration_ms'] as int?,
        imageBase64: imgB64,
        imagePath: imgPath,
        isPinned: (m['is_pinned'] as int?) == 1,
      ));
    }
    return notes;
  }

  Future<int> updateFlashNote(int id, FlashNote note) async {
    if (_webMode) { final i = _wFlashNotes.indexWhere((n) => n.id == id); if (i >= 0) _wFlashNotes[i] = FlashNote(id: id, content: note.content, audioPath: note.audioPath, audioDurationMs: note.audioDurationMs, imageBase64: note.imageBase64, imagePath: note.imagePath, createdAt: note.createdAt, isPinned: note.isPinned); return 1; }
    final db = await database;
    return await db.update('flash_notes', note.toDbMap(), where: 'id = ?', whereArgs: [id]);
  }

  Future<int> deleteFlashNote(int id) async {
    if (_webMode) { _wFlashNotes.removeWhere((n) => n.id == id); return 1; }
    final db = await database;
    return await db.delete('flash_notes', where: 'id = ?', whereArgs: [id]);
  }

  // ── Calendar Events CRUD ──

  Future<int> insertEvent(CalendarEventFull event) async {
    if (_webMode) { final id = _nextId(); final e = CalendarEventFull(id: id, title: event.title, startTime: event.startTime, endTime: event.endTime, calendar: event.calendar, reminder: event.reminder, preset: event.preset, attachmentPath: event.attachmentPath, attachmentBase64: event.attachmentBase64, notes: event.notes, isCompleted: event.isCompleted, googleEventId: event.googleEventId, sharedWith: event.sharedWith); final key = '${event.startTime.year}-${event.startTime.month.toString().padLeft(2,'0')}-${event.startTime.day.toString().padLeft(2,'0')}'; _wEvents.putIfAbsent(key, () => []).add(e); return id; }
    final db = await database;
    return await db.insert('calendar_events', event.toDbMap());
  }

  Future<Map<String, List<CalendarEventFull>>> getAllEvents() async {
    if (_webMode) return Map.of(_wEvents);
    final db = await database;
    final maps = await db.query('calendar_events', orderBy: 'start_time ASC');
    final result = <String, List<CalendarEventFull>>{};
    for (final m in maps) {
      final event = CalendarEventFull.fromDbMap(m);
      final key = m['date_key'] as String;
      result.putIfAbsent(key, () => []).add(event);
    }
    return result;
  }

  Future<int> updateEvent(int id, CalendarEventFull event) async {
    if (_webMode) { for (final list in _wEvents.values) { final i = list.indexWhere((e) => e.id == id); if (i >= 0) { list[i] = CalendarEventFull(id: id, title: event.title, startTime: event.startTime, endTime: event.endTime, calendar: event.calendar, reminder: event.reminder, preset: event.preset, attachmentPath: event.attachmentPath, attachmentBase64: event.attachmentBase64, notes: event.notes, isCompleted: event.isCompleted, googleEventId: event.googleEventId, sharedWith: event.sharedWith); return 1; } } return 0; }
    final db = await database;
    return await db.update('calendar_events', event.toDbMap(), where: 'id = ?', whereArgs: [id]);
  }

  Future<int> deleteEvent(int id) async {
    if (_webMode) { for (final list in _wEvents.values) { list.removeWhere((e) => e.id == id); } _wEvents.removeWhere((k, v) => v.isEmpty); return 1; }
    final db = await database;
    return await db.delete('calendar_events', where: 'id = ?', whereArgs: [id]);
  }

  Future<void> saveAllEvents(Map<String, List<CalendarEventFull>> events) async {
    if (_webMode) { _wEvents.clear(); _wEvents.addAll(events); return; }
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('calendar_events');
      final batch = txn.batch();
      for (final entry in events.entries) {
        for (final event in entry.value) {
          batch.insert('calendar_events', event.toDbMap());
        }
      }
      await batch.commit(noResult: true);
    });
  }

  // ── User Profile ──

  Future<UserProfile?> getProfile() async {
    if (_webMode) return _wProfile;
    final db = await database;
    final maps = await db.query('user_profile', where: 'id = 1');
    if (maps.isEmpty) return null;
    return UserProfile.fromDbMap(maps.first);
  }

  Future<void> saveProfile(UserProfile profile) async {
    if (_webMode) { _wProfile = profile; return; }
    final db = await database;
    final map = profile.toDbMap();
    map['id'] = 1;
    await db.insert('user_profile', map, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  // ── Trashed Notes ──

  Future<int> insertTrashedNote(TrashedNote note) async {
    if (_webMode) { final id = _nextId(); _wTrashed.insert(0, TrashedNote(id: id, type: note.type, noteJson: note.noteJson, deletedAt: note.deletedAt)); return id; }
    final db = await database;
    return await db.insert('trashed_notes', note.toDbMap());
  }

  Future<List<TrashedNote>> getAllTrashedNotes() async {
    if (_webMode) return List.of(_wTrashed);
    final db = await database;
    final maps = await db.query('trashed_notes', orderBy: 'deleted_at DESC');
    return maps.map((m) => TrashedNote.fromDbMap(m)).toList();
  }

  Future<int> deleteTrashedNote(int id) async {
    if (_webMode) { _wTrashed.removeWhere((n) => n.id == id); return 1; }
    final db = await database;
    return await db.delete('trashed_notes', where: 'id = ?', whereArgs: [id]);
  }

  Future<void> cleanExpiredTrash(int retentionDays) async {
    if (_webMode) { final cutoff = DateTime.now().subtract(Duration(days: retentionDays)); _wTrashed.removeWhere((n) => n.deletedAt.isBefore(cutoff)); return; }
    final db = await database;
    final cutoff = DateTime.now().subtract(Duration(days: retentionDays)).millisecondsSinceEpoch;
    // Delete image files before removing DB records
    final expiredRows = await db.query('trashed_notes', where: 'deleted_at < ?', whereArgs: [cutoff]);
    final imgHelper = ImageStorageHelper();
    for (final row in expiredRows) {
      try {
        final noteJson = json.decode(row['note_json'] as String) as Map<String, dynamic>;
        final type = row['type'] as String;
        if (type == 'flash' || type == 'pro') {
          await imgHelper.deleteImageFile(noteJson['imagePath'] as String?);
        } else if (type == 'event') {
          await imgHelper.deleteImageFile(noteJson['attachmentPath'] as String?);
        }
      } catch (_) {}
    }
    await db.delete('trashed_notes', where: 'deleted_at < ?', whereArgs: [cutoff]);
  }

  Future<void> saveAllTrashedNotes(List<TrashedNote> notes) async {
    if (_webMode) { _wTrashed.clear(); _wTrashed.addAll(notes); return; }
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('trashed_notes');
      final batch = txn.batch();
      for (final note in notes) {
        batch.insert('trashed_notes', note.toDbMap());
      }
      await batch.commit(noResult: true);
    });
  }

  // ── Custom Folders ──

  Future<void> saveFolder(String name, FolderStyle style) async {
    if (_webMode) { _wFolders[name] = style; return; }
    final db = await database;
    final map = style.toDbMap(name);
    await db.insert('custom_folders', map, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<Map<String, FolderStyle>> getAllFolders() async {
    if (_webMode) return Map.of(_wFolders);
    final db = await database;
    final maps = await db.query('custom_folders');
    final result = <String, FolderStyle>{};
    for (final m in maps) {
      result[m['name'] as String] = FolderStyle.fromDbMap(m);
    }
    return result;
  }

  Future<void> deleteFolder(String name) async {
    if (_webMode) { _wFolders.remove(name); return; }
    final db = await database;
    await db.delete('custom_folders', where: 'name = ?', whereArgs: [name]);
  }

  Future<void> saveAllFolders(Map<String, FolderStyle> folders) async {
    if (_webMode) { _wFolders.clear(); _wFolders.addAll(folders); return; }
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('custom_folders');
      final batch = txn.batch();
      for (final entry in folders.entries) {
        batch.insert('custom_folders', entry.value.toDbMap(entry.key));
      }
      await batch.commit(noResult: true);
    });
  }

  // ── Settings (key-value) ──

  Future<void> saveSetting(String key, String value) async {
    if (_webMode) { _wSettings[key] = value; return; }
    final db = await database;
    await db.insert('settings', {'key': key, 'value': value}, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<String?> getSetting(String key) async {
    if (_webMode) return _wSettings[key];
    final db = await database;
    final maps = await db.query('settings', where: 'key = ?', whereArgs: [key]);
    if (maps.isEmpty) return null;
    return maps.first['value'] as String;
  }

  // ── Cache (key-value with timestamp) ──

  Future<void> saveCache(String key, String value) async {
    if (_webMode) { _wCache[key] = value; return; }
    final db = await database;
    await db.insert('cache', {
      'key': key, 'value': value, 'updated_at': DateTime.now().millisecondsSinceEpoch,
    }, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<String?> getCache(String key) async {
    if (_webMode) return _wCache[key];
    final db = await database;
    final maps = await db.query('cache', where: 'key = ?', whereArgs: [key]);
    if (maps.isEmpty) return null;
    return maps.first['value'] as String;
  }

  Future<void> deleteCache(String key) async {
    if (_webMode) { _wCache.remove(key); return; }
    final db = await database;
    await db.delete('cache', where: 'key = ?', whereArgs: [key]);
  }

  // ── Cycle Days ──

  Future<Set<String>> getCycleDays() async {
    if (_webMode) return Set.of(_wCycleDays);
    final db = await database;
    final maps = await db.query('cycle_days');
    return maps.map((m) => m['day_key'] as String).toSet();
  }

  Future<Map<String, String>> getCycleDaysWithIntensity() async {
    if (_webMode) return {for (final k in _wCycleDays) k: 'medium'};
    final db = await database;
    final maps = await db.query('cycle_days');
    return {for (final m in maps) m['day_key'] as String: (m['flow_intensity'] as String?) ?? 'medium'};
  }

  Future<void> addCycleDay(String dayKey, {String intensity = 'medium'}) async {
    if (_webMode) { _wCycleDays.add(dayKey); return; }
    final db = await database;
    await db.insert('cycle_days', {'day_key': dayKey, 'flow_intensity': intensity}, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<void> updateCycleDayIntensity(String dayKey, String intensity) async {
    if (_webMode) return;
    final db = await database;
    await db.update('cycle_days', {'flow_intensity': intensity}, where: 'day_key = ?', whereArgs: [dayKey]);
  }

  Future<void> removeCycleDay(String dayKey) async {
    if (_webMode) { _wCycleDays.remove(dayKey); return; }
    final db = await database;
    await db.delete('cycle_days', where: 'day_key = ?', whereArgs: [dayKey]);
  }

  Future<void> replaceAllCycleDays(List<Map<String, dynamic>> days) async {
    if (_webMode) { _wCycleDays.clear(); _wCycleDays.addAll(days.map((d) => d['day_key'] as String)); return; }
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('cycle_days');
      final batch = txn.batch();
      for (final d in days) {
        batch.insert('cycle_days', d);
      }
      await batch.commit(noResult: true);
    });
  }

  // ── Utility ──

  Future<void> replaceAllFlashNotes(List<FlashNote> notes) async {
    if (_webMode) { _wFlashNotes.clear(); _wFlashNotes.addAll(notes); return; }
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('flash_notes');
      final batch = txn.batch();
      for (final note in notes) {
        batch.insert('flash_notes', note.toDbMap());
      }
      await batch.commit(noResult: true);
    });
  }

  Future<void> replaceAllProNotes(List<ProNote> notes) async {
    if (_webMode) { _wProNotes.clear(); _wProNotes.addAll(notes); return; }
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('pro_notes');
      final batch = txn.batch();
      for (final note in notes) {
        batch.insert('pro_notes', note.toDbMap());
      }
      await batch.commit(noResult: true);
    });
  }

  Future<void> deleteAllData() async {
    if (_webMode) { _wProNotes.clear(); _wFlashNotes.clear(); _wEvents.clear(); _wProfile = null; _wTrashed.clear(); _wFolders.clear(); _wSettings.clear(); _wCache.clear(); _wCycleDays.clear(); return; }
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('pro_notes');
      await txn.delete('flash_notes');
      await txn.delete('calendar_events');
      await txn.delete('user_profile');
      await txn.delete('trashed_notes');
      await txn.delete('custom_folders');
      await txn.delete('settings');
      await txn.delete('cache');
      await txn.delete('cycle_days');
    });
  }
}

// ─── Image Storage Helper ──────────────────────────────────────────────────

class ImageStorageHelper {
  static final ImageStorageHelper _instance = ImageStorageHelper._internal();
  factory ImageStorageHelper() => _instance;
  ImageStorageHelper._internal();

  Directory? _imagesDir;

  Future<Directory> get imagesDir async {
    if (_imagesDir != null) return _imagesDir!;
    final appDir = await getApplicationDocumentsDirectory();
    _imagesDir = Directory(p.join(appDir.path, 'images'));
    if (!await _imagesDir!.exists()) {
      await _imagesDir!.create(recursive: true);
    }
    return _imagesDir!;
  }

  String generateFileName(String prefix) {
    final ts = DateTime.now().millisecondsSinceEpoch;
    final rand = math.Random().nextInt(9999).toString().padLeft(4, '0');
    return '${prefix}_${ts}_$rand.jpg';
  }

  Future<String> saveBase64ToFile(String base64Str, String fileName) async {
    final dir = await imagesDir;
    final filePath = p.join(dir.path, fileName);
    final bytes = base64Decode(base64Str);
    await File(filePath).writeAsBytes(bytes);
    return filePath;
  }

  Future<String> saveBytesToFile(Uint8List bytes, String fileName) async {
    final dir = await imagesDir;
    final filePath = p.join(dir.path, fileName);
    await File(filePath).writeAsBytes(bytes);
    return filePath;
  }

  Future<Uint8List?> loadImageBytes({String? filePath, String? base64Str}) async {
    if (filePath != null && filePath.isNotEmpty) {
      final file = File(filePath);
      if (await file.exists()) return await file.readAsBytes();
    }
    if (base64Str != null && base64Str.isNotEmpty) {
      try { return base64Decode(base64Str); } catch (_) {}
    }
    return null;
  }

  Future<void> deleteImageFile(String? filePath) async {
    if (filePath == null || filePath.isEmpty) return;
    try {
      final file = File(filePath);
      if (await file.exists()) await file.delete();
    } catch (_) {}
  }
}

class StoredImage extends StatelessWidget {
  final String? imagePath;
  final String? imageBase64;
  final double? width;
  final double? height;
  final BoxFit fit;
  final BorderRadius? borderRadius;

  const StoredImage({
    super.key,
    this.imagePath,
    this.imageBase64,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
    this.borderRadius,
  });

  @override
  Widget build(BuildContext context) {
    Widget image;
    if (imagePath != null && imagePath!.isNotEmpty) {
      image = Image.file(
        File(imagePath!),
        width: width,
        height: height,
        fit: fit,
        errorBuilder: (_, __, ___) => _placeholder(context),
      );
    } else if (imageBase64 != null && imageBase64!.isNotEmpty) {
      try {
        image = Image.memory(
          base64Decode(imageBase64!),
          width: width,
          height: height,
          fit: fit,
          errorBuilder: (_, __, ___) => _placeholder(context),
        );
      } catch (_) {
        image = _placeholder(context);
      }
    } else {
      image = _placeholder(context);
    }
    if (borderRadius != null) {
      return ClipRRect(borderRadius: borderRadius!, child: image);
    }
    return image;
  }

  Widget _placeholder(BuildContext context) {
    return Container(
      width: width,
      height: height ?? 100,
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: borderRadius ?? BorderRadius.circular(12),
      ),
      child: Center(child: Icon(Icons.broken_image, color: Theme.of(context).colorScheme.onSurfaceVariant)),
    );
  }
}

Future<void> _logError(Object error, StackTrace? stack) async {
  if (kDebugMode) {
    debugPrint('ERROR: $error');
    debugPrint('STACK: $stack');
  }
  try {
    final dir = await getApplicationDocumentsDirectory();
    final file = File('${dir.path}/crash_log.txt');
    final timestamp = DateTime.now().toIso8601String();
    final entry = '[$timestamp] $error\n${stack ?? ''}\n---\n';
    await file.writeAsString(entry, mode: FileMode.append);
    // Keep file size manageable - truncate if > 1MB
    if (await file.length() > 1024 * 1024) {
      final content = await file.readAsString();
      await file.writeAsString(content.substring(content.length ~/ 2));
    }
  } catch (_) {}
}

void main() {
  runZonedGuarded(() async {
    WidgetsFlutterBinding.ensureInitialized();

    FlutterError.onError = (FlutterErrorDetails details) {
      FlutterError.presentError(details);
      _logError(details.exception, details.stack);
    };

    ui.PlatformDispatcher.instance.onError = (error, stack) {
      _logError(error, stack);
      return true;
    };

    if (kIsWeb) {
      // Web: use in-memory storage, re-create demo data each session
      DatabaseHelper.enableWebMode();
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool('demo_data_loaded', false);
    } else {
      // Mobile/Desktop: use SQLite
      await DatabaseHelper().database;
      await _migrateSharedPrefsToSqlite();
    }
    // await _initDemoDataIfNeeded(); // Demo data disabled
    // One-time DB wipe to start clean
    final prefs = await SharedPreferences.getInstance();
    if (prefs.getBool('db_wiped_v1') != true) {
      final db = await DatabaseHelper().database;
      await db.delete('pro_notes');
      await db.delete('flash_notes');
      await db.delete('calendar_events');
      await db.delete('trashed_notes');
      await db.delete('user_profile');
      await prefs.setBool('db_wiped_v1', true);
    }
    if (!kIsWeb) {
      await _migrateBase64ToFiles();
    }
    await NotificationService.init();
    await initializeDateFormatting();
    runApp(const EthosNoteApp());
  }, (error, stack) {
    _logError(error, stack);
  });
}

Future<void> _migrateBase64ToFiles() async {
  final db = await DatabaseHelper().database;
  // Check if already migrated
  final rows = await db.query('settings', where: 'key = ?', whereArgs: ['images_migrated_v8']);
  if (rows.isNotEmpty && rows.first['value'] == 'true') return;

  final imgHelper = ImageStorageHelper();

  // Migrate flash_notes
  final flashRows = await db.rawQuery(
    "SELECT id FROM flash_notes WHERE image_base64 IS NOT NULL AND image_base64 != '' AND (image_path IS NULL OR image_path = '')"
  );
  for (final row in flashRows) {
    final id = row['id'] as int;
    try {
      final imgData = await db.query('flash_notes', columns: ['image_base64'], where: 'id = ?', whereArgs: [id]);
      if (imgData.isEmpty) continue;
      final b64 = imgData.first['image_base64'] as String?;
      if (b64 == null || b64.isEmpty) continue;
      final fileName = imgHelper.generateFileName('flash');
      final filePath = await imgHelper.saveBase64ToFile(b64, fileName);
      await db.update('flash_notes', {'image_path': filePath, 'image_base64': null}, where: 'id = ?', whereArgs: [id]);
    } catch (e) {
      if (kDebugMode) debugPrint('Migration error flash $id: $e');
    }
  }

  // Migrate pro_notes
  final proRows = await db.rawQuery(
    "SELECT id FROM pro_notes WHERE image_base64 IS NOT NULL AND image_base64 != '' AND (image_path IS NULL OR image_path = '')"
  );
  for (final row in proRows) {
    final id = row['id'] as int;
    try {
      final imgData = await db.query('pro_notes', columns: ['image_base64'], where: 'id = ?', whereArgs: [id]);
      if (imgData.isEmpty) continue;
      final b64 = imgData.first['image_base64'] as String?;
      if (b64 == null || b64.isEmpty) continue;
      final fileName = imgHelper.generateFileName('pro');
      final filePath = await imgHelper.saveBase64ToFile(b64, fileName);
      await db.update('pro_notes', {'image_path': filePath, 'image_base64': null}, where: 'id = ?', whereArgs: [id]);
    } catch (e) {
      if (kDebugMode) debugPrint('Migration error pro $id: $e');
    }
  }

  // Migrate calendar_events attachment_base64
  final eventRows = await db.rawQuery(
    "SELECT id FROM calendar_events WHERE attachment_base64 IS NOT NULL AND attachment_base64 != '' AND (attachment_path IS NULL OR attachment_path = '')"
  );
  for (final row in eventRows) {
    final id = row['id'] as int;
    try {
      final imgData = await db.query('calendar_events', columns: ['attachment_base64'], where: 'id = ?', whereArgs: [id]);
      if (imgData.isEmpty) continue;
      final b64 = imgData.first['attachment_base64'] as String?;
      if (b64 == null || b64.isEmpty) continue;
      final fileName = imgHelper.generateFileName('event');
      final filePath = await imgHelper.saveBase64ToFile(b64, fileName);
      await db.update('calendar_events', {'attachment_path': filePath, 'attachment_base64': null}, where: 'id = ?', whereArgs: [id]);
    } catch (e) {
      if (kDebugMode) debugPrint('Migration error event $id: $e');
    }
  }

  // Mark as migrated
  await db.insert('settings', {'key': 'images_migrated_v8', 'value': 'true'}, conflictAlgorithm: ConflictAlgorithm.replace);
}

Future<void> _migrateSharedPrefsToSqlite() async {
  final prefs = await SharedPreferences.getInstance();
  if (prefs.getBool('db_migration_complete') == true) return;
  if (prefs.getBool('demo_data_loaded') != true) {
    // No data to migrate — fresh install will use DB directly
    await prefs.setBool('db_migration_complete', true);
    return;
  }

  final db = DatabaseHelper();

  try {
    // ── Profile ──
    final profileJson = prefs.getString('user_profile');
    if (profileJson != null) {
      await db.saveProfile(UserProfile.fromJson(json.decode(profileJson)));
    }

    // ── Pro Notes ──
    final proNotesJson = prefs.getStringList('pro_notes') ?? [];
    for (final s in proNotesJson) {
      try { await db.insertProNote(ProNote.fromJson(json.decode(s))); } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
    }

    // ── Flash Notes ──
    final flashNotesJson = prefs.getStringList('flash_notes_v2') ?? [];
    for (final s in flashNotesJson) {
      try { await db.insertFlashNote(FlashNote.fromJson(json.decode(s))); } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
    }

    // ── Calendar Events ──
    final eventsJsonStr = prefs.getString('calendar_events_full');
    if (eventsJsonStr != null) {
      final Map<String, dynamic> decoded = json.decode(eventsJsonStr);
      for (final entry in decoded.entries) {
        for (final e in (entry.value as List)) {
          try { await db.insertEvent(CalendarEventFull.fromJson(e)); } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
        }
      }
    }

    // ── Trashed Notes ──
    final trashedJson = prefs.getStringList('trashed_notes') ?? [];
    for (final s in trashedJson) {
      try { await db.insertTrashedNote(TrashedNote.fromJson(json.decode(s))); } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
    }

    // ── Custom Folders ──
    final foldersJsonStr = prefs.getString('custom_folders');
    if (foldersJsonStr != null) {
      final Map<String, dynamic> decoded = json.decode(foldersJsonStr);
      for (final entry in decoded.entries) {
        try { await db.saveFolder(entry.key, FolderStyle.fromJson(entry.value)); } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
      }
    }

    // ── Settings ──
    for (final key in ['calendar_settings', 'note_pro_settings', 'flash_notes_settings']) {
      final val = prefs.getString(key);
      if (val != null) await db.saveSetting(key, val);
    }

    // ── Cache ──
    for (final key in ['horoscope_cache', 'weather_cache', 'health_snapshot']) {
      final val = prefs.getString(key);
      if (val != null) await db.saveCache(key, val);
    }

    // ── Cycle Days ──
    final cycleDays = prefs.getStringList('cycle_tracking_private') ?? [];
    if (cycleDays.isNotEmpty) {
      await db.replaceAllCycleDays(cycleDays.map((d) => {'day_key': d, 'flow_intensity': 'medium'}).toList());
    }
  } finally {
    await prefs.setBool('db_migration_complete', true);
  }
}

class EthosNoteApp extends StatefulWidget {
  const EthosNoteApp({super.key});

  @override
  State<EthosNoteApp> createState() => _EthosNoteAppState();
}

class _EthosNoteAppState extends State<EthosNoteApp> {
  // 'light', 'dark', 'ethos'
  String _themeMode = 'ethos';
  bool _onboardingComplete = true; // default true to avoid flash
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadTheme();
    _loadLocale();
    _loadOnboarding();
  }

  Future<void> _loadOnboarding() async {
    final prefs = await SharedPreferences.getInstance();
    final complete = prefs.getBool('onboarding_complete') ?? false;
    // Try silent sign-in at boot so GoogleCalendarService._currentUser is set
    await GoogleCalendarService.trySilentSignIn();
    if (mounted) {
      setState(() {
        _onboardingComplete = complete;
        _isLoading = false;
      });
    }
  }

  void _completeOnboarding() {
    SharedPreferences.getInstance().then((prefs) {
      prefs.setBool('onboarding_complete', true);
    });
    setState(() => _onboardingComplete = true);
  }

  Future<void> _loadTheme() async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() {
      _themeMode = prefs.getString('theme_mode') ?? 'ethos';
    });
  }

  Future<void> _loadLocale() async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() {
      _appLocale = prefs.getString('app_locale') ?? 'it';
    });
  }

  void setThemeMode(String mode) {
    setState(() => _themeMode = mode);
    SharedPreferences.getInstance().then((prefs) {
      prefs.setString('theme_mode', mode);
    });
    _syncThemeToWidget(mode);
  }

  void setLocale(String locale) {
    setState(() => _appLocale = locale);
    SharedPreferences.getInstance().then((prefs) {
      prefs.setString('app_locale', locale);
    });
  }

  // ── Original theme (Indigo) ──
  ThemeData _buildTheme(Brightness brightness) {
    final isDark = brightness == Brightness.dark;
    final colorScheme = ColorScheme.fromSeed(
      seedColor: const Color(0xFF6366F1),
      brightness: brightness,
    );

    return ThemeData(
      colorScheme: colorScheme,
      useMaterial3: true,
      scaffoldBackgroundColor: colorScheme.surface,
      appBarTheme: AppBarTheme(
        elevation: 0,
        scrolledUnderElevation: 2,
        centerTitle: true,
        backgroundColor: Colors.transparent,
        foregroundColor: colorScheme.onSurface,
        titleTextStyle: TextStyle(
          fontSize: 22,
          fontWeight: FontWeight.bold,
          color: colorScheme.onSurface,
        ),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        color: colorScheme.surfaceContainerLowest,
        clipBehavior: Clip.antiAlias,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 0,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
          textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
          side: BorderSide(color: colorScheme.outline),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: isDark
            ? colorScheme.surfaceContainerHighest
            : colorScheme.surfaceContainerLowest,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.outline),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.outlineVariant),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.primary, width: 2),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0,
        height: 65,
        indicatorShape: const StadiumBorder(),
        labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: colorScheme.surface,
        surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(24),
        ),
      ),
      snackBarTheme: SnackBarThemeData(
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      dividerTheme: DividerThemeData(
        color: colorScheme.outlineVariant.withValues(alpha: 0.5),
        thickness: 1,
      ),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
    );
  }

  // ── Ethos Bordeaux palette (dark-mode only) ──
  static const _bordeaux = Color(0xFF800020);
  static const _bordeauxLight = Color(0xFFA3274F);
  static const _anthracite = Color(0xFF1A1A1E);

  ThemeData _buildEthosTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _bordeaux,
      brightness: Brightness.dark,
      primary: _bordeauxLight,
      onPrimary: Colors.white,
    );

    return ThemeData(
      colorScheme: colorScheme,
      useMaterial3: true,
      scaffoldBackgroundColor: _anthracite,
      appBarTheme: AppBarTheme(
        elevation: 0,
        scrolledUnderElevation: 2,
        centerTitle: true,
        backgroundColor: Colors.transparent,
        foregroundColor: colorScheme.onSurface,
        titleTextStyle: TextStyle(
          fontSize: 22,
          fontWeight: FontWeight.bold,
          color: colorScheme.onSurface,
        ),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        color: const Color(0xFF232327),
        clipBehavior: Clip.antiAlias,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 0,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
          textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(
          backgroundColor: _bordeauxLight,
          foregroundColor: Colors.white,
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
          side: BorderSide(color: colorScheme.outline),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: colorScheme.surfaceContainerHighest,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.outline),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: colorScheme.outlineVariant),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: _bordeauxLight, width: 2),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0,
        height: 65,
        indicatorColor: _bordeauxLight.withValues(alpha: 0.15),
        indicatorShape: const StadiumBorder(),
        labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _anthracite,
        surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(24),
        ),
      ),
      snackBarTheme: SnackBarThemeData(
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      dividerTheme: DividerThemeData(
        color: colorScheme.outlineVariant.withValues(alpha: 0.5),
        thickness: 1,
      ),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2,
        backgroundColor: _bordeauxLight,
        foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) return _bordeauxLight;
          return null;
        }),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Ephemera palette (light vintage diary) ──
  static const _ephCream = Color(0xFFF4EBD0);
  static const _ephCardBg = Color(0xFFFAF5E8);
  static const _ephSepia = Color(0xFF3E2723);
  static const _ephLeather = Color(0xFF795548);
  static const _ephBorder = Color(0xFFD7CFC0);

  ThemeData _buildEphemeraTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _ephLeather,
      brightness: Brightness.light,
      primary: _ephLeather,
      onPrimary: Colors.white,
      surface: _ephCream,
      onSurface: _ephSepia,
    );

    return ThemeData(
      colorScheme: colorScheme,
      useMaterial3: true,
      scaffoldBackgroundColor: _ephCream,
      textTheme: GoogleFonts.loraTextTheme(ThemeData.light().textTheme).apply(
        bodyColor: _ephSepia,
        displayColor: _ephSepia,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0,
        scrolledUnderElevation: 2,
        centerTitle: true,
        backgroundColor: Colors.transparent,
        foregroundColor: _ephSepia,
        titleTextStyle: GoogleFonts.lora(
          fontSize: 22,
          fontWeight: FontWeight.bold,
          color: _ephSepia,
        ),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: const BorderSide(color: _ephBorder, width: 0.5),
        ),
        color: _ephCardBg,
        clipBehavior: Clip.antiAlias,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 0,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
          textStyle: GoogleFonts.lora(fontSize: 16, fontWeight: FontWeight.w600),
        ),
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(
          backgroundColor: _ephLeather,
          foregroundColor: Colors.white,
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
          side: const BorderSide(color: _ephBorder),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: _ephCream,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _ephBorder),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _ephBorder),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _ephLeather, width: 2),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0,
        height: 65,
        indicatorColor: _ephLeather.withValues(alpha: 0.15),
        indicatorShape: const StadiumBorder(),
        labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _ephCream,
        surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(24),
        ),
      ),
      snackBarTheme: SnackBarThemeData(
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      dividerTheme: DividerThemeData(
        color: _ephBorder.withValues(alpha: 0.5),
        thickness: 1,
      ),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2,
        backgroundColor: _ephLeather,
        foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) return _ephLeather;
          return null;
        }),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Nordic Zen palette (glassmorphism ice) ──
  static const _nzIce = Color(0xFFF0F4F8);
  static const _nzCard = Color(0xE6FFFFFF);
  static const _nzText = Color(0xFF2D3748);
  static const _nzAccent = Color(0xFF78909C);
  static const _nzBorder = Color(0xFFCFD8DC);

  ThemeData _buildNordicZenTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _nzAccent,
      brightness: Brightness.light,
      primary: _nzAccent,
      onPrimary: Colors.white,
      surface: _nzIce,
      onSurface: _nzText,
    );
    return ThemeData(
      colorScheme: colorScheme,
      useMaterial3: true,
      scaffoldBackgroundColor: _nzIce,
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 0, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _nzText,
        titleTextStyle: const TextStyle(fontSize: 22, fontWeight: FontWeight.w300, color: _nzText),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(24),
          side: const BorderSide(color: _nzBorder, width: 0.5),
        ),
        color: _nzCard, clipBehavior: Clip.antiAlias,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(elevation: 0, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14)),
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _nzAccent, foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20))),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          side: const BorderSide(color: _nzBorder)),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _nzCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(20), borderSide: const BorderSide(color: _nzBorder)),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(20), borderSide: const BorderSide(color: _nzBorder)),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(20), borderSide: const BorderSide(color: _nzAccent, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _nzAccent.withValues(alpha: 0.12),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _nzIce, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(28))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20))),
      dividerTheme: DividerThemeData(color: _nzBorder.withValues(alpha: 0.4), thickness: 0.5),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 0, backgroundColor: _nzAccent, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _nzAccent : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Green Salvia palette (botanical calm) ──
  static const _gsSalvia = Color(0xFFE2E8E4);
  static const _gsCard = Color(0xFFEDF2EE);
  static const _gsForest = Color(0xFF2A3B32);
  static const _gsAccent = Color(0xFF6B8F71);
  static const _gsBorder = Color(0xFFC5D1C8);

  ThemeData _buildGreenSalviaTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _gsAccent,
      brightness: Brightness.light,
      primary: _gsAccent,
      onPrimary: Colors.white,
      surface: _gsSalvia,
      onSurface: _gsForest,
    );
    return ThemeData(
      colorScheme: colorScheme,
      useMaterial3: true,
      scaffoldBackgroundColor: _gsSalvia,
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _gsForest,
        titleTextStyle: TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: _gsForest),
      ),
      cardTheme: CardThemeData(
        elevation: 1,
        shadowColor: _gsAccent.withValues(alpha: 0.25),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        color: _gsCard, clipBehavior: Clip.antiAlias,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(elevation: 0, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14)),
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _gsAccent, foregroundColor: Colors.white),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          side: const BorderSide(color: _gsBorder)),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _gsSalvia,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _gsBorder)),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _gsBorder)),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _gsAccent, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _gsAccent.withValues(alpha: 0.15),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _gsSalvia, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _gsBorder.withValues(alpha: 0.5), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2, backgroundColor: _gsAccent, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _gsAccent : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Sakura palette (sophisticated blush) ──
  static const _skBlush = Color(0xFFF7E7E6);
  static const _skCard = Color(0xFFFFF0EF);
  static const _skText = Color(0xFF2D3748);
  static const _skAccent = Color(0xFFB5838D);
  static const _skBorder = Color(0xFFE8CCCE);

  ThemeData _buildSakuraTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _skAccent,
      brightness: Brightness.light,
      primary: _skAccent,
      onPrimary: Colors.white,
      surface: _skBlush,
      onSurface: _skText,
    );
    return ThemeData(
      colorScheme: colorScheme,
      useMaterial3: true,
      scaffoldBackgroundColor: _skBlush,
      textTheme: GoogleFonts.libreBaskervilleTextTheme(ThemeData.light().textTheme).apply(
        bodyColor: _skText, displayColor: _skText,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _skText,
        titleTextStyle: GoogleFonts.libreBaskerville(fontSize: 22, fontWeight: FontWeight.bold, color: _skText),
      ),
      cardTheme: CardThemeData(
        elevation: 1,
        shadowColor: _skAccent.withValues(alpha: 0.15),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        color: _skCard, clipBehavior: Clip.antiAlias,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(elevation: 0, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
          textStyle: GoogleFonts.libreBaskerville(fontSize: 16, fontWeight: FontWeight.w600)),
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _skAccent, foregroundColor: Colors.white),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          side: const BorderSide(color: _skBorder)),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _skBlush,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _skBorder)),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _skBorder)),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _skAccent, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _skAccent.withValues(alpha: 0.15),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _skBlush, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _skBorder.withValues(alpha: 0.5), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2, backgroundColor: _skAccent, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _skAccent : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Spadaccino Errante (Zoro) palette — DARK steel dojo ──
  static const _zoMoss = Color(0xFF1B4D3E);
  static const _zoCard = Color(0xFF1E5A47);
  static const _zoText = Color(0xFFF0F0F0);
  static const _zoAccent = Color(0xFF1B4D3E);
  static const _zoBorder = Color(0xFF2E7D5B);

  ThemeData _buildSpadaccinoTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _zoAccent, brightness: Brightness.dark,
      primary: _zoAccent, onPrimary: _zoText,
      surface: const Color(0xFF0D2818), onSurface: _zoText,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: const Color(0xFF0D2818),
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _zoText,
        titleTextStyle: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: _zoText),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: BeveledRectangleBorder(
          borderRadius: BorderRadius.circular(8),
          side: BorderSide(color: _zoBorder.withValues(alpha: 0.4)),
        ),
        color: _zoCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _zoBorder, foregroundColor: _zoText),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          side: BorderSide(color: _zoBorder.withValues(alpha: 0.5)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _zoCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _zoBorder.withValues(alpha: 0.4))),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _zoBorder.withValues(alpha: 0.4))),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _zoBorder, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _zoBorder.withValues(alpha: 0.25),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: const Color(0xFF0D2818), surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _zoBorder.withValues(alpha: 0.3), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2, backgroundColor: _zoBorder, foregroundColor: _zoText,
        shape: BeveledRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _zoBorder : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Sogno del Re (Luffy) palette — LIGHT solar energy ──
  static const _luPaglia = Color(0xFFFFF9C4);
  static const _luCard = Color(0xFFFFFDE7);
  static const _luBlu = Color(0xFF1565C0);
  static const _luRosso = Color(0xFFD32F2F);
  static const _luBorder = Color(0xFFFFCC80);

  ThemeData _buildSognoReTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _luRosso, brightness: Brightness.light,
      primary: _luRosso, onPrimary: Colors.white,
      surface: _luPaglia, onSurface: _luBlu,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _luPaglia,
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _luBlu,
        titleTextStyle: TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: _luBlu),
      ),
      cardTheme: CardThemeData(
        elevation: 1, shadowColor: _luRosso.withValues(alpha: 0.15),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        color: _luCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _luRosso, foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20))),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          side: BorderSide(color: _luRosso.withValues(alpha: 0.5)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _luCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(16), borderSide: BorderSide(color: _luBorder)),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(16), borderSide: BorderSide(color: _luBorder)),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(16), borderSide: const BorderSide(color: _luRosso, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _luRosso.withValues(alpha: 0.15),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _luPaglia, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(28))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16))),
      dividerTheme: DividerThemeData(color: _luBorder.withValues(alpha: 0.5), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 3, backgroundColor: _luRosso, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _luRosso : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Mappa del Tesoro (Nami) palette — LIGHT nautical gold ──
  static const _nmPerla = Color(0xFFFFE0B2);
  static const _nmCard = Color(0xFFFFF3E0);
  static const _nmBlu = Color(0xFF0D47A1);
  static const _nmOro = Color(0xFFE6A800);
  static const _nmBorder = Color(0xFFFFCC80);

  ThemeData _buildMappaTesoroTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _nmOro, brightness: Brightness.light,
      primary: _nmOro, onPrimary: Colors.white,
      surface: _nmPerla, onSurface: _nmBlu,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _nmPerla,
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _nmBlu,
        titleTextStyle: TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: _nmBlu),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: _nmOro.withValues(alpha: 0.3), width: 1)),
        color: _nmCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _nmOro, foregroundColor: Colors.white),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          side: BorderSide(color: _nmOro.withValues(alpha: 0.5)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _nmCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _nmBorder)),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _nmBorder)),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _nmOro, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _nmOro.withValues(alpha: 0.2),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _nmPerla, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _nmBorder.withValues(alpha: 0.5), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2, backgroundColor: _nmOro, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _nmOro : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Fulmine Vendicatore (Sasuke) palette — DARK electric night ──
  static const _saNotteScaffold = Color(0xFF0D0D1A);
  static const _saNotte = Color(0xFF1A1A2E);
  static const _saCard = Color(0xFF16213E);
  static const _saText = Color(0xFFE8EAF6);
  static const _saElectric = Color(0xFF7C4DFF);
  static const _saBorder = Color(0xFF3949AB);

  ThemeData _buildFulmineTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _saElectric, brightness: Brightness.dark,
      primary: _saElectric, onPrimary: Colors.white,
      surface: _saNotte, onSurface: _saText,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _saNotteScaffold,
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _saText,
        titleTextStyle: GoogleFonts.rajdhani(fontSize: 24, fontWeight: FontWeight.bold, color: _saText),
      ),
      cardTheme: CardThemeData(
        elevation: 4,
        shadowColor: _saElectric.withValues(alpha: 0.3),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12),
          side: BorderSide(color: _saElectric.withValues(alpha: 0.2))),
        color: _saCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _saElectric, foregroundColor: Colors.white),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          side: BorderSide(color: _saElectric.withValues(alpha: 0.5)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _saCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _saBorder.withValues(alpha: 0.5))),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _saBorder.withValues(alpha: 0.5))),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _saElectric, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _saElectric.withValues(alpha: 0.2),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _saNotteScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _saBorder.withValues(alpha: 0.3), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 4, backgroundColor: _saElectric, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _saElectric : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Eremita Volpe (Naruto) palette — DARK fire & determination ──
  static const _naScaffold = Color(0xFF0A0A0A);
  static const _naCard = Color(0xFF1A1400);
  static const _naText = Color(0xFFFAFAFA);
  static const _naOrange = Color(0xFFE65100);
  static const _naTurquoise = Color(0xFF00BCD4);
  static const _naBorder = Color(0xFF5D4037);

  ThemeData _buildEremitaTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _naOrange, brightness: Brightness.dark,
      primary: _naOrange, onPrimary: Colors.white,
      surface: const Color(0xFF121212), onSurface: _naText,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _naScaffold,
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _naText,
        titleTextStyle: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: _naText),
      ),
      cardTheme: CardThemeData(
        elevation: 2, shadowColor: _naOrange.withValues(alpha: 0.2),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        color: _naCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _naTurquoise, foregroundColor: Colors.white),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          side: BorderSide(color: _naOrange.withValues(alpha: 0.5)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _naCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _naBorder.withValues(alpha: 0.5))),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _naBorder.withValues(alpha: 0.5))),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _naOrange, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _naOrange.withValues(alpha: 0.2),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _naScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _naBorder.withValues(alpha: 0.3), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2, backgroundColor: _naTurquoise, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _naOrange : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Saggio dei Rospi (Jiraiya) palette — DARK ancient scroll ──
  static const _jrScaffold = Color(0xFF2A0E0E);
  static const _jrCard = Color(0xFF3D1515);
  static const _jrParchment = Color(0xFFF5E6C8);
  static const _jrGranata = Color(0xFF691212);
  static const _jrOlive = Color(0xFF6B8E23);
  static const _jrBorder = Color(0xFF8B4513);

  ThemeData _buildSaggioTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _jrGranata, brightness: Brightness.dark,
      primary: _jrGranata, onPrimary: _jrParchment,
      surface: const Color(0xFF331111), onSurface: _jrParchment,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _jrScaffold,
      textTheme: GoogleFonts.caveatTextTheme(ThemeData.dark().textTheme).apply(
        bodyColor: _jrParchment, displayColor: _jrParchment,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _jrParchment,
        titleTextStyle: GoogleFonts.caveat(fontSize: 26, fontWeight: FontWeight.bold, color: _jrParchment),
      ),
      cardTheme: CardThemeData(
        elevation: 1, shadowColor: _jrGranata.withValues(alpha: 0.3),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12),
          side: BorderSide(color: _jrBorder.withValues(alpha: 0.4))),
        color: _jrCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _jrOlive, foregroundColor: _jrParchment),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          side: BorderSide(color: _jrBorder.withValues(alpha: 0.5)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _jrCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _jrBorder.withValues(alpha: 0.4))),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _jrBorder.withValues(alpha: 0.4))),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _jrOlive, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _jrGranata.withValues(alpha: 0.3),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _jrScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _jrBorder.withValues(alpha: 0.3), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2, backgroundColor: _jrOlive, foregroundColor: _jrParchment,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _jrOlive : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Cabina del Tempo (Dr. Who) palette — DARK TARDIS blue ──
  static const _dwScaffold = Color(0xFF001F3F);
  static const _dwCard = Color(0xFF002B54);
  static const _dwText = Color(0xFFFFF8E1);
  static const _dwTardis = Color(0xFF003B6F);
  static const _dwSilver = Color(0xFFB0BEC5);
  static const _dwBorder = Color(0xFF1565C0);

  ThemeData _buildCabinaTempoTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _dwTardis, brightness: Brightness.dark,
      primary: _dwTardis, onPrimary: _dwText,
      surface: const Color(0xFF00264D), onSurface: _dwText,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _dwScaffold,
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _dwText,
        titleTextStyle: GoogleFonts.shareTechMono(fontSize: 20, fontWeight: FontWeight.bold, color: _dwText),
      ),
      cardTheme: CardThemeData(
        elevation: 2, shadowColor: _dwBorder.withValues(alpha: 0.3),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8),
          side: BorderSide(color: _dwBorder.withValues(alpha: 0.3))),
        color: _dwCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _dwBorder, foregroundColor: _dwText),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          side: BorderSide(color: _dwSilver.withValues(alpha: 0.5)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _dwCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: _dwBorder.withValues(alpha: 0.4))),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: _dwBorder.withValues(alpha: 0.4))),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: const BorderSide(color: _dwBorder, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _dwBorder.withValues(alpha: 0.25),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _dwScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _dwBorder.withValues(alpha: 0.3), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 2, backgroundColor: _dwBorder, foregroundColor: _dwText,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _dwBorder : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Sottosopra (Stranger Things) palette — DARK 80s horror ──
  static const _stScaffold = Color(0xFF050510);
  static const _stCard = Color(0xFF0A0A1A);
  static const _stNeon = Color(0xFFFF1744);
  static const _stBlood = Color(0xFFB71C1C);
  static const _stBorder = Color(0xFF880E4F);

  ThemeData _buildSottosopaTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _stBlood, brightness: Brightness.dark,
      primary: _stBlood, onPrimary: Colors.white,
      surface: const Color(0xFF0A0A14), onSurface: _stNeon,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _stScaffold,
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _stNeon,
        titleTextStyle: GoogleFonts.russoOne(fontSize: 22, color: _stNeon),
      ),
      cardTheme: CardThemeData(
        elevation: 4, shadowColor: _stNeon.withValues(alpha: 0.15),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8),
          side: BorderSide(color: _stBlood.withValues(alpha: 0.3))),
        color: _stCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _stBlood, foregroundColor: Colors.white),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          side: BorderSide(color: _stNeon.withValues(alpha: 0.4)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _stCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: _stBorder.withValues(alpha: 0.4))),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: _stBorder.withValues(alpha: 0.4))),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: const BorderSide(color: _stNeon, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _stBlood.withValues(alpha: 0.3),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _stScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _stBorder.withValues(alpha: 0.3), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 4, backgroundColor: _stBlood, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _stBlood : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Rifugio Atomico (Fallout) palette — DARK terminal green ──
  static const _faScaffold = Color(0xFF1A1A1A);
  static const _faCard = Color(0xFF222222);
  static const _faGreen = Color(0xFF32CD32);
  static const _faYellow = Color(0xFFFFEB3B);
  static const _faVault = Color(0xFF005FB8);
  static const _faBorder = Color(0xFF424242);

  ThemeData _buildRifugioTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _faGreen, brightness: Brightness.dark,
      primary: _faGreen, onPrimary: Colors.black,
      surface: const Color(0xFF1E1E1E), onSurface: _faGreen,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _faScaffold,
      textTheme: GoogleFonts.shareTechMonoTextTheme(ThemeData.dark().textTheme).apply(
        bodyColor: _faGreen, displayColor: _faGreen,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _faGreen,
        titleTextStyle: GoogleFonts.shareTechMono(fontSize: 20, fontWeight: FontWeight.bold, color: _faGreen),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4),
          side: BorderSide(color: _faGreen.withValues(alpha: 0.3))),
        color: _faCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _faVault, foregroundColor: Colors.white),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
          side: BorderSide(color: _faGreen.withValues(alpha: 0.4)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _faCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(4), borderSide: BorderSide(color: _faBorder)),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(4), borderSide: BorderSide(color: _faBorder)),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(4), borderSide: const BorderSide(color: _faGreen, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _faGreen.withValues(alpha: 0.15),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _faScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4))),
      dividerTheme: DividerThemeData(color: _faBorder.withValues(alpha: 0.5), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 0, backgroundColor: _faVault, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _faGreen : null),
        checkColor: const WidgetStatePropertyAll(Colors.black),
      ),
    );
  }

  // ── Yellow Note Theme (Analogic Legacy) ──
  static const _ynYellow = Color(0xFFFEF9C3);
  static const _ynCard = Color(0xFFFFFDE7);
  static const _ynBlue = Color(0xFF1E3A8A);
  static const _ynRed = Color(0xFFEF4444);
  static const _ynBorder = Color(0xFFE5D99B);

  ThemeData _buildYellowNoteTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _ynBlue, brightness: Brightness.light,
      primary: _ynBlue, onPrimary: Colors.white,
      surface: _ynYellow, onSurface: const Color(0xFF1A1A1A),
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _ynYellow,
      textTheme: GoogleFonts.courierPrimeTextTheme(ThemeData.light().textTheme).apply(
        bodyColor: const Color(0xFF1A1A1A), displayColor: _ynBlue,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _ynBlue,
        titleTextStyle: GoogleFonts.courierPrime(fontSize: 20, fontWeight: FontWeight.bold, color: _ynBlue),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4),
          side: const BorderSide(color: _ynBorder)),
        color: _ynCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _ynBlue, foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          side: BorderSide(color: _ynBlue.withValues(alpha: 0.4)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _ynCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: const BorderSide(color: _ynBorder)),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: const BorderSide(color: _ynBorder)),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: const BorderSide(color: _ynBlue, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _ynBlue.withValues(alpha: 0.12),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _ynYellow, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))),
      dividerTheme: DividerThemeData(color: _ynBorder.withValues(alpha: 0.5), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 0, backgroundColor: _ynRed, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _ynBlue : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Like a Block Note Theme (paper & sticky aesthetic) ──
  static const _bnPrimary = Color(0xFFE6A100);
  static const _bnScaffold = Color(0xFFFFF8E1);
  static const _bnCard = Color(0xFFFFF176);
  static const _bnText = Color(0xFF37474F);
  static const _bnRed = Color(0xFFE53935);
  static const _bnBorder = Color(0xFFE0C97A);

  ThemeData _buildBlockNoteTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _bnPrimary, brightness: Brightness.light,
      primary: _bnPrimary, onPrimary: _bnText,
      surface: _bnScaffold, onSurface: _bnText,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _bnScaffold,
      textTheme: GoogleFonts.patrickHandTextTheme(ThemeData.light().textTheme).apply(
        bodyColor: _bnText, displayColor: _bnText,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _bnText,
        titleTextStyle: GoogleFonts.patrickHand(fontSize: 22, fontWeight: FontWeight.bold, color: _bnText),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: const BorderRadius.only(
            topLeft: Radius.circular(2), topRight: Radius.circular(4),
            bottomLeft: Radius.circular(3), bottomRight: Radius.circular(1),
          ),
          side: BorderSide(color: _bnBorder.withValues(alpha: 0.4)),
        ),
        color: _bnCard, clipBehavior: Clip.antiAlias,
        shadowColor: const Color(0x33795548),
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _bnRed, foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          side: BorderSide(color: _bnPrimary.withValues(alpha: 0.5)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: const Color(0xFFFFFDE7),
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: _bnBorder)),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: _bnBorder)),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: _bnPrimary, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _bnPrimary.withValues(alpha: 0.15),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _bnScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))),
      dividerTheme: DividerThemeData(color: _bnBorder.withValues(alpha: 0.5), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 4, backgroundColor: _bnCard, foregroundColor: _bnText,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _bnRed : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Deep Abyss Theme (OLED pure black, spectral minimalism) ──
  static const _daIndigo = Color(0xFF1A237E);
  static const _daViolet = Color(0xFF7C4DFF);
  static const _daDarkViolet = Color(0xFF4A148C);
  static const _daScaffold = Color(0xFF000000);
  static const _daCard = Color(0xFF0A0A0A);
  static const _daSurface = Color(0xFF060606);
  static const _daText = Color(0xFFC8C8C8);

  ThemeData _buildDeepAbyssTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _daIndigo, brightness: Brightness.dark,
      primary: _daIndigo, onPrimary: Colors.white,
      surface: _daSurface, onSurface: _daText,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _daScaffold,
      textTheme: ThemeData.dark().textTheme.apply(
        bodyColor: _daText, displayColor: _daText,
      ),
      appBarTheme: const AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _daText,
        titleTextStyle: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: _daText),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: Colors.white.withValues(alpha: 0.08))),
        color: _daCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _daIndigo, foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          side: BorderSide(color: _daIndigo.withValues(alpha: 0.4)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _daCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: Colors.white.withValues(alpha: 0.08))),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: Colors.white.withValues(alpha: 0.08))),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _daIndigo, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _daViolet.withValues(alpha: 0.12),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _daScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: Colors.white.withValues(alpha: 0.06), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 0, backgroundColor: _daDarkViolet, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _daIndigo : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Midnight Forest Theme (organic night green, relaxing) ──
  static const _mfGreen = Color(0xFF2E7D32);
  static const _mfBronze = Color(0xFF8D6E63);
  static const _mfScaffold = Color(0xFF050A05);
  static const _mfCard = Color(0xFF0C140C);
  static const _mfSurface = Color(0xFF0A120A);
  static const _mfText = Color(0xFFF5F0E1);
  static const _mfBorder = Color(0xFF1B3A1B);

  ThemeData _buildMidnightForestTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _mfGreen, brightness: Brightness.dark,
      primary: _mfGreen, onPrimary: Colors.white,
      surface: _mfSurface, onSurface: _mfText,
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _mfScaffold,
      textTheme: GoogleFonts.loraTextTheme(ThemeData.dark().textTheme).apply(
        bodyColor: _mfText, displayColor: _mfText,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _mfText,
        titleTextStyle: GoogleFonts.lora(fontSize: 20, fontWeight: FontWeight.bold, color: _mfText),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: _mfBorder.withValues(alpha: 0.4))),
        color: _mfCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _mfBronze, foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          side: BorderSide(color: _mfGreen.withValues(alpha: 0.4)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _mfCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _mfBorder.withValues(alpha: 0.4))),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: _mfBorder.withValues(alpha: 0.4))),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: _mfGreen, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _mfGreen.withValues(alpha: 0.15),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _mfScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _mfBorder.withValues(alpha: 0.3), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 0, backgroundColor: _mfGreen, foregroundColor: Colors.white,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _mfGreen : null),
        checkColor: const WidgetStatePropertyAll(Colors.white),
      ),
    );
  }

  // ── Cyberpunk Void Theme (neon dark, futuristic) ──
  static const _cvCyan = Color(0xFF00BCD4);
  static const _cvMagenta = Color(0xFFFF4081);
  static const _cvScaffold = Color(0xFF0F0F10);
  static const _cvCard = Color(0xFF1A1A1E);
  static const _cvSurface = Color(0xFF141418);
  static const _cvText = Color(0xFFB0E0E6);

  ThemeData _buildCyberpunkVoidTheme() {
    final colorScheme = ColorScheme.fromSeed(
      seedColor: _cvCyan, brightness: Brightness.dark,
      primary: _cvCyan, onPrimary: Colors.black,
      surface: _cvSurface, onSurface: _cvText,
      surfaceContainerLowest: const Color(0xFF111114),
      surfaceContainerLow: const Color(0xFF151518),
      surfaceContainer: const Color(0xFF1A1A1E),
      surfaceContainerHigh: const Color(0xFF1E1E22),
      surfaceContainerHighest: const Color(0xFF232328),
      outline: const Color(0xFF3A3A42),
      outlineVariant: const Color(0xFF2A2A30),
    );
    return ThemeData(
      colorScheme: colorScheme, useMaterial3: true,
      scaffoldBackgroundColor: _cvScaffold,
      textTheme: GoogleFonts.shareTechMonoTextTheme(ThemeData.dark().textTheme).apply(
        bodyColor: _cvText, displayColor: _cvText,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0, scrolledUnderElevation: 2, centerTitle: true,
        backgroundColor: Colors.transparent, foregroundColor: _cvText,
        titleTextStyle: GoogleFonts.shareTechMono(fontSize: 20, fontWeight: FontWeight.bold, color: _cvText),
      ),
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8),
          side: BorderSide(color: _cvCyan.withValues(alpha: 0.15))),
        color: _cvCard, clipBehavior: Clip.antiAlias,
      ),
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(backgroundColor: _cvMagenta, foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          side: BorderSide(color: _cvCyan.withValues(alpha: 0.4)),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true, fillColor: _cvCard,
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: _cvCyan.withValues(alpha: 0.15))),
        enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: _cvCyan.withValues(alpha: 0.15))),
        focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: const BorderSide(color: _cvCyan, width: 2)),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      ),
      navigationBarTheme: NavigationBarThemeData(
        elevation: 0, height: 65, indicatorColor: _cvCyan.withValues(alpha: 0.15),
        indicatorShape: const StadiumBorder(), labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        backgroundColor: _cvScaffold, surfaceTintColor: Colors.transparent,
      ),
      dialogTheme: DialogThemeData(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24))),
      snackBarTheme: SnackBarThemeData(behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      dividerTheme: DividerThemeData(color: _cvCyan.withValues(alpha: 0.1), thickness: 1),
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        elevation: 0, backgroundColor: _cvCyan, foregroundColor: Colors.black,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),
      checkboxTheme: CheckboxThemeData(
        fillColor: WidgetStateProperty.resolveWith((s) => s.contains(WidgetState.selected) ? _cvCyan : null),
        checkColor: const WidgetStatePropertyAll(Colors.black),
      ),
    );
  }

  ThemeData get _activeTheme {
    switch (_themeMode) {
      case 'dark': return _buildTheme(Brightness.dark);
      case 'ethos': return _buildEthosTheme();
      case 'ephemera': return _buildEphemeraTheme();
      case 'nordic_zen': return _buildNordicZenTheme();
      case 'green_salvia': return _buildGreenSalviaTheme();
      case 'sakura': return _buildSakuraTheme();
      case 'spadaccino': return _buildSpadaccinoTheme();
      case 'sogno_re': return _buildSognoReTheme();
      case 'mappa_tesoro': return _buildMappaTesoroTheme();
      case 'fulmine': return _buildFulmineTheme();
      case 'eremita': return _buildEremitaTheme();
      case 'saggio': return _buildSaggioTheme();
      case 'cabina_tempo': return _buildCabinaTempoTheme();
      case 'sottosopra': return _buildSottosopaTheme();
      case 'rifugio': return _buildRifugioTheme();
      case 'yellow_note': return _buildYellowNoteTheme();
      case 'deep_abyss': return _buildDeepAbyssTheme();
      case 'midnight_forest': return _buildMidnightForestTheme();
      case 'cyberpunk_void': return _buildCyberpunkVoidTheme();
      case 'block_note': return _buildBlockNoteTheme();
      default: return _buildTheme(Brightness.light);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = _activeTheme;
    return MaterialApp(
      title: 'Ethos Note',
      localizationsDelegates: const [
        quill.FlutterQuillLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('it'),
        Locale('en'),
        Locale('fr'),
        Locale('es'),
      ],
      theme: theme,
      home: _isLoading
          ? Container(color: const Color(0xFF1A1A1A))
          : _SplashGate(
              child: _onboardingComplete
                  ? HomePage(
                      themeMode: _themeMode,
                      onThemeModeChanged: setThemeMode,
                      onLocaleChanged: setLocale,
                    )
                  : WelcomePage(
                      onComplete: _completeOnboarding,
                      themeMode: _themeMode,
                      onThemeModeChanged: setThemeMode,
                      onLocaleChanged: setLocale,
                    ),
            ),
    );
  }
}

class _SplashGate extends StatefulWidget {
  final Widget child;
  const _SplashGate({required this.child});

  @override
  State<_SplashGate> createState() => _SplashGateState();
}

class _SplashGateState extends State<_SplashGate> with SingleTickerProviderStateMixin {
  bool _showSplash = true;
  late AnimationController _fadeController;
  late Animation<double> _fadeOut;

  @override
  void initState() {
    super.initState();
    _fadeController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 500),
    );
    _fadeOut = CurvedAnimation(parent: _fadeController, curve: Curves.easeOut);
    // Show splash for 1.5s, then fade out
    Future.delayed(const Duration(milliseconds: 1500), () {
      if (mounted) {
        _fadeController.forward().then((_) {
          if (mounted) setState(() => _showSplash = false);
          // Remove the HTML splash
          _removeHtmlSplash();
        });
      }
    });
    // Remove HTML splash early if Flutter renders fast
    _removeHtmlSplash();
  }

  void _removeHtmlSplash() {
    // This runs JS to hide the HTML splash div on web
    // On mobile it's a no-op since there's no HTML
  }

  @override
  void dispose() {
    _fadeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        widget.child,
        if (_showSplash)
          FadeTransition(
            opacity: ReverseAnimation(_fadeOut),
            child: Container(
              color: const Color(0xFF1A1A1A),
              child: Center(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    ClipRRect(
                      borderRadius: BorderRadius.circular(24),
                      child: Image.asset(
                        'assets/logo.png',
                        width: 120,
                        height: 120,
                      ),
                    ),
                    const SizedBox(height: 20),
                    const Text(
                      'Ethos Note',
                      style: TextStyle(
                        fontFamily: 'Georgia',
                        fontSize: 24,
                        fontWeight: FontWeight.w600,
                        color: Color(0xFFB8566B),
                        letterSpacing: 1.2,
                        decoration: TextDecoration.none,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
      ],
    );
  }
}

// ─── Welcome / Onboarding Page ───────────────────────────────────────────────

class WelcomePage extends StatefulWidget {
  final VoidCallback onComplete;
  final String themeMode;
  final Function(String) onThemeModeChanged;
  final Function(String) onLocaleChanged;

  const WelcomePage({
    super.key,
    required this.onComplete,
    required this.themeMode,
    required this.onThemeModeChanged,
    required this.onLocaleChanged,
  });

  @override
  State<WelcomePage> createState() => _WelcomePageState();
}

class _WelcomePageState extends State<WelcomePage> {
  bool _signingIn = false;

  Future<void> _handleGoogleSignIn() async {
    setState(() => _signingIn = true);
    try {
      final success = await GoogleCalendarService.signIn();
      if (!mounted) return;
      if (success) {
        // Populate UserProfile with Google account data
        final db = DatabaseHelper();
        final existing = await db.getProfile();
        final profile = existing ?? UserProfile();

        final displayName = GoogleCalendarService.userDisplayName;
        if (displayName != null && displayName.isNotEmpty) {
          final parts = displayName.trim().split(RegExp(r'\s+'));
          profile.nome = parts.first;
          if (parts.length > 1) {
            profile.cognome = parts.sublist(1).join(' ');
          }
        }
        profile.email = GoogleCalendarService.userEmail ?? profile.email;
        profile.googleCalendarConnected = true;

        // Download Google profile photo
        final photoUrl = GoogleCalendarService.userPhotoUrl;
        if (photoUrl != null && photoUrl.isNotEmpty) {
          try {
            final response = await http.get(Uri.parse(photoUrl)).timeout(const Duration(seconds: 5));
            if (response.statusCode == 200) {
              profile.photoBase64 = base64Encode(response.bodyBytes);
            }
          } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
        }

        await db.saveProfile(profile);
        if (!mounted) return;
        widget.onComplete();
      } else {
        setState(() => _signingIn = false);
      }
    } catch (e) {
      if (mounted) setState(() => _signingIn = false);
      if (kDebugMode) debugPrint('Welcome Google sign-in error: $e');
    }
  }

  void _handleContinueWithout() {
    widget.onComplete();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF1A1A1A),
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const SizedBox(height: 32),
                // Logo
                ClipRRect(
                  borderRadius: BorderRadius.circular(28),
                  child: Image.asset(
                    'assets/logo.png',
                    width: 120,
                    height: 120,
                  ),
                ),
                const SizedBox(height: 24),
                // App name
                const Text(
                  'Ethos Note',
                  style: TextStyle(
                    fontFamily: 'Georgia',
                    fontSize: 32,
                    fontWeight: FontWeight.w600,
                    color: Color(0xFFB8566B),
                    letterSpacing: 1.2,
                  ),
                ),
                const SizedBox(height: 8),
                // Subtitle
                Text(
                  tr('welcome_subtitle'),
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    fontSize: 15,
                    color: Colors.white.withValues(alpha: 0.7),
                  ),
                ),
                const SizedBox(height: 40),
                // Feature pills
                _buildFeaturePill(Icons.edit_note, tr('welcome_feature_1'), const Color(0xFFE53935)),
                const SizedBox(height: 12),
                _buildFeaturePill(Icons.calendar_month, tr('welcome_feature_2'), const Color(0xFF1E88E5)),
                const SizedBox(height: 12),
                _buildFeaturePill(Icons.flash_on, tr('welcome_feature_3'), const Color(0xFFFFA726)),
                const SizedBox(height: 48),
                // Google Sign-In button
                SizedBox(
                  width: double.infinity,
                  child: FilledButton.icon(
                    onPressed: _signingIn ? null : _handleGoogleSignIn,
                    icon: _signingIn
                        ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                        : const Icon(Icons.g_mobiledata, size: 24),
                    label: Text(_signingIn ? '...' : tr('sign_in_google')),
                    style: FilledButton.styleFrom(
                      backgroundColor: const Color(0xFF6366F1),
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
                      textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                // Continue without account
                SizedBox(
                  width: double.infinity,
                  child: TextButton(
                    onPressed: _handleContinueWithout,
                    style: TextButton.styleFrom(
                      foregroundColor: Colors.white.withValues(alpha: 0.7),
                      padding: const EdgeInsets.symmetric(vertical: 14),
                      textStyle: const TextStyle(fontSize: 15),
                    ),
                    child: Text(tr('continue_without_account')),
                  ),
                ),
                const SizedBox(height: 32),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFeaturePill(IconData icon, String text, Color accentColor) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 14),
      decoration: BoxDecoration(
        color: accentColor.withValues(alpha: 0.12),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: accentColor.withValues(alpha: 0.25)),
      ),
      child: Row(
        children: [
          Icon(icon, color: accentColor, size: 22),
          const SizedBox(width: 14),
          Expanded(
            child: Text(
              text,
              style: TextStyle(
                fontSize: 14,
                color: Colors.white.withValues(alpha: 0.9),
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class UserProfile {
  String? nome;
  String? cognome;
  String? email;
  DateTime? dataNascita;
  bool isPro;
  String? photoPath;
  String? photoBase64;
  bool googleCalendarConnected;
  bool googleDriveConnected;
  bool geminiConnected;
  String backupMode;
  String religione;
  String? telefono;
  String? password;
  List<String> socialLinks;
  List<String> friends;
  List<String> oldPhotos;
  List<Map<String, String>> accounts;
  int activeAccountIndex;
  String? nickname;
  bool lockDeepNote;
  bool lockFlashNotes;

  UserProfile({
    this.nome,
    this.cognome,
    this.email,
    this.dataNascita,
    this.isPro = false,
    this.photoPath,
    this.photoBase64,
    this.googleCalendarConnected = false,
    this.googleDriveConnected = false,
    this.geminiConnected = false,
    this.backupMode = 'local',
    this.religione = 'Cattolica',
    this.telefono,
    this.password,
    List<String>? socialLinks,
    List<String>? friends,
    List<String>? oldPhotos,
    List<Map<String, String>>? accounts,
    this.activeAccountIndex = 0,
    this.nickname,
    this.lockDeepNote = false,
    this.lockFlashNotes = false,
  })  : socialLinks = socialLinks ?? [],
        friends = friends ?? [],
        oldPhotos = oldPhotos ?? [],
        accounts = accounts ?? [];

  int? get eta {
    if (dataNascita == null) return null;
    final now = DateTime.now();
    int age = now.year - dataNascita!.year;
    if (now.month < dataNascita!.month ||
        (now.month == dataNascita!.month && now.day < dataNascita!.day)) {
      age--;
    }
    return age;
  }

  Map<String, dynamic> toJson() {
    return {
      'nome': nome,
      'cognome': cognome,
      'email': email,
      'dataNascita': dataNascita?.toIso8601String(),
      'isPro': isPro,
      'photoPath': photoPath,
      'photoBase64': photoBase64,
      'googleCalendarConnected': googleCalendarConnected,
      'googleDriveConnected': googleDriveConnected,
      'geminiConnected': geminiConnected,
      'backupMode': backupMode,
      'religione': religione,
      'telefono': telefono,
      'password': password,
      'socialLinks': socialLinks,
      'friends': friends,
      'oldPhotos': oldPhotos,
      'accounts': accounts,
      'activeAccountIndex': activeAccountIndex,
      'nickname': nickname,
      'lockDeepNote': lockDeepNote,
      'lockFlashNotes': lockFlashNotes,
    };
  }

  factory UserProfile.fromJson(Map<String, dynamic> json) {
    return UserProfile(
      nome: json['nome'],
      cognome: json['cognome'],
      email: json['email'],
      dataNascita: json['dataNascita'] != null
          ? DateTime.tryParse(json['dataNascita'] ?? '')
          : null,
      isPro: json['isPro'] ?? false,
      photoPath: json['photoPath'],
      photoBase64: json['photoBase64'],
      googleCalendarConnected: json['googleCalendarConnected'] ?? false,
      googleDriveConnected: json['googleDriveConnected'] ?? false,
      geminiConnected: json['geminiConnected'] ?? false,
      backupMode: json['backupMode'] ?? 'local',
      religione: json['religione'] ?? tr('catholic'),
      telefono: json['telefono'],
      password: json['password'],
      socialLinks: (json['socialLinks'] as List<dynamic>?)?.cast<String>() ?? [],
      friends: (json['friends'] as List<dynamic>?)?.cast<String>() ?? [],
      oldPhotos: (json['oldPhotos'] as List<dynamic>?)?.cast<String>() ?? [],
      accounts: (json['accounts'] as List<dynamic>?)
          ?.map((e) => Map<String, String>.from(e as Map))
          .toList() ?? [],
      activeAccountIndex: json['activeAccountIndex'] ?? 0,
      nickname: json['nickname'],
      lockDeepNote: json['lockDeepNote'] ?? false,
      lockFlashNotes: json['lockFlashNotes'] ?? false,
    );
  }

  String get initials {
    if (nome == null && cognome == null) return '?';
    final n = nome?.isNotEmpty == true ? nome![0] : '';
    final c = cognome?.isNotEmpty == true ? cognome![0] : '';
    return '$n$c'.toUpperCase();
  }

  String get fullName {
    if (nome == null && cognome == null) return tr('guest');
    return '${nome ?? ''} ${cognome ?? ''}'.trim();
  }

  bool get hasAccount => email != null && email!.isNotEmpty;

  Uint8List? get photoBytes {
    if (photoBase64 != null && photoBase64!.isNotEmpty) {
      return base64Decode(photoBase64!);
    }
    return null;
  }

  Map<String, dynamic> toDbMap() => {
    'nome': nome,
    'cognome': cognome,
    'email': email,
    'data_nascita': dataNascita?.millisecondsSinceEpoch,
    'is_pro': isPro ? 1 : 0,
    'photo_path': photoPath,
    'photo_base64': photoBase64,
    'google_calendar_connected': googleCalendarConnected ? 1 : 0,
    'google_drive_connected': googleDriveConnected ? 1 : 0,
    'gemini_connected': geminiConnected ? 1 : 0,
    'backup_mode': backupMode,
    'religione': religione,
    'telefono': telefono,
    'password': password,
    'social_links': json.encode(socialLinks),
    'friends': json.encode(friends),
    'old_photos': json.encode(oldPhotos),
    'accounts': json.encode(accounts),
    'active_account_index': activeAccountIndex,
    'nickname': nickname,
    'lock_deep_note': lockDeepNote ? 1 : 0,
    'lock_flash_notes': lockFlashNotes ? 1 : 0,
  };

  factory UserProfile.fromDbMap(Map<String, dynamic> m) => UserProfile(
    nome: m['nome'] as String?,
    cognome: m['cognome'] as String?,
    email: m['email'] as String?,
    dataNascita: m['data_nascita'] != null ? DateTime.fromMillisecondsSinceEpoch(m['data_nascita'] as int) : null,
    isPro: (m['is_pro'] as int?) == 1,
    photoPath: m['photo_path'] as String?,
    photoBase64: m['photo_base64'] as String?,
    googleCalendarConnected: (m['google_calendar_connected'] as int?) == 1,
    googleDriveConnected: (m['google_drive_connected'] as int?) == 1,
    geminiConnected: (m['gemini_connected'] as int?) == 1,
    backupMode: (m['backup_mode'] as String?) ?? 'local',
    religione: (m['religione'] as String?) ?? 'Cattolica',
    telefono: m['telefono'] as String?,
    password: m['password'] as String?,
    socialLinks: m['social_links'] != null ? (json.decode(m['social_links'] as String) as List).cast<String>() : [],
    friends: m['friends'] != null ? (json.decode(m['friends'] as String) as List).cast<String>() : [],
    oldPhotos: m['old_photos'] != null ? (json.decode(m['old_photos'] as String) as List).cast<String>() : [],
    accounts: m['accounts'] != null ? (json.decode(m['accounts'] as String) as List).map((e) => Map<String, String>.from(e as Map)).toList() : [],
    activeAccountIndex: (m['active_account_index'] as int?) ?? 0,
    nickname: m['nickname'] as String?,
    lockDeepNote: (m['lock_deep_note'] as int?) == 1,
    lockFlashNotes: (m['lock_flash_notes'] as int?) == 1,
  );
}

class CalendarEventFull {
  final int? id;
  final String title;
  final DateTime startTime;
  final DateTime endTime;
  final String calendar;
  final String? reminder;
  final String? preset;
  final String? attachmentPath;
  final String? notes;
  final bool isCompleted;
  final String? googleEventId;
  final List<String> sharedWith;
  final String? attachmentBase64;
  final String? recurrence; // null/daily/weekly/monthly/yearly
  final String? recurrenceEndDate; // ISO date string

  CalendarEventFull({
    this.id,
    required this.title,
    required this.startTime,
    required this.endTime,
    this.calendar = 'Personale',
    this.reminder,
    this.preset,
    this.attachmentPath,
    this.notes,
    this.isCompleted = false,
    this.googleEventId,
    List<String>? sharedWith,
    this.attachmentBase64,
    this.recurrence,
    this.recurrenceEndDate,
  }) : sharedWith = sharedWith ?? [];

  String get dateKey => '${startTime.year}-${startTime.month}-${startTime.day}';

  CalendarEventFull copyWith({
    bool? isCompleted,
    List<String>? sharedWith,
    String? attachmentBase64,
    String? recurrence,
    String? recurrenceEndDate,
  }) {
    return CalendarEventFull(
      id: id,
      title: title,
      startTime: startTime,
      endTime: endTime,
      calendar: calendar,
      reminder: reminder,
      preset: preset,
      attachmentPath: attachmentPath,
      notes: notes,
      isCompleted: isCompleted ?? this.isCompleted,
      googleEventId: googleEventId,
      sharedWith: sharedWith ?? this.sharedWith,
      attachmentBase64: attachmentBase64 ?? this.attachmentBase64,
      recurrence: recurrence ?? this.recurrence,
      recurrenceEndDate: recurrenceEndDate ?? this.recurrenceEndDate,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'title': title,
      'startTime': startTime.toIso8601String(),
      'endTime': endTime.toIso8601String(),
      'calendar': calendar,
      'reminder': reminder,
      'preset': preset,
      'attachmentPath': attachmentPath,
      'notes': notes,
      'isCompleted': isCompleted,
      if (googleEventId != null) 'googleEventId': googleEventId,
      'sharedWith': sharedWith,
      if (attachmentBase64 != null) 'attachmentBase64': attachmentBase64,
      if (recurrence != null) 'recurrence': recurrence,
      if (recurrenceEndDate != null) 'recurrenceEndDate': recurrenceEndDate,
    };
  }

  factory CalendarEventFull.fromJson(Map<String, dynamic> json) {
    return CalendarEventFull(
      title: json['title'] ?? '',
      startTime: DateTime.tryParse(json['startTime'] ?? '') ?? DateTime.now(),
      endTime: DateTime.tryParse(json['endTime'] ?? '') ?? DateTime.now(),
      calendar: json['calendar'] ?? tr('personal'),
      reminder: json['reminder'],
      preset: json['preset'],
      attachmentPath: json['attachmentPath'],
      notes: json['notes'],
      isCompleted: json['isCompleted'] ?? false,
      googleEventId: json['googleEventId'],
      sharedWith: (json['sharedWith'] as List<dynamic>?)?.cast<String>() ?? [],
      attachmentBase64: json['attachmentBase64'],
      recurrence: json['recurrence'],
      recurrenceEndDate: json['recurrenceEndDate'],
    );
  }

  Map<String, dynamic> toDbMap() => {
    'title': title,
    'start_time': startTime.millisecondsSinceEpoch,
    'end_time': endTime.millisecondsSinceEpoch,
    'date_key': dateKey,
    'calendar': calendar,
    'reminder': reminder,
    'preset': preset,
    'attachment_path': attachmentPath,
    'attachment_base64': attachmentBase64,
    'notes': notes,
    'is_completed': isCompleted ? 1 : 0,
    'google_event_id': googleEventId,
    'shared_with': sharedWith.isNotEmpty ? json.encode(sharedWith) : null,
    'recurrence': recurrence,
    'recurrence_end_date': recurrenceEndDate,
  };

  factory CalendarEventFull.fromDbMap(Map<String, dynamic> m) => CalendarEventFull(
    id: m['id'] as int?,
    title: (m['title'] as String?) ?? '',
    startTime: DateTime.fromMillisecondsSinceEpoch((m['start_time'] as int?) ?? 0),
    endTime: DateTime.fromMillisecondsSinceEpoch((m['end_time'] as int?) ?? 0),
    calendar: (m['calendar'] as String?) ?? 'Personale',
    reminder: m['reminder'] as String?,
    preset: m['preset'] as String?,
    attachmentPath: m['attachment_path'] as String?,
    attachmentBase64: m['attachment_base64'] as String?,
    notes: m['notes'] as String?,
    isCompleted: (m['is_completed'] as int?) == 1,
    googleEventId: m['google_event_id'] as String?,
    sharedWith: m['shared_with'] != null ? (json.decode(m['shared_with'] as String) as List).cast<String>() : [],
    recurrence: m['recurrence'] as String?,
    recurrenceEndDate: m['recurrence_end_date'] as String?,
  );
}

class Holidays {
  static Map<String, List<Holiday>> getHolidays(String religione) {
    final base = <Holiday>[
      Holiday(1, 1, '🎉', 'Capodanno'),
      Holiday(1, 6, '⭐', 'Epifania'),
      Holiday(4, 25, '🇮🇹', 'Liberazione'),
      Holiday(5, 1, '🛠️', 'Festa Lavoro'),
      Holiday(6, 2, '🇮🇹', 'Repubblica'),
      Holiday(8, 15, '⛱️', 'Ferragosto'),
      Holiday(11, 1, '🕯️', 'Ognissanti'),
      Holiday(12, 8, '🎄', 'Immacolata'),
      Holiday(12, 25, '🎄', 'Natale'),
      Holiday(12, 26, '🎁', 'S. Stefano'),
    ];

    if (religione == tr('catholic')) {
      base.add(Holiday(4, 20, '🐣', 'Pasqua'));
      base.add(Holiday(4, 21, '🐣', 'Pasquetta'));
    } else if (religione == tr('jewish')) {
      base.add(Holiday(9, 25, '🕎', 'Rosh Hashanah'));
      base.add(Holiday(12, 25, '🕎', 'Hanukkah'));
    } else if (religione == tr('islamic')) {
      base.add(Holiday(4, 10, '🌙', 'Eid al-Fitr'));
      base.add(Holiday(6, 16, '🌙', 'Eid al-Adha'));
    } else if (religione == tr('chinese')) {
      base.add(Holiday(1, 29, '🧧', 'Capodanno Cinese'));
      base.add(Holiday(2, 15, '🏮', 'Festa delle Lanterne'));
      base.add(Holiday(4, 5, '🪦', 'Qingming'));
      base.add(Holiday(5, 31, '🐉', 'Duanwu'));
      base.add(Holiday(10, 1, '🇨🇳', 'Festa Nazionale Cinese'));
      base.add(Holiday(10, 6, '🥮', 'Zhongqiu'));
    }

    Map<String, List<Holiday>> result = {};
    for (var h in base) {
      final key = '${h.month}-${h.day}';
      result[key] = result[key] ?? [];
      result[key]!.add(h);
    }
    return result;
  }
}

class Holiday {
  final int month;
  final int day;
  final String emoji;
  final String name;

  Holiday(this.month, this.day, this.emoji, this.name);
}

String getZodiacSignFromDate(int month, int day, {String mode = 'icon_and_text'}) {
  // Accurate zodiac based on actual date ranges
  String segno;
  String icon;
  if ((month == 3 && day >= 21) || (month == 4 && day <= 19)) { segno = tr('aries'); icon = '♈'; }
  else if ((month == 4 && day >= 20) || (month == 5 && day <= 20)) { segno = tr('taurus'); icon = '♉'; }
  else if ((month == 5 && day >= 21) || (month == 6 && day <= 20)) { segno = tr('gemini'); icon = '♊'; }
  else if ((month == 6 && day >= 21) || (month == 7 && day <= 22)) { segno = tr('cancer'); icon = '♋'; }
  else if ((month == 7 && day >= 23) || (month == 8 && day <= 22)) { segno = tr('leo'); icon = '♌'; }
  else if ((month == 8 && day >= 23) || (month == 9 && day <= 22)) { segno = tr('virgo'); icon = '♍'; }
  else if ((month == 9 && day >= 23) || (month == 10 && day <= 22)) { segno = tr('libra'); icon = '♎'; }
  else if ((month == 10 && day >= 23) || (month == 11 && day <= 21)) { segno = tr('scorpio'); icon = '♏'; }
  else if ((month == 11 && day >= 22) || (month == 12 && day <= 21)) { segno = tr('sagittarius'); icon = '♐'; }
  else if ((month == 12 && day >= 22) || (month == 1 && day <= 19)) { segno = tr('capricorn'); icon = '♑'; }
  else if ((month == 1 && day >= 20) || (month == 2 && day <= 18)) { segno = tr('aquarius'); icon = '♒'; }
  else { segno = tr('pisces'); icon = '♓'; }

  switch (mode) {
    case 'icon_only': return icon;
    case 'text_only': return segno;
    case 'icon_and_text':
    default: return '$icon $segno';
  }
}

String getChineseZodiac(int year) {
  const emojis = ['🐒', '🐓', '🐕', '🐖', '🐀', '🐂', '🐅', '🐇', '🐉', '🐍', '🐎', '🐐'];
  return emojis[year % 12];
}

// ─── Horoscope Data ─────────────────────────────────────────────────────────

class HoroscopeData {
  final String segno;
  final String testo;
  final DateTime fetchedAt;

  HoroscopeData({required this.segno, required this.testo, required this.fetchedAt});

  bool get isStale => DateTime.now().difference(fetchedAt).inHours > 12;

  Map<String, dynamic> toJson() => {
    'segno': segno,
    'testo': testo,
    'fetchedAt': fetchedAt.toIso8601String(),
  };

  factory HoroscopeData.fromJson(Map<String, dynamic> json) => HoroscopeData(
    segno: json['segno'],
    testo: json['testo'],
    fetchedAt: DateTime.tryParse(json['fetchedAt'] ?? '') ?? DateTime.now(),
  );

  static Future<HoroscopeData?> loadCached() async {
    final jsonStr = await DatabaseHelper().getCache('horoscope_cache');
    if (jsonStr != null) {
      final data = HoroscopeData.fromJson(json.decode(jsonStr));
      if (!data.isStale) return data;
    }
    return null;
  }

  Future<void> saveCache() async {
    await DatabaseHelper().saveCache('horoscope_cache', json.encode(toJson()));
  }
}

Future<HoroscopeData?> fetchOroscopo(String segno) async {
  // Check cache first
  final cached = await HoroscopeData.loadCached();
  if (cached != null && cached.segno.toLowerCase() == segno.toLowerCase()) {
    return cached;
  }

  try {
    final now = DateTime.now();
    const giorniSettimana = ['', 'lunedi', 'martedi', 'mercoledi', 'giovedi', 'venerdi', 'sabato', 'domenica'];
    const mesiIt = ['', 'gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
      'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];

    final giorno = giorniSettimana[now.weekday];
    final giornoNumero = now.day;
    final mese = mesiIt[now.month];
    final anno = now.year;

    final url = 'https://www.superguidatv.it/oroscopo-paolo-fox-del-giorno-$giorno-$giornoNumero-$mese-$anno/';
    final response = await http.get(Uri.parse(url)).timeout(const Duration(seconds: 10));

    if (response.statusCode == 200) {
      final body = response.body;
      // Search for the zodiac sign section
      final segnoLower = segno.toLowerCase();
      final patterns = [
        RegExp('oroscopo\\s+paolo\\s+fox\\s+$segnoLower[^<]*</h[23]>\\s*<p>([^<]+)', caseSensitive: false),
        RegExp('$segnoLower[^<]*</h[23]>\\s*<p>([^<]+)', caseSensitive: false),
        RegExp('$segnoLower[^<]*</strong>\\s*[.:–-]?\\s*([^<]+)', caseSensitive: false),
      ];

      String? testo;
      for (final pattern in patterns) {
        final match = pattern.firstMatch(body);
        if (match != null) {
          testo = match.group(1)?.trim();
          if (testo != null && testo.length > 20) break;
          testo = null;
        }
      }

      if (testo != null) {
        // Clean HTML entities
        testo = testo.replaceAll('&nbsp;', ' ')
            .replaceAll('&amp;', '&')
            .replaceAll('&rsquo;', "'")
            .replaceAll('&lsquo;', "'")
            .replaceAll('&ldquo;', '"')
            .replaceAll('&rdquo;', '"')
            .replaceAll(RegExp(r'&#\d+;'), '')
            .replaceAll(RegExp(r'<[^>]+>'), '')
            .trim();

        final data = HoroscopeData(segno: segno, testo: testo, fetchedAt: DateTime.now());
        await data.saveCache();
        return data;
      }
    }
  } catch (_) {
    // fallback
  }

  return null;
}

// ─── Weather Data ───────────────────────────────────────────────────────────

class DailyWeather {
  final DateTime date;
  final int weatherCode;
  final double tempMax;
  final double tempMin;

  DailyWeather({required this.date, required this.weatherCode, required this.tempMax, required this.tempMin});

  String get icon {
    if (weatherCode == 0) return '☀️';
    if (weatherCode <= 3) return '🌤️';
    if (weatherCode <= 48) return '☁️';
    if (weatherCode <= 67) return '🌧️';
    if (weatherCode <= 77) return '❄️';
    if (weatherCode <= 82) return '🌧️';
    if (weatherCode <= 86) return '❄️';
    if (weatherCode <= 99) return '⛈️';
    return '🌤️';
  }

  String get description {
    if (weatherCode == 0) return 'Sereno';
    if (weatherCode <= 3) return 'Parz. nuvoloso';
    if (weatherCode <= 48) return 'Nuvoloso';
    if (weatherCode <= 57) return 'Pioggerella';
    if (weatherCode <= 67) return 'Pioggia';
    if (weatherCode <= 77) return 'Neve';
    if (weatherCode <= 82) return 'Acquazzone';
    if (weatherCode <= 86) return 'Neve forte';
    if (weatherCode <= 99) return 'Temporale';
    return 'Variabile';
  }

  Map<String, dynamic> toJson() => {
    'date': date.toIso8601String(),
    'weatherCode': weatherCode,
    'tempMax': tempMax,
    'tempMin': tempMin,
  };

  factory DailyWeather.fromJson(Map<String, dynamic> json) => DailyWeather(
    date: DateTime.tryParse(json['date'] ?? '') ?? DateTime.now(),
    weatherCode: json['weatherCode'],
    tempMax: (json['tempMax'] as num).toDouble(),
    tempMin: (json['tempMin'] as num).toDouble(),
  );
}

class WeatherData {
  final String city;
  final double lat;
  final double lon;
  final List<DailyWeather> forecast;
  final DateTime fetchedAt;

  WeatherData({required this.city, required this.lat, required this.lon, required this.forecast, required this.fetchedAt});

  bool get isStale => DateTime.now().difference(fetchedAt).inHours > 6;

  DailyWeather? forDay(DateTime day) {
    for (final f in forecast) {
      if (f.date.year == day.year && f.date.month == day.month && f.date.day == day.day) return f;
    }
    return null;
  }

  Map<String, dynamic> toJson() => {
    'city': city,
    'lat': lat,
    'lon': lon,
    'forecast': forecast.map((f) => f.toJson()).toList(),
    'fetchedAt': fetchedAt.toIso8601String(),
  };

  factory WeatherData.fromJson(Map<String, dynamic> json) => WeatherData(
    city: json['city'],
    lat: (json['lat'] as num).toDouble(),
    lon: (json['lon'] as num).toDouble(),
    forecast: (json['forecast'] as List?)?.map((f) => DailyWeather.fromJson(f)).toList() ?? [],
    fetchedAt: DateTime.tryParse(json['fetchedAt'] ?? '') ?? DateTime.now(),
  );

  static Future<WeatherData?> loadCached() async {
    final jsonStr = await DatabaseHelper().getCache('weather_cache');
    if (jsonStr != null) {
      final data = WeatherData.fromJson(json.decode(jsonStr));
      if (!data.isStale) return data;
    }
    return null;
  }

  Future<void> saveCache() async {
    await DatabaseHelper().saveCache('weather_cache', json.encode(toJson()));
  }
}

class WeatherCityResult {
  final String name;
  final String? country;
  final String? admin;
  final double lat;
  final double lon;

  WeatherCityResult({required this.name, this.country, this.admin, required this.lat, required this.lon});

  String get displayName {
    final parts = <String>[name];
    if (admin != null && admin!.isNotEmpty && admin != name) parts.add(admin!);
    if (country != null && country!.isNotEmpty) parts.add(country!);
    return parts.join(', ');
  }
}

class WeatherService {
  static Future<List<WeatherCityResult>> searchCities(String query) async {
    if (query.trim().length < 2) return [];
    try {
      final url = 'https://geocoding-api.open-meteo.com/v1/search?name=${Uri.encodeComponent(query.trim())}&count=5&language=it';
      final response = await http.get(Uri.parse(url)).timeout(const Duration(seconds: 10));
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final results = data['results'] as List?;
        if (results != null) {
          return results.map((r) => WeatherCityResult(
            name: r['name'] as String,
            country: r['country'] as String?,
            admin: r['admin1'] as String?,
            lat: (r['latitude'] as num).toDouble(),
            lon: (r['longitude'] as num).toDouble(),
          )).toList();
        }
      }
    } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
    return [];
  }

  static Future<({double lat, double lon})?> geocodeCity(String name) async {
    final results = await searchCities(name);
    if (results.isNotEmpty) return (lat: results.first.lat, lon: results.first.lon);
    return null;
  }

  static Future<WeatherData?> fetchWeather(String city, double lat, double lon) async {
    try {
      final url = 'https://api.open-meteo.com/v1/forecast?latitude=$lat&longitude=$lon'
          '&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=auto';
      final response = await http.get(Uri.parse(url)).timeout(const Duration(seconds: 10));
      if (response.statusCode == 200) {
        final data = json.decode(response.body) as Map<String, dynamic>;
        final daily = data['daily'] as Map<String, dynamic>?;
        if (daily == null) return null;
        final dates = (daily['time'] as List?)?.cast<String>() ?? [];
        if (dates.isEmpty) return null;
        final codes = (daily['weather_code'] as List?) ?? [];
        final maxTemps = (daily['temperature_2m_max'] as List?) ?? [];
        final minTemps = (daily['temperature_2m_min'] as List?) ?? [];

        final forecast = <DailyWeather>[];
        for (int i = 0; i < dates.length && i < 7; i++) {
          forecast.add(DailyWeather(
            date: DateTime.parse(dates[i]),
            weatherCode: (codes[i] as num).toInt(),
            tempMax: (maxTemps[i] as num).toDouble(),
            tempMin: (minTemps[i] as num).toDouble(),
          ));
        }

        final weatherData = WeatherData(
          city: city, lat: lat, lon: lon, forecast: forecast, fetchedAt: DateTime.now(),
        );
        await weatherData.saveCache();
        return weatherData;
      }
    } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
    return null;
  }
}

String getZodiacSign(int month, {String mode = 'icon_and_text'}) {
  const icons = {
    1: '♑', 2: '♒', 3: '♓', 4: '♈', 5: '♉', 6: '♊',
    7: '♋', 8: '♌', 9: '♍', 10: '♎', 11: '♏', 12: '♐',
  };
  final names = {
    1: tr('capricorn'), 2: tr('aquarius'), 3: tr('pisces'), 4: tr('aries'),
    5: tr('taurus'), 6: tr('gemini'), 7: tr('cancer'), 8: tr('leo'),
    9: tr('virgo'), 10: tr('libra'), 11: tr('scorpio'), 12: tr('sagittarius'),
  };
  final icon = icons[month] ?? '';
  final name = names[month] ?? '';
  switch (mode) {
    case 'icon_only':
      return icon;
    case 'text_only':
      return name;
    case 'icon_and_text':
    default:
      return '$icon $name';
  }
}

TextStyle getCalendarFontStyle(String fontFamily, double fontSize, Color color) {
  switch (fontFamily) {
    case 'Corsivo':
      return GoogleFonts.dancingScript(fontSize: fontSize, color: color);
    case 'Arcade':
      return GoogleFonts.pressStart2p(fontSize: fontSize * 0.7, color: color);
    default:
      return TextStyle(fontSize: fontSize, color: color);
  }
}

class _CalendarIcon9 extends StatelessWidget {
  final double size;
  final Color? color;
  const _CalendarIcon9({this.size = 24, this.color});
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: size,
      height: size,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Icon(Icons.calendar_today, size: size, color: color),
          Positioned(
            bottom: size * 0.12,
            child: Text(
              '9',
              style: TextStyle(
                fontSize: size * 0.42,
                fontWeight: FontWeight.w800,
                color: color ?? IconTheme.of(context).color,
                height: 1,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _AnimatedCalendarIcon9 extends AnimatedWidget {
  final double size;
  final Color unselectedColor;
  final Color selectedColor;

  const _AnimatedCalendarIcon9({
    required Animation<double> animation,
    this.size = 24,
    required this.unselectedColor,
    required this.selectedColor,
  }) : super(listenable: animation);

  @override
  Widget build(BuildContext context) {
    final progress = (listenable as Animation<double>).value;
    final color = Color.lerp(unselectedColor, selectedColor, progress)!;
    return SizedBox(
      width: size,
      height: size,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Icon(Icons.calendar_today, size: size, color: color),
          Positioned(
            bottom: size * 0.12,
            child: Opacity(
              opacity: progress,
              child: Transform.scale(
                scale: 0.5 + 0.5 * progress,
                child: Text(
                  '9',
                  style: TextStyle(
                    fontSize: size * 0.42,
                    fontWeight: FontWeight.w800,
                    color: color,
                    height: 1,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _SlideInItem extends StatelessWidget {
  final int index;
  final Widget child;
  const _SlideInItem({required this.index, required this.child});

  @override
  Widget build(BuildContext context) {
    final delay = Duration(milliseconds: 50 * index.clamp(0, 8));
    return TweenAnimationBuilder<double>(
      tween: Tween(begin: 0.0, end: 1.0),
      duration: Duration(milliseconds: 300 + delay.inMilliseconds),
      curve: Curves.easeOutCubic,
      builder: (context, value, child) {
        return Opacity(
          opacity: value,
          child: Transform.translate(
            offset: Offset(0, 20 * (1 - value)),
            child: child,
          ),
        );
      },
      child: child,
    );
  }
}

/// A widget that applies a breathing pulse animation to its child.
class _PulsingWidget extends StatefulWidget {
  final Widget child;
  final bool pulsing;
  const _PulsingWidget({required this.child, required this.pulsing});

  @override
  State<_PulsingWidget> createState() => _PulsingWidgetState();
}

class _PulsingWidgetState extends State<_PulsingWidget> with SingleTickerProviderStateMixin {
  late final AnimationController _ctrl;
  late final Animation<double> _scale;

  @override
  void initState() {
    super.initState();
    _ctrl = AnimationController(vsync: this, duration: const Duration(milliseconds: 800));
    _scale = Tween<double>(begin: 1.0, end: 1.18).animate(CurvedAnimation(parent: _ctrl, curve: Curves.easeInOut));
    if (widget.pulsing) _ctrl.repeat(reverse: true);
  }

  @override
  void didUpdateWidget(covariant _PulsingWidget old) {
    super.didUpdateWidget(old);
    if (widget.pulsing && !old.pulsing) {
      _ctrl.repeat(reverse: true);
    } else if (!widget.pulsing && old.pulsing) {
      _ctrl.stop();
      _ctrl.reset();
    }
  }

  @override
  void dispose() {
    _ctrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.pulsing) return widget.child;
    return AnimatedBuilder(
      animation: _scale,
      builder: (context, child) => Transform.scale(scale: _scale.value, child: child),
      child: widget.child,
    );
  }
}

class HomePage extends StatefulWidget {
  final String themeMode;
  final Function(String) onThemeModeChanged;
  final Function(String) onLocaleChanged;

  const HomePage({
    super.key,
    required this.themeMode,
    required this.onThemeModeChanged,
    required this.onLocaleChanged,
  });

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> with TickerProviderStateMixin {
  int _selectedIndex = 1;
  int _refreshKey = 0;
  UserProfile _userProfile = UserProfile();
  bool _cycleDiaryActive = false;
  static const _shareChannel = MethodChannel('com.ethosnote.app/share');
  static const _deepLinkChannel = MethodChannel('com.ethosnote.app/deeplink');
  String? _pendingDeepLink;
  DateTime? _lastDeepLinkTime;
  late final AnimationController _calIconController;
  List<ConnectivityResult> _connectivityStatus = [];
  late final StreamSubscription<List<ConnectivityResult>> _connectivitySubscription;

  @override
  void initState() {
    super.initState();
    _connectivitySubscription = Connectivity().onConnectivityChanged.listen((result) {
      if (mounted) setState(() => _connectivityStatus = result);
    });
    _calIconController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 400),
      value: 1.0, // starts on calendar tab (index 1)
    );
    _loadUserProfile();
    _checkCycleDiaryBadge();
    _checkSharedFile();
    _checkDeepLink();
    _checkAutoBackup();
    _checkBootReschedule();
    _refreshWidgets();
    _syncThemeToWidget(widget.themeMode);
    NotificationService.onNotificationTap = _handleNotificationPayload;
    // Listen for deep links pushed from native (warm start)
    _deepLinkChannel.setMethodCallHandler((call) async {
      if (call.method == 'onDeepLink') {
        final String? link = call.arguments as String?;
        if (link != null && link.isNotEmpty) {
          _handleDeepLink(link);
        }
      }
    });
  }

  @override
  void dispose() {
    _connectivitySubscription.cancel();
    _deepLinkChannel.setMethodCallHandler(null);
    _calIconController.dispose();
    NotificationService.onNotificationTap = null;
    super.dispose();
  }

  void _handleNotificationPayload(String payload) {
    if (payload == 'cycle_diary' && mounted) {
      setState(() {
        _selectedIndex = 0;
        _calIconController.reverse();
      });
      _openLatestCycleDiary();
    }
  }

  Future<void> _openLatestCycleDiary() async {
    final notes = await DatabaseHelper().getAllProNotes();
    final diaryNotes = notes.where((n) {
      if (n.folder != 'Diario del Ciclo' || n.contentDelta == null) return false;
      try {
        final data = json.decode(n.contentDelta!) as Map<String, dynamic>;
        return data['type'] == 'cycle_diary' || data['type'] == 'cycle_missing';
      } catch (_) {
        return false;
      }
    }).toList();
    if (diaryNotes.isEmpty || !mounted) return;
    diaryNotes.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    final latest = diaryNotes.first;
    final data = json.decode(latest.contentDelta!) as Map<String, dynamic>;
    Navigator.push(context, MaterialPageRoute(
      builder: (_) => CycleDiaryPage(
        data: data,
        noteId: latest.id,
        onSave: (updatedData) async {
          if (latest.id != null) {
            final updated = ProNote(
              title: latest.title,
              content: _CalendarPageState.buildCycleDiaryPlainText(updatedData),
              contentDelta: json.encode(updatedData),
              folder: 'Diario del Ciclo',
              createdAt: latest.createdAt,
            );
            await DatabaseHelper().updateProNote(latest.id!, updated);
          }
        },
        onComplete: (updatedData) async {
          if (latest.id != null) {
            final updated = ProNote(
              title: latest.title,
              content: _CalendarPageState.buildCycleDiaryPlainText(updatedData),
              contentDelta: json.encode(updatedData),
              folder: 'Diario del Ciclo',
              createdAt: latest.createdAt,
            );
            await DatabaseHelper().updateProNote(latest.id!, updated);
            await DatabaseHelper().deleteCache('cycle_diary_active');
          }
        },
      ),
    ));
  }

  Future<void> _checkCycleDiaryBadge() async {
    final activeJson = await DatabaseHelper().getCache('cycle_diary_active');
    final active = activeJson != null && activeJson.isNotEmpty;
    if (mounted && active != _cycleDiaryActive) {
      setState(() => _cycleDiaryActive = active);
    }
  }

  Future<void> _refreshWidgets() async {
    if (kIsWeb) return;
    try {
      await HomeWidget.updateWidget(
        qualifiedAndroidName: 'com.ethosnote.app.widget.FlashNotesShortcutsProvider',
      );
    } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
  }

  Future<void> _checkDeepLink() async {
    if (kIsWeb) return;
    try {
      final String? link = await _deepLinkChannel.invokeMethod('getDeepLink');
      if (link != null && link.isNotEmpty) {
        _handleDeepLink(link);
      }
    } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
  }

  void _handleDeepLink(String uri) {
    // Throttle: ignore deep links arriving within 3 seconds of each other
    final now = DateTime.now();
    if (_lastDeepLinkTime != null && now.difference(_lastDeepLinkTime!).inSeconds < 3) return;
    _lastDeepLinkTime = now;
    final parsed = Uri.tryParse(uri);
    if (parsed == null || parsed.scheme != 'ethosnote') return;
    final host = parsed.host;
    final pathSegments = parsed.pathSegments;

    if (host == 'flashnote') {
      // Switch to Flash Notes tab (index 2)
      setState(() {
        _selectedIndex = 2;
        _refreshKey++;
      });
      final mode = pathSegments.isNotEmpty ? pathSegments[0] : 'text';
      _pendingDeepLink = 'flashnote/$mode';
    } else if (host == 'calendar') {
      // Switch to Calendar tab (index 1)
      setState(() {
        _selectedIndex = 1;
        _refreshKey++;
      });
      if (pathSegments.isNotEmpty) {
        _pendingDeepLink = 'calendar/${pathSegments[0]}';
      }
    }
  }

  Future<void> _checkSharedFile() async {
    if (kIsWeb) return;
    try {
      final String? path = await _shareChannel.invokeMethod('getSharedFile');
      if (path != null && path.isNotEmpty) {
        await _handleSharedAudioFile(path);
      }
    } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
  }

  Future<void> _handleSharedAudioFile(String sourcePath) async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final fileName = 'shared_audio_${DateTime.now().millisecondsSinceEpoch}${p.extension(sourcePath)}';
      final destPath = '${appDir.path}/$fileName';
      await File(sourcePath).copy(destPath);
      final note = FlashNote(
        content: '🎤 ${tr('voice_note')}',
        audioPath: destPath,
      );
      await DatabaseHelper().insertFlashNote(note);
      if (!mounted) return;
      // Switch to Flash Notes tab and refresh
      setState(() { _selectedIndex = 2; _refreshKey++; });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(tr('voice_note_saved')),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
  }

  Future<void> _loadUserProfile() async {
    final profile = await DatabaseHelper().getProfile();
    if (profile != null && mounted) {
      setState(() {
        _userProfile = profile;
      });
    }
  }

  Future<void> _saveUserProfile() async {
    await DatabaseHelper().saveProfile(_userProfile);
  }

  /// After a device reboot, the BootReceiver sets a flag so that the next
  /// app launch reschedules all calendar-event notifications.
  Future<void> _checkBootReschedule() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (prefs.getBool('needs_reschedule') ?? false) {
        await prefs.remove('needs_reschedule');
        // Load all calendar events and reschedule their notifications
        final events = await DatabaseHelper().getAllEvents();
        final now = DateTime.now();
        final calSettings = await CalendarSettings.load();
        final alertType = calSettings.alertConfig.alertType;
        try {
          await NotificationService.cancelAll();
        } catch (_) {}
        int scheduled = 0;
        for (final dayEvents in events.values) {
          for (final event in dayEvents) {
            if (!event.startTime.isAfter(now)) continue;
            final baseId = event.startTime.millisecondsSinceEpoch ~/ 1000;

            // 1) Event-specific reminder (mirrors _CalendarPageState._scheduleNotification)
            if (event.reminder != null && event.reminder!.isNotEmpty) {
              final r = event.reminder!;
              int minutesBefore = 15;
              if (r == tr('10_min_before')) {
                minutesBefore = 10;
              } else if (r == tr('15_min_before')) {
                minutesBefore = 15;
              } else if (r == tr('30_min_before')) {
                minutesBefore = 30;
              } else if (r == tr('1_hour_before')) {
                minutesBefore = 60;
              } else if (r == tr('day_before') || r == tr('1_day_before')) {
                minutesBefore = 1440;
              } else if (r == tr('1_week_before')) {
                minutesBefore = 10080;
              } else {
                final numMatch = RegExp(r'(\d+)').firstMatch(r);
                if (numMatch != null) minutesBefore = int.tryParse(numMatch.group(1)!) ?? 15;
              }
              await NotificationService.scheduleEventReminder(
                id: baseId,
                title: event.title,
                eventTime: event.startTime,
                minutesBefore: minutesBefore,
                alertType: alertType,
              );
              scheduled++;
              continue;
            }

            // 2) Fallback: global alertMinutesBefore from CalendarSettings
            for (int i = 0; i < calSettings.alertMinutesBefore.length; i++) {
              final mins = calSettings.alertMinutesBefore[i];
              await NotificationService.scheduleEventReminder(
                id: baseId + i + 1,
                title: event.title,
                eventTime: event.startTime,
                minutesBefore: mins,
                alertType: alertType,
              );
            }
            scheduled++;
          }
        }
        debugPrint('BootReschedule: rescheduled $scheduled events after reboot');
      }
    } catch (e) {
      debugPrint('BootReschedule error: $e');
    }
  }

  Future<void> _checkAutoBackup() async {
    try {
      final db = DatabaseHelper();
      final mode = await db.getSetting('auto_backup_mode');
      if (mode == null || mode == 'off') return;

      final lastDateStr = await db.getSetting('last_backup_date');
      final now = DateTime.now();

      if (lastDateStr != null) {
        final lastDate = DateTime.parse(lastDateStr);
        final diff = now.difference(lastDate);
        final shouldBackup = switch (mode) {
          'daily' => diff.inHours >= 24,
          'weekly' => diff.inDays >= 7,
          'monthly' => diff.inDays >= 30,
          _ => false,
        };
        if (!shouldBackup) return;
      }

      // Perform backup silently
      final dest = await db.getSetting('backup_destination');
      if (dest == 'drive') {
        await _autoBackupToDrive();
      } else {
        await _autoBackupToDevice();
      }
    } catch (e) {
      if (kDebugMode) debugPrint('Auto-backup error: $e');
    }
  }

  Future<Uint8List> _buildAutoBackupZipBytes() async {
    final dbPath = await getDatabasesPath();
    final sourcePath = p.join(dbPath, 'ethos_note.db');
    final sourceFile = File(sourcePath);

    // Flush WAL data into the main DB file before reading
    final db = await DatabaseHelper().database;
    await db.rawQuery('PRAGMA wal_checkpoint(TRUNCATE)');

    final zip = archive.Archive();

    final dbBytes = await sourceFile.readAsBytes();
    zip.addFile(archive.ArchiveFile('ethos_note.db', dbBytes.length, dbBytes));

    final imgDir = await ImageStorageHelper().imagesDir;
    if (await imgDir.exists()) {
      await for (final entity in imgDir.list()) {
        if (entity is File) {
          final fileName = p.basename(entity.path);
          final fileBytes = await entity.readAsBytes();
          zip.addFile(archive.ArchiveFile('images/$fileName', fileBytes.length, fileBytes));
        }
      }
    }

    return Uint8List.fromList(archive.ZipEncoder().encode(zip));
  }

  Future<void> _autoBackupToDrive() async {
    try {
      // Try silent sign-in only — no interactive prompt for auto-backup
      if (!GoogleCalendarService.isSignedIn) {
        final ok = await GoogleCalendarService.trySilentSignIn();
        if (!ok) return;
      }

      final driveApi = await GoogleCalendarService.getDriveApi();
      if (driveApi == null) return;

      final zipBytes = await _buildAutoBackupZipBytes();

      final now = DateTime.now();
      final fileName = 'ethos_note_backup_${now.year}${now.month.toString().padLeft(2, '0')}${now.day.toString().padLeft(2, '0')}_${now.hour.toString().padLeft(2, '0')}${now.minute.toString().padLeft(2, '0')}.zip';

      final driveFile = gdrive.File()
        ..name = fileName
        ..parents = ['appDataFolder'];

      await driveApi.files.create(
        driveFile,
        uploadMedia: gdrive.Media(
          Stream.value(zipBytes),
          zipBytes.length,
        ),
      );

      // Cleanup old backups
      try {
        final fileList = await driveApi.files.list(
          spaces: 'appDataFolder',
          q: "name contains 'ethos_note_backup'",
          orderBy: 'createdTime desc',
          pageSize: 20,
          $fields: 'files(id)',
        );
        if (fileList.files != null && fileList.files!.length > 5) {
          for (var i = 5; i < fileList.files!.length; i++) {
            final fileId = fileList.files![i].id;
            if (fileId != null) await driveApi.files.delete(fileId);
          }
        }
      } catch (_) {}

      await DatabaseHelper().saveSetting('last_backup_date', now.toIso8601String());
      if (kDebugMode) debugPrint('Auto-backup to Drive completed');
    } catch (e) {
      if (kDebugMode) debugPrint('Auto-backup to Drive error: $e');
    }
  }

  Future<void> _autoBackupToDevice() async {
    try {
      final zipBytes = await _buildAutoBackupZipBytes();

      final appDir = await getApplicationDocumentsDirectory();
      final backupDir = Directory(p.join(appDir.path, 'backups'));
      if (!await backupDir.exists()) {
        await backupDir.create(recursive: true);
      }

      final now = DateTime.now();
      final fileName = 'ethos_note_backup_${now.year}${now.month.toString().padLeft(2, '0')}${now.day.toString().padLeft(2, '0')}_${now.hour.toString().padLeft(2, '0')}${now.minute.toString().padLeft(2, '0')}.zip';

      await File(p.join(backupDir.path, fileName)).writeAsBytes(zipBytes);

      // Keep only last 5 backups
      final files = await backupDir.list().where((e) => e is File && e.path.endsWith('.zip')).toList();
      if (files.length > 5) {
        files.sort((a, b) => b.path.compareTo(a.path));
        for (var i = 5; i < files.length; i++) {
          await files[i].delete();
        }
      }

      await DatabaseHelper().saveSetting('last_backup_date', now.toIso8601String());
      if (kDebugMode) debugPrint('Auto-backup to device completed');
    } catch (e) {
      if (kDebugMode) debugPrint('Auto-backup to device error: $e');
    }
  }

  void _openSettings() {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => SettingsPage(
          userProfile: _userProfile,
          themeMode: widget.themeMode,
          onThemeModeChanged: widget.onThemeModeChanged,
          onLocaleChanged: widget.onLocaleChanged,
          onSave: (profile) {
            setState(() {
              _userProfile = profile;
            });
            _saveUserProfile();
          },
        ),
      ),
    ).then((_) {
      // Refresh pages when returning from settings
      _checkCycleDiaryBadge();
      setState(() => _refreshKey++);
    });
  }

  // Section accent colors — original
  static const _sectionColorsDefault = [
    Color(0xFFE53935), // Deep Note - red
    Color(0xFF1E88E5), // Calendar - blue
    Color(0xFFFFA726), // Flash Notes - amber
  ];
  // Ethos Bordeaux family (brightened for dark-mode contrast)
  static const _sectionColorsEthos = [
    Color(0xFFC0364D), // Deep Note  — bordeaux luminoso
    Color(0xFFA3274F), // Calendario — bordeaux chiaro
    Color(0xFFB8566B), // Flash Notes — rosé caldo
  ];
  // Ephemera warm leather family
  static const _sectionColorsEphemera = [
    Color(0xFF6D4C41), Color(0xFF795548), Color(0xFF8D6E63),
  ];
  static const _sectionColorsNordic = [
    Color(0xFF607D8B), Color(0xFF78909C), Color(0xFF90A4AE),
  ];
  static const _sectionColorsSalvia = [
    Color(0xFF5B7F61), Color(0xFF6B8F71), Color(0xFF8BAF90),
  ];
  static const _sectionColorsSakura = [
    Color(0xFFA36B74), Color(0xFFB5838D), Color(0xFFC89FA6),
  ];
  // Oltre l'Oceano
  static const _sectionColorsSpadaccino = [
    Color(0xFF2E7D5B), Color(0xFF1B4D3E), Color(0xFF4CAF50),
  ];
  static const _sectionColorsSognoRe = [
    Color(0xFFC62828), Color(0xFFD32F2F), Color(0xFFEF5350),
  ];
  static const _sectionColorsMappaT = [
    Color(0xFFFFD700), Color(0xFFE6A800), Color(0xFFFFB300),
  ];
  // Spirito della Foglia
  static const _sectionColorsFulmine = [
    Color(0xFF651FFF), Color(0xFF7C4DFF), Color(0xFFB388FF),
  ];
  static const _sectionColorsEremita = [
    Color(0xFFE65100), Color(0xFF00BCD4), Color(0xFFFF6D00),
  ];
  static const _sectionColorsSaggio = [
    Color(0xFF8B1A1A), Color(0xFF691212), Color(0xFF6B8E23),
  ];
  // Serie Cult
  static const _sectionColorsCabina = [
    Color(0xFF1565C0), Color(0xFF003B6F), Color(0xFF90CAF9),
  ];
  static const _sectionColorsSottosopra = [
    Color(0xFFD50000), Color(0xFFB71C1C), Color(0xFFFF1744),
  ];
  static const _sectionColorsRifugio = [
    Color(0xFF32CD32), Color(0xFF005FB8), Color(0xFFFFEB3B),
  ];

  static const _sectionColorsMap = <String, List<Color>>{
    'ethos': _sectionColorsEthos,
    'ephemera': _sectionColorsEphemera,
    'nordic_zen': _sectionColorsNordic,
    'green_salvia': _sectionColorsSalvia,
    'sakura': _sectionColorsSakura,
    'spadaccino': _sectionColorsSpadaccino,
    'sogno_re': _sectionColorsSognoRe,
    'mappa_tesoro': _sectionColorsMappaT,
    'fulmine': _sectionColorsFulmine,
    'eremita': _sectionColorsEremita,
    'saggio': _sectionColorsSaggio,
    'cabina_tempo': _sectionColorsCabina,
    'sottosopra': _sectionColorsSottosopra,
    'rifugio': _sectionColorsRifugio,
  };

  List<Color> get _sectionColors =>
      _sectionColorsMap[widget.themeMode] ?? _sectionColorsDefault;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final accentColor = _sectionColors[_selectedIndex];

    // Resolve pending deep link parameters
    String? flashInitialMode;
    DateTime? calendarInitialDate;
    String? calendarInitialAction;
    if (_pendingDeepLink != null) {
      final dl = _pendingDeepLink!;
      _pendingDeepLink = null;
      if (dl.startsWith('flashnote/')) {
        flashInitialMode = dl.substring('flashnote/'.length);
      } else if (dl == 'calendar/new') {
        calendarInitialAction = 'new';
      } else if (dl.startsWith('calendar/')) {
        final dateStr = dl.substring('calendar/'.length);
        final parts = dateStr.split('-');
        if (parts.length == 3) {
          calendarInitialDate = DateTime(
            int.tryParse(parts[0]) ?? DateTime.now().year,
            int.tryParse(parts[1]) ?? DateTime.now().month,
            int.tryParse(parts[2]) ?? DateTime.now().day,
          );
        }
      }
    }

    final pages = [
      const NotesProPage(),
      CalendarPage(key: ValueKey('cal_$_refreshKey'), initialDate: calendarInitialDate, initialAction: calendarInitialAction),
      FlashNotesPage(key: ValueKey('flash_$_refreshKey'), initialMode: flashInitialMode),
    ];

    return Scaffold(
      appBar: AppBar(
        leading: Padding(
          padding: const EdgeInsets.all(8.0),
          child: GestureDetector(
            onTap: _openSettings,
            child: CircleAvatar(
              backgroundColor: _userProfile.photoBytes != null
                  ? accentColor.withValues(alpha: 0.12)
                  : Colors.transparent,
              backgroundImage: _userProfile.photoBytes != null
                  ? MemoryImage(_userProfile.photoBytes!)
                  : null,
              child: _userProfile.photoBytes == null
                  ? ClipOval(child: Image.asset('assets/logo.png', width: 40, height: 40, fit: BoxFit.cover))
                  : null,
            ),
          ),
        ),
        title: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('Ethos Note', style: TextStyle(fontFamily: _themedFont(context), color: _hasCustomTheme(context) ? Theme.of(context).colorScheme.primary : null)),
            const SizedBox(width: 8),
            if (_selectedIndex == 1) _CalendarIcon9(size: 22, color: _sectionColors[1])
            else Icon(
              _selectedIndex == 0 ? Icons.note : Icons.flash_on,
              size: 22,
              color: _sectionColors[_selectedIndex],
            ),
          ],
        ),
        scrolledUnderElevation: 2,
      ),
      body: Column(
        children: [
          if (_connectivityStatus.contains(ConnectivityResult.none))
            Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 16),
              color: Theme.of(context).colorScheme.errorContainer,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.wifi_off, size: 16, color: Theme.of(context).colorScheme.onErrorContainer),
                  const SizedBox(width: 8),
                  Text(tr('offline_mode'), style: TextStyle(fontSize: 13, color: Theme.of(context).colorScheme.onErrorContainer)),
                ],
              ),
            ),
          Expanded(
            child: AnimatedSwitcher(
              duration: const Duration(milliseconds: 300),
              switchInCurve: Curves.easeInOut,
              switchOutCurve: Curves.easeInOut,
              transitionBuilder: (child, animation) {
                return FadeTransition(opacity: animation, child: child);
              },
              child: KeyedSubtree(
                key: ValueKey<String>('${_selectedIndex}_$_refreshKey'),
                child: pages[_selectedIndex],
              ),
            ),
          ),
        ],
      ),
      bottomNavigationBar: NavigationBar(
        selectedIndex: _selectedIndex,
        onDestinationSelected: (index) async {
          // Check biometric lock for Deep Note (index 0) or Flash Notes (index 2)
          if ((index == 0 && _userProfile.lockDeepNote) || (index == 2 && _userProfile.lockFlashNotes)) {
            final localAuth = LocalAuthentication();
            try {
              final authenticated = await localAuth.authenticate(
                localizedReason: tr('auth_to_access'),
                options: const AuthenticationOptions(biometricOnly: false),
              );
              if (!authenticated) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(tr('auth_failed')),
                      behavior: SnackBarBehavior.floating,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                  );
                }
                return;
              }
            } catch (_) {
              return;
            }
          }
          _checkCycleDiaryBadge();
          setState(() {
            _selectedIndex = index;
          });
          if (index == 1) {
            _calIconController.forward();
          } else {
            _calIconController.reverse();
          }
        },
        destinations: [
          NavigationDestination(
            icon: Badge(
              isLabelVisible: _cycleDiaryActive,
              backgroundColor: Colors.red,
              smallSize: 8,
              child: Icon(Icons.note_outlined, color: colorScheme.onSurfaceVariant),
            ),
            selectedIcon: Badge(
              isLabelVisible: _cycleDiaryActive,
              backgroundColor: Colors.red,
              smallSize: 8,
              child: Icon(Icons.note, color: _sectionColors[0]),
            ),
            label: 'Deep Note',
          ),
          NavigationDestination(
            icon: _AnimatedCalendarIcon9(
              animation: _calIconController,
              size: 24,
              unselectedColor: colorScheme.onSurfaceVariant,
              selectedColor: _sectionColors[1],
            ),
            label: tr('calendar'),
          ),
          NavigationDestination(
            icon: Icon(Icons.flash_on_outlined, color: colorScheme.onSurfaceVariant),
            selectedIcon: Icon(Icons.flash_on, color: _sectionColors[2]),
            label: 'Flash Notes',
          ),
        ],
      ),
    );
  }
}

class CalendarPage extends StatefulWidget {
  final DateTime? initialDate;
  final String? initialAction;
  const CalendarPage({super.key, this.initialDate, this.initialAction});

  @override
  State<CalendarPage> createState() => _CalendarPageState();
}

class _CalendarPageState extends State<CalendarPage> {
  DateTime _focusedDay = DateTime.now();
  DateTime? _selectedDay;
  Map<String, List<CalendarEventFull>> _events = {};
  late Map<String, List<Holiday>> _holidays;
  CalendarSettings _calSettings = const CalendarSettings();

  // Weather
  WeatherData? _weatherData;
  bool _isLoadingWeather = false;

  // Cycle tracking (private)
  Set<String> _cycleDays = {};
  Map<String, String> _cycleDaysIntensity = {};
  EthosAuraSettings _auraSettings = const EthosAuraSettings();

  // Split layout: calendar compression on scroll
  bool _isCalendarCompact = false;
  bool _compactCooldown = false;
  final ScrollController _eventsScrollController = ScrollController();

  // Google Calendar
  Map<String, List<CalendarEventFull>> _googleEvents = {};
  Set<String> _completedGoogleEventIds = {};
  // Track locally-deleted events so matching Google duplicates stay hidden
  final Set<String> _deletedEventSignatures = {};
  // Only reschedule all notifications once per session
  static bool _notificationsInitialized = false;

  // Health
  HealthSnapshot? _healthSnapshot;


  @override
  void initState() {
    super.initState();
    if (widget.initialDate != null) {
      _focusedDay = widget.initialDate!;
    }
    _selectedDay = _focusedDay;
    _holidays = _calSettings.showHolidays ? Holidays.getHolidays(_calSettings.religione) : {};
    _initNotificationsAndEvents();
    _loadAuraSettings();
    _loadCycleDays();
    _loadCompletedGoogleEventIds();
    _initGoogleCalendar();
    _initHealth();
    _eventsScrollController.addListener(_onEventsScroll);
    // Handle deep link action (e.g. create new event)
    if (widget.initialAction == 'new') {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) _createEvent();
      });
    }
  }

  /// Ensures permissions + settings are loaded BEFORE scheduling notifications.
  Future<void> _initNotificationsAndEvents() async {
    // 1) Load calendar settings first (needed for alertMinutesBefore / alertType)
    final settings = await CalendarSettings.load();
    if (!mounted) return;
    setState(() {
      _calSettings = settings;
      _holidays = settings.showHolidays ? Holidays.getHolidays(settings.religione) : {};
    });
    if (settings.showWeather && settings.weatherCity != null && settings.weatherCity!.isNotEmpty) {
      _loadWeather();
    }

    // 2) Request notification permissions and wait for result
    await NotificationService.ensurePermissions();

    // 2b) Request battery optimization exemption (Samsung kills background alarms)
    final batteryOk = await NotificationService.isIgnoringBatteryOptimizations();
    if (!batteryOk) {
      await NotificationService.requestIgnoreBatteryOptimization();
    }

    // 3) Now load events and schedule notifications (settings + permissions are ready)
    await _loadEvents();

    // 4) Schedule cycle reminder
    _scheduleCycleReminder();
  }

  Future<void> _loadAuraSettings() async {
    final s = await EthosAuraSettings.load();
    if (!mounted) return;
    setState(() => _auraSettings = s);
  }

  void _onEventsScroll() {
    if (!_eventsScrollController.hasClients) return;
    final offset = _eventsScrollController.offset;
    final maxExtent = _eventsScrollController.position.maxScrollExtent;
    if (offset > 30 && !_isCalendarCompact) {
      setState(() => _isCalendarCompact = true);
      _compactCooldown = true;
      Future.delayed(const Duration(milliseconds: 800), () {
        if (mounted) _compactCooldown = false;
      });
    } else if (offset <= 5 && _isCalendarCompact && !_compactCooldown && maxExtent > 60) {
      setState(() => _isCalendarCompact = false);
    }
  }

  @override
  void dispose() {
    _eventsScrollController.removeListener(_onEventsScroll);
    _eventsScrollController.dispose();
    super.dispose();
  }

  Future<void> _loadCycleDays() async {
    final days = await DatabaseHelper().getCycleDays();
    final intensityMap = await DatabaseHelper().getCycleDaysWithIntensity();
    if (!mounted) return;
    setState(() {
      _cycleDays = days;
      _cycleDaysIntensity = intensityMap;
    });
    _scheduleCycleReminder();
    _checkAndCreateCycleDiary();
  }

  Future<void> _loadCompletedGoogleEventIds() async {
    final cached = await DatabaseHelper().getCache('completed_google_events');
    if (cached != null && cached.isNotEmpty && mounted) {
      setState(() {
        _completedGoogleEventIds = Set<String>.from(json.decode(cached) as List);
      });
    }
  }

  Future<void> _saveCompletedGoogleEventIds() async {
    await DatabaseHelper().saveCache(
      'completed_google_events',
      json.encode(_completedGoogleEventIds.toList()),
    );
  }

  Future<void> _toggleCycleDay(DateTime day, {String intensity = 'medium'}) async {
    final key = '${day.year}-${day.month}-${day.day}';
    final adding = !_cycleDays.contains(key);
    setState(() {
      if (adding) {
        _cycleDays.add(key);
        _cycleDaysIntensity[key] = intensity;
      } else {
        _cycleDays.remove(key);
        _cycleDaysIntensity.remove(key);
      }
    });
    if (adding) {
      await DatabaseHelper().addCycleDay(key, intensity: intensity);
    } else {
      await DatabaseHelper().removeCycleDay(key);
    }
    // Sync to Apple Health / Health Connect
    if (adding && HealthService.isAuthorized) {
      HealthService.writeMenstruationFlow(day);
    }
    _scheduleCycleReminder();
  }

  Future<void> _setCycleDayIntensity(DateTime day, String intensity) async {
    final key = '${day.year}-${day.month}-${day.day}';
    setState(() => _cycleDaysIntensity[key] = intensity);
    await DatabaseHelper().updateCycleDayIntensity(key, intensity);
  }

  void _showIntensityPicker(BuildContext context, DateTime day, {VoidCallback? onChanged}) {
    final colorScheme = Theme.of(context).colorScheme;
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (ctx) {
        final intensities = ['light', 'medium', 'heavy', 'very_heavy'];
        final labels = [tr('flow_light'), tr('flow_medium'), tr('flow_heavy'), tr('flow_very_heavy')];
        final droplets = ['💧', '💧💧', '💧💧💧', '💧💧💧💧'];
        final currentIntensity = _getCycleIntensity(day);
        return Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(tr('flow_intensity'), style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: colorScheme.onSurface)),
              const SizedBox(height: 16),
              ...List.generate(4, (i) => ListTile(
                leading: Text(droplets[i], style: const TextStyle(fontSize: 18)),
                title: Text(labels[i]),
                trailing: currentIntensity == intensities[i] ? Icon(Icons.check_circle, color: Colors.red.shade400) : null,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                selectedTileColor: Colors.red.shade50,
                selected: currentIntensity == intensities[i],
                onTap: () {
                  _setCycleDayIntensity(day, intensities[i]);
                  Navigator.pop(ctx);
                  onChanged?.call();
                },
              )),
              const SizedBox(height: 8),
            ],
          ),
        );
      },
    );
  }

  bool _isCycleDay(DateTime day) {
    return _cycleDays.contains('${day.year}-${day.month}-${day.day}');
  }

  String _getCycleIntensity(DateTime day) {
    final key = '${day.year}-${day.month}-${day.day}';
    return _cycleDaysIntensity[key] ?? 'medium';
  }

  String _intensityDroplets(String intensity) {
    switch (intensity) {
      case 'light': return '💧';
      case 'medium': return '💧💧';
      case 'heavy': return '💧💧💧';
      case 'very_heavy': return '💧💧💧💧';
      default: return '💧💧';
    }
  }

  double _intensityFontSize(String intensity, double baseSize) {
    switch (intensity) {
      case 'light': return baseSize * 0.8;
      case 'heavy': return baseSize * 1.1;
      case 'very_heavy': return baseSize * 1.3;
      default: return baseSize;
    }
  }

  /// Groups cycle days into consecutive periods (gap ≤ 1 day).
  /// Returns list of (start, end) sorted chronologically.
  List<(DateTime, DateTime)> _findCyclePeriods() {
    if (_cycleDays.isEmpty) return [];
    final dates = <DateTime>[];
    for (final k in _cycleDays) {
      final parts = k.split('-');
      if (parts.length == 3) {
        dates.add(DateTime(int.parse(parts[0]), int.parse(parts[1]), int.parse(parts[2])));
      }
    }
    if (dates.isEmpty) return [];
    dates.sort();
    final periods = <(DateTime, DateTime)>[];
    var start = dates.first;
    var end = dates.first;
    for (int i = 1; i < dates.length; i++) {
      if (dates[i].difference(end).inDays <= 1) {
        end = dates[i];
      } else {
        periods.add((start, end));
        start = dates[i];
        end = dates[i];
      }
    }
    periods.add((start, end));
    return periods;
  }

  /// Calculates the next predicted cycle start date.
  /// Uses manual date if set and no cycle data, otherwise calculates from periods.
  DateTime? _getNextPredictedCycleStart() {
    final periods = _findCyclePeriods();
    final cyclePeriod = _calSettings.cyclePeriodDays;
    final now = DateTime.now();
    final todayNorm = DateTime(now.year, now.month, now.day);

    if (periods.isEmpty) {
      // Use manual date if available
      if (_calSettings.manualNextCycleDate != null) {
        final manual = DateTime.tryParse(_calSettings.manualNextCycleDate!);
        if (manual != null) {
          var predicted = DateTime(manual.year, manual.month, manual.day);
          while (predicted.isBefore(todayNorm)) {
            predicted = predicted.add(Duration(days: cyclePeriod));
          }
          return predicted;
        }
      }
      return null;
    }

    final lastStart = periods.last.$1;
    var predicted = lastStart.add(Duration(days: cyclePeriod));
    while (predicted.isBefore(todayNorm)) {
      predicted = predicted.add(Duration(days: cyclePeriod));
    }
    return predicted;
  }

  bool _isPredictedCycleDay(DateTime day) {
    if (!_auraSettings.cycleTrackingPurchased || !_calSettings.showCycleTracking) return false;
    if (_isCycleDay(day)) return false;
    final cyclePeriod = _calSettings.cyclePeriodDays;
    final duration = _calSettings.cycleDurationDays;
    final dayNorm = DateTime(day.year, day.month, day.day);
    final periods = _findCyclePeriods();

    DateTime? baseStart;
    if (periods.isNotEmpty) {
      baseStart = periods.last.$1;
    } else if (_calSettings.manualNextCycleDate != null) {
      // Use manual date as the first predicted start (c=0)
      final manual = DateTime.tryParse(_calSettings.manualNextCycleDate!);
      if (manual != null) {
        final manualNorm = DateTime(manual.year, manual.month, manual.day);
        // Check if day falls in the manual period itself
        final diff0 = dayNorm.difference(manualNorm).inDays;
        if (diff0 >= 0 && diff0 < duration) return true;
        baseStart = manualNorm;
      }
    }
    if (baseStart == null) return false;

    for (int c = 1; c <= 3; c++) {
      final predictedStart = baseStart.add(Duration(days: cyclePeriod * c));
      final diff = dayNorm.difference(predictedStart).inDays;
      if (diff >= 0 && diff < duration) return true;
    }
    return false;
  }

  Future<void> _initGoogleCalendar() async {
    final signedIn = await GoogleCalendarService.trySilentSignIn();
    if (signedIn) {
      _fetchGoogleEvents();
    }
  }

  Future<void> _fetchGoogleEvents() async {
    if (!GoogleCalendarService.isSignedIn) return;
    // Fetch 3 months of events
    final start = DateTime(_focusedDay.year, _focusedDay.month - 1, 1);
    final end = DateTime(_focusedDay.year, _focusedDay.month + 2, 0);
    final events = await GoogleCalendarService.fetchEvents(start, end);
    final Map<String, List<CalendarEventFull>> mapped = {};
    for (final e in events) {
      final key = _dateKey(e.startTime);
      mapped.putIfAbsent(key, () => []).add(e);
    }
    if (mounted) {
      setState(() {
        _googleEvents = mapped;
      });
      // Google events are scheduled via _rescheduleAllNotifications() —
      // no separate loop here to avoid duplicate notifications.
    }
  }

  Future<void> _pushEventToGoogle(CalendarEventFull event) async {
    if (!GoogleCalendarService.isSignedIn) return;
    final success = await GoogleCalendarService.pushEvent(event);
    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('event_saved')} - ${event.title}'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          duration: const Duration(seconds: 2),
        ),
      );
      _fetchGoogleEvents();
    }
  }

  Future<void> _initHealth() async {
    if (!HealthService.isSupported) {
      // On web / unsupported platforms, load demo health data
      if (mounted) {
        setState(() => _healthSnapshot = HealthSnapshot(
          steps: 6320,
          heartRate: 72,
          calories: 1450,
          weight: 70,
          bloodOxygen: 98,
          waterLiters: 1.2,
          fetchedAt: DateTime.now(),
        ));
      }
      return;
    }
    await HealthService.checkAuthorization();
    if (HealthService.isAuthorized) {
      await _refreshHealth();
      // If data came back empty, try clearing cache and re-fetching
      if (_healthSnapshot != null && !_healthSnapshot!.hasData) {
        await DatabaseHelper().saveCache('health_snapshot', '');
        await _refreshHealth();
      }
    }
  }

  Future<void> _refreshHealth() async {
    final snapshot = await HealthService.fetchTodayData();
    if (mounted) {
      setState(() => _healthSnapshot = snapshot);
    }
  }

  Widget _buildCycleFlowBar(DateTime day) {
    final intensity = _getCycleIntensity(day);
    final double progress;
    final String label;
    switch (intensity) {
      case 'light':
        progress = 0.25;
        label = 'Leggero';
      case 'heavy':
        progress = 0.75;
        label = 'Forte';
      case 'very_heavy':
        progress = 1.0;
        label = 'Molto forte';
      default:
        progress = 0.50;
        label = 'Medio';
    }
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: Row(
        children: [
          const Icon(Icons.water_drop, color: Colors.red, size: 16),
          const SizedBox(width: 6),
          Text(label, style: const TextStyle(fontSize: 11, fontWeight: FontWeight.w600, color: Colors.red)),
          const SizedBox(width: 8),
          Expanded(
            child: ClipRRect(
              borderRadius: BorderRadius.circular(3),
              child: LinearProgressIndicator(
                value: progress,
                minHeight: 3,
                backgroundColor: Colors.red.withValues(alpha: 0.12),
                valueColor: const AlwaysStoppedAnimation<Color>(Colors.red),
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _scheduleCycleReminder() {
    if (!_auraSettings.cycleTrackingPurchased || !_calSettings.showCycleTracking || !_calSettings.cycleReminder) {
      NotificationService.cancelCycleReminder();
      return;
    }
    final nextStart = _getNextPredictedCycleStart();
    if (nextStart == null) {
      NotificationService.cancelCycleReminder();
      return;
    }
    final alertType = _calSettings.alertConfig.alertType;
    NotificationService.scheduleCycleReminder(nextStart, alertType: alertType);
  }

  Future<void> _checkAndCreateCycleDiary() async {
    if (!_auraSettings.cycleTrackingPurchased || !_calSettings.showCycleTracking) return;
    final now = DateTime.now();
    final todayNorm = DateTime(now.year, now.month, now.day);
    final months = localizedMonths();

    // 1) Check if a tracked period has ended (≥1 day gap)
    final periods = _findCyclePeriods();
    if (periods.isNotEmpty) {
      final (start, end) = periods.last;
      final daysSinceEnd = todayNorm.difference(end).inDays;
      if (daysSinceEnd >= 1) {
        final doneKey = 'cycle_diary_done_${start.year}-${start.month}-${start.day}';
        final done = await DatabaseHelper().getCache(doneKey);
        if (done == null) {
          // Create report note in Diario del Ciclo
          final month = months[end.month] ?? '';
          await _createCycleDiaryNote(
            title: '${tr('cycle_report')} $month',
            type: 'cycle_diary',
            periodStart: '${start.year}-${start.month}-${start.day}',
            periodEnd: '${end.year}-${end.month}-${end.day}',
            month: month,
          );
          await DatabaseHelper().saveCache(doneKey, 'done');
          await DatabaseHelper().saveCache('cycle_diary_active', DateTime.now().toIso8601String());
          // Schedule notification immediately (for today at 9:00 or now if past 9)
          final notifTime = DateTime(now.year, now.month, now.day, 9, 0);
          if (notifTime.isAfter(now)) {
            NotificationService.scheduleCycleDiaryNotification(notifTime, alertType: _calSettings.alertConfig.alertType);
          } else {
            NotificationService.showCycleDiaryNotification(alertType: _calSettings.alertConfig.alertType);
          }
        }
      }
    }

    // 2) Check if predicted cycle passed without marking
    final nextPredicted = _getNextPredictedCycleStart();
    if (nextPredicted != null && periods.isNotEmpty) {
      // Only check if prediction is based on actual data (not manual) and the predicted END has passed
      final predictedEnd = nextPredicted.add(Duration(days: _calSettings.cycleDurationDays - 1));
      if (todayNorm.isAfter(predictedEnd)) {
        // Check if any cycle days were marked in the predicted window
        bool markedInWindow = false;
        for (final k in _cycleDays) {
          final parts = k.split('-');
          if (parts.length == 3) {
            final d = DateTime(int.parse(parts[0]), int.parse(parts[1]), int.parse(parts[2]));
            if (!d.isBefore(nextPredicted) && !d.isAfter(predictedEnd)) {
              markedInWindow = true;
              break;
            }
          }
        }
        if (!markedInWindow) {
          final missKey = 'cycle_missing_${nextPredicted.year}-${nextPredicted.month}-${nextPredicted.day}';
          final missDone = await DatabaseHelper().getCache(missKey);
          if (missDone == null) {
            final month = months[nextPredicted.month] ?? '';
            await _createCycleDiaryNote(
              title: '${tr('cycle_missing')} $month',
              type: 'cycle_missing',
              periodStart: '',
              periodEnd: '',
              month: month,
            );
            await DatabaseHelper().saveCache(missKey, 'done');
            await DatabaseHelper().saveCache('cycle_diary_active', DateTime.now().toIso8601String());
            NotificationService.showCycleDiaryNotification(alertType: _calSettings.alertConfig.alertType);
          }
        }
      }
    }

    // 3) Auto-expire badge after 1 day
    final badgeJson = await DatabaseHelper().getCache('cycle_diary_active');
    if (badgeJson != null && badgeJson.isNotEmpty) {
      final badgeTime = DateTime.tryParse(badgeJson);
      if (badgeTime != null && todayNorm.difference(DateTime(badgeTime.year, badgeTime.month, badgeTime.day)).inDays >= 1) {
        await DatabaseHelper().deleteCache('cycle_diary_active');
      }
    }
  }

  Future<void> _ensureCycleDiaryFolder() async {
    final customFolders = await DatabaseHelper().getAllFolders();
    const folderName = 'Diario del Ciclo';
    if (!customFolders.containsKey(folderName)) {
      customFolders[folderName] = const FolderStyle(Icons.water_drop, Colors.red, isCustom: true);
      await DatabaseHelper().saveAllFolders(customFolders);
    }
  }

  Future<void> _createCycleDiaryNote({
    required String title,
    required String type,
    required String periodStart,
    required String periodEnd,
    required String month,
  }) async {
    await _ensureCycleDiaryFolder();
    final data = <String, dynamic>{
      'type': type,
      'periodStart': periodStart,
      'periodEnd': periodEnd,
      'month': month,
      'timing': null,
      'flow': null,
      'symptoms': <String>[],
      'energy': null,
      'cravings': <String>[],
      'cravingsCustom': '',
      'sleep': null,
      'sleepCustom': '',
      'emotions': <String>[],
      'emotionsCustom': '',
      'notes': '',
      // For cycle_missing type
      'missingReason': null,
      'missingReasonCustom': '',
    };
    final note = ProNote(
      title: title,
      content: title,
      contentDelta: json.encode(data),
      folder: 'Diario del Ciclo',
      createdAt: DateTime.now(),
    );
    await DatabaseHelper().insertProNote(note);
  }

  /// Build plain-text summary from cycle diary data (for PDF/content field).
  static String buildCycleDiaryPlainText(Map<String, dynamic> data) {
    final buf = StringBuffer();
    final type = data['type'] as String? ?? 'cycle_diary';
    final month = data['month'] as String? ?? '';
    buf.writeln(type == 'cycle_missing' ? '${tr('cycle_missing')} $month' : '${tr('cycle_report')} $month');
    if (type == 'cycle_missing') {
      if (data['missingReason'] != null) buf.writeln('${tr('cycle_missing_why')}: ${data['missingReason']}');
      if ((data['missingReasonCustom'] as String?)?.isNotEmpty == true) buf.writeln('${data['missingReasonCustom']}');
      return buf.toString();
    }
    if (data['timing'] != null) buf.writeln('${tr('cycle_q_timing')}: ${data['timing']}');
    if (data['flow'] != null) buf.writeln('${tr('cycle_q_flow')}: ${data['flow']}');
    final symptoms = (data['symptoms'] as List?)?.cast<String>() ?? [];
    if (symptoms.isNotEmpty) buf.writeln('${tr('cycle_q_symptoms')}: ${symptoms.join(', ')}');
    if (data['energy'] != null) buf.writeln('${tr('cycle_q_energy')}: ${data['energy']}');
    final cravings = (data['cravings'] as List?)?.cast<String>() ?? [];
    if (cravings.isNotEmpty) buf.writeln('${tr('cycle_q_cravings')}: ${cravings.join(', ')}');
    if ((data['cravingsCustom'] as String?)?.isNotEmpty == true) buf.writeln('  ${data['cravingsCustom']}');
    if (data['sleep'] != null) buf.writeln('${tr('cycle_q_sleep')}: ${data['sleep']}');
    if ((data['sleepCustom'] as String?)?.isNotEmpty == true) buf.writeln('  ${data['sleepCustom']}');
    final emotions = (data['emotions'] as List?)?.cast<String>() ?? [];
    if (emotions.isNotEmpty) buf.writeln('${tr('cycle_q_emotions')}: ${emotions.join(', ')}');
    if ((data['emotionsCustom'] as String?)?.isNotEmpty == true) buf.writeln('  ${data['emotionsCustom']}');
    if ((data['notes'] as String?)?.isNotEmpty == true) buf.writeln('${tr('cycle_q_notes')}: ${data['notes']}');
    return buf.toString();
  }

  Future<void> _loadWeather() async {
    if (_isLoadingWeather) return;
    setState(() => _isLoadingWeather = true);
    try {
      final city = _calSettings.weatherCity;
      if (city != null && city.isNotEmpty) {
        // Try non-stale cache first
        final cached = await WeatherData.loadCached();
        if (cached != null && cached.city == city) {
          if (mounted) setState(() => _weatherData = cached);
        } else {
          // Use stored coordinates if available, otherwise geocode
          double? lat = _calSettings.weatherLat;
          double? lon = _calSettings.weatherLon;
          if (lat == null || lon == null) {
            final geo = await WeatherService.geocodeCity(city);
            if (geo != null) {
              lat = geo.lat;
              lon = geo.lon;
            }
          }
          if (lat != null && lon != null) {
            final data = await WeatherService.fetchWeather(city, lat, lon);
            if (mounted) setState(() => _weatherData = data);
          } else {
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('${tr('weather_city')}: "$city" ${tr('city_not_found')}'),
                  behavior: SnackBarBehavior.floating,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
              );
            }
          }
        }
      }
    } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
    if (mounted) setState(() => _isLoadingWeather = false);
  }

  Future<void> _loadEvents() async {
    final events = await DatabaseHelper().getAllEvents();
    if (!mounted) return;
    setState(() {
      _events = events;
    });
    // Re-schedule all future notifications on app start
    await _rescheduleAllNotifications();
  }

  Future<void> _rescheduleAllNotifications() async {
    // Only run once per app session to avoid cancelling active notifications
    if (_notificationsInitialized) {
      debugPrint('NotificationService: already initialized this session, skipping bulk reschedule');
      return;
    }
    _notificationsInitialized = true;
    // Cancel stale alarms from previous session before rescheduling
    try { await NotificationService.cancelAll(); } catch (_) {}
    final now = DateTime.now();
    int scheduled = 0;
    for (final dayEvents in _events.values) {
      for (final event in dayEvents) {
        if (event.startTime.isAfter(now)) {
          await _scheduleNotification(event, allowImmediate: false);
          scheduled++;
        }
      }
    }
    // Verify pending notifications
    try {
      final count = await NotificationService.pendingCount();
      debugPrint('NotificationService: rescheduled $scheduled events, $count pending notifications');
    } catch (e) {
      debugPrint('NotificationService: rescheduled $scheduled events (pending check failed: $e)');
    }
  }

  Future<void> _saveEvents() async {
    await DatabaseHelper().saveAllEvents(_events);
  }

  Future<void> _scheduleNotification(CalendarEventFull event, {bool allowImmediate = true}) async {
    final baseId = event.startTime.millisecondsSinceEpoch ~/ 1000;
    final alertType = _calSettings.alertConfig.alertType;
    debugPrint('_scheduleNotification: "${event.title}" at ${event.startTime}, reminder="${event.reminder}", alertType=$alertType, allowImmediate=$allowImmediate');

    // 1) Schedule from event-specific reminder (if set)
    if (event.reminder != null && event.reminder!.isNotEmpty) {
      final r = event.reminder!;
      int minutesBefore = 15;
      if (r == tr('10_min_before')) {
        minutesBefore = 10;
      } else if (r == tr('15_min_before')) {
        minutesBefore = 15;
      } else if (r == tr('30_min_before')) {
        minutesBefore = 30;
      } else if (r == tr('1_hour_before')) {
        minutesBefore = 60;
      } else if (r == tr('day_before') || r == tr('1_day_before')) {
        minutesBefore = 1440;
      } else if (r == tr('1_week_before')) {
        minutesBefore = 10080;
      } else {
        final numMatch = RegExp(r'(\d+)').firstMatch(r);
        if (numMatch != null) minutesBefore = int.tryParse(numMatch.group(1)!) ?? 15;
      }
      await NotificationService.scheduleEventReminder(
        id: baseId,
        title: event.title,
        eventTime: event.startTime,
        minutesBefore: minutesBefore,
        alertType: alertType,
        allowImmediate: allowImmediate,
      );
      return;
    }

    // 2) Fallback: use global alertMinutesBefore from CalendarSettings
    for (int i = 0; i < _calSettings.alertMinutesBefore.length; i++) {
      final mins = _calSettings.alertMinutesBefore[i];
      await NotificationService.scheduleEventReminder(
        id: baseId + i + 1,
        title: event.title,
        eventTime: event.startTime,
        minutesBefore: mins,
        alertType: alertType,
        allowImmediate: allowImmediate,
      );
    }
  }

  String _dateKey(DateTime date) => '${date.year}-${date.month}-${date.day}';

  List<CalendarEventFull> _getEventsForDay(DateTime day) {
    final local = _events[_dateKey(day)] ?? [];
    final google = _googleEvents[_dateKey(day)] ?? [];
    // Filter out Google events that duplicate a local event (same title + close startTime)
    // Also filter out events whose local counterpart was deleted this session
    final filtered = google.where((g) {
      // Duplicates a still-existing local event
      if (local.any((l) => l.title == g.title && l.startTime.difference(g.startTime).inMinutes.abs() < 2)) return false;
      // Was deleted locally (match within ±2 min)
      if (_deletedEventSignatures.any((sig) {
        final parts = sig.split('|');
        if (parts.length != 2) return false;
        final title = parts[0];
        final ms = int.tryParse(parts[1]);
        if (ms == null) return false;
        return title == g.title && (g.startTime.millisecondsSinceEpoch - ms).abs() < 120000;
      })) return false;
      return true;
    }).map((g) {
      // Apply persisted completion state for Google events
      if (g.googleEventId != null && _completedGoogleEventIds.contains(g.googleEventId)) {
        return g.copyWith(isCompleted: true);
      }
      return g;
    }).toList();
    return [...local, ...filtered];
  }

  void _createEvent() {
    if (_selectedDay == null) return;
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => EventEditorPage(
          selectedDate: _selectedDay!,
          onSave: (event) {
            // Build full list: base event + recurring instances
            final allEvents = <CalendarEventFull>[event];
            if (event.recurrence != null) {
              final duration = event.endTime.difference(event.startTime);
              DateTime nextStart = event.startTime;
              final effectiveEnd = event.recurrenceEndDate != null
                  ? DateTime.parse(event.recurrenceEndDate!)
                  : event.startTime.add(const Duration(days: 730));
              int count = 0;
              while (count < 730) {
                count++;
                switch (event.recurrence) {
                  case 'daily':
                    nextStart = nextStart.add(const Duration(days: 1));
                    break;
                  case 'weekly':
                    nextStart = nextStart.add(const Duration(days: 7));
                    break;
                  case 'monthly':
                    nextStart = DateTime(nextStart.year, nextStart.month + 1, nextStart.day, nextStart.hour, nextStart.minute);
                    break;
                  case 'yearly':
                    nextStart = DateTime(nextStart.year + 1, nextStart.month, nextStart.day, nextStart.hour, nextStart.minute);
                    break;
                  default:
                    count = 730;
                    continue;
                }
                if (nextStart.isAfter(effectiveEnd)) break;
                allEvents.add(CalendarEventFull(
                  title: event.title,
                  startTime: nextStart,
                  endTime: nextStart.add(duration),
                  calendar: event.calendar,
                  reminder: event.reminder,
                  sharedWith: event.sharedWith,
                  recurrence: event.recurrence,
                  recurrenceEndDate: event.recurrenceEndDate,
                ));
              }
            }
            // Single setState — add all events to correct dates
            setState(() {
              for (final e in allEvents) {
                final key = _dateKey(e.startTime);
                _events.putIfAbsent(key, () => []).add(e);
              }
            });
            // Single DB save, then schedule notifications
            _saveEvents().then((_) async {
              for (final e in allEvents) {
                await _scheduleNotification(e);
              }
              debugPrint('NotificationService: scheduled ${allEvents.length} notifications for "${event.title}"');
            });
            if (GoogleCalendarService.isSignedIn) {
              _pushEventToGoogle(event); // push base event only
            }
          },
        ),
      ),
    );
  }

  void _editEvent(DateTime day, int index) {
    final events = _getEventsForDay(day);
    if (index >= events.length) return;
    final event = events[index];
    final localEvents = _events[_dateKey(day)] ?? [];
    final isLocal = index < localEvents.length;
    if (!isLocal) {
      // Google Calendar event — read-only
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('edit')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
      return;
    }
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => EventEditorPage(
          selectedDate: day,
          existingEvent: event,
          onSave: (updatedEvent) {
            setState(() {
              final key = _dateKey(day);
              _events[key]?[index] = updatedEvent;
            });
            _saveEvents().then((_) async {
              await _scheduleNotification(updatedEvent);
              debugPrint('NotificationService: rescheduled notification for updated event "${updatedEvent.title}"');
            });
          },
        ),
      ),
    );
  }

  Future<void> _deleteEvent(int index) async {
    if (_selectedDay == null) return;
    final key = _dateKey(_selectedDay!);
    final localEvents = _events[key] ?? [];
    if (index < localEvents.length) {
      // Local event — ask confirmation
      final event = localEvents[index];
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('confirm_delete')),
          content: Text('${tr('delete')} "${event.title}"?'),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
            FilledButton(onPressed: () => Navigator.pop(ctx, true), child: Text(tr('delete'))),
          ],
        ),
      );
      if (confirmed != true || !mounted) return;
      // Move to trash if enabled
      final db = DatabaseHelper();
      final settings = await NoteProSettings.load();
      int? trashedId;
      if (settings.trashEnabled) {
        trashedId = await db.insertTrashedNote(TrashedNote(
          type: 'event',
          noteJson: event.toJson(),
          deletedAt: DateTime.now(),
        ));
      }
      final notifId = event.startTime.millisecondsSinceEpoch ~/ 1000;
      // Cancel all notification IDs (base for event-specific, base+i+1 for global alerts)
      NotificationService.cancelReminder(notifId);
      for (int i = 0; i < _calSettings.alertMinutesBefore.length; i++) {
        NotificationService.cancelReminder(notifId + i + 1);
      }
      // Remember signature so matching Google duplicate stays hidden
      final sig = '${event.title}|${event.startTime.millisecondsSinceEpoch}';
      _deletedEventSignatures.add(sig);
      if (!mounted) return;
      setState(() {
        _events[key]?.removeAt(index);
        if (_events[key]?.isEmpty ?? false) _events.remove(key);
      });
      await _saveEvents();
      if (!mounted) return;
      ScaffoldMessenger.of(context).clearSnackBars();
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(tr('event_deleted')),
        action: SnackBarAction(
          label: tr('undo'),
          onPressed: () async {
            _deletedEventSignatures.remove(sig);
            setState(() {
              _events.putIfAbsent(key, () => []).insert(index.clamp(0, (_events[key]?.length ?? 0)), event);
            });
            await _saveEvents();
            if (trashedId != null) {
              await db.deleteTrashedNote(trashedId);
            }
            _scheduleNotification(event);
          },
        ),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ));
    } else {
      // Google Calendar event
      final events = _getEventsForDay(_selectedDay!);
      if (index >= events.length) return;
      final event = events[index];
      final gid = event.googleEventId;
      if (gid == null) return;
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(tr('confirm_delete')),
          content: Text(tr('delete_event_confirm')),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
            FilledButton(onPressed: () => Navigator.pop(ctx, true), child: Text(tr('delete'))),
          ],
        ),
      );
      if (confirmed != true) return;
      final success = await GoogleCalendarService.deleteEvent(gid);
      if (success && mounted) {
        // Cancel all notification IDs for this event
        final notifId = event.startTime.millisecondsSinceEpoch ~/ 1000;
        NotificationService.cancelReminder(notifId);
        for (int i = 0; i < _calSettings.alertMinutesBefore.length; i++) {
          NotificationService.cancelReminder(notifId + i + 1);
        }
        setState(() {
          // Remove from _googleEvents map
          final gKey = _dateKey(event.startTime);
          _googleEvents[gKey]?.removeWhere((e) => e.googleEventId == gid);
          if (_googleEvents[gKey]?.isEmpty ?? false) _googleEvents.remove(gKey);
          _completedGoogleEventIds.remove(gid);
        });
        _saveCompletedGoogleEventIds();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(tr('event_deleted')),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  void _toggleEventCompletion(DateTime day, int combinedIndex) {
    final key = _dateKey(day);
    final localEvents = _events[key] ?? [];
    if (combinedIndex < localEvents.length) {
      // Local event
      setState(() {
        localEvents[combinedIndex] = localEvents[combinedIndex].copyWith(
          isCompleted: !localEvents[combinedIndex].isCompleted,
        );
      });
      _saveEvents();
    } else {
      // Google Calendar event
      final events = _getEventsForDay(day);
      if (combinedIndex >= events.length) return;
      final event = events[combinedIndex];
      final gid = event.googleEventId;
      if (gid == null) return;
      setState(() {
        if (_completedGoogleEventIds.contains(gid)) {
          _completedGoogleEventIds.remove(gid);
        } else {
          _completedGoogleEventIds.add(gid);
        }
      });
      _saveCompletedGoogleEventIds();
    }
  }

  Widget _buildProgressBar(DateTime day) {
    final events = _getEventsForDay(day);
    if (events.isEmpty) return const SizedBox.shrink();
    int completed = 0;
    for (final e in events) {
      if (e.isCompleted) {
        completed++;
      }
    }
    final progress = completed / events.length;
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                '$completed/${events.length} completati',
                style: TextStyle(fontSize: 12, fontWeight: FontWeight.w500, color: _calSettings.calendarColor),
              ),
              Text(
                '${(progress * 100).round()}%',
                style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600, color: _calSettings.calendarColor),
              ),
            ],
          ),
          const SizedBox(height: 4),
          ClipRRect(
            borderRadius: BorderRadius.circular(4),
            child: LinearProgressIndicator(
              value: progress,
              minHeight: 4,
              backgroundColor: _calSettings.calendarColor.withValues(alpha: 0.12),
              valueColor: AlwaysStoppedAnimation<Color>(_calSettings.calendarColor),
            ),
          ),
        ],
      ),
    );
  }

  Color _getCalendarCategoryColor(String calendar) {
    final custom = _hasCustomTheme(context);
    switch (calendar) {
      case 'Personale': return custom ? _sectionAccent(context, 0) : const Color(0xFF4CAF50);
      case 'Lavoro': return custom ? _sectionAccent(context, 1) : const Color(0xFF2196F3);
      case 'Famiglia': return const Color(0xFF9C27B0);
      case 'Compleanno': return custom ? _sectionAccent(context, 2) : const Color(0xFFE91E63);
      default: return const Color(0xFF9E9E9E);
    }
  }

  Widget _buildCategoryDots(List<CalendarEventFull> events, {double dotSize = 5}) {
    final categories = events.map((e) => e.calendar).toSet().take(4);
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      mainAxisSize: MainAxisSize.min,
      children: categories.map((cat) => Container(
        width: dotSize,
        height: dotSize,
        margin: EdgeInsets.symmetric(horizontal: dotSize * 0.2),
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: _getCalendarCategoryColor(cat),
        ),
      )).toList(),
    );
  }

  Widget _buildCalendarCell(DateTime day, DateTime focusedDay, {bool isOutsideMonth = false}) {
    final colorScheme = Theme.of(context).colorScheme;
    final isToday = isSameDay(day, DateTime.now());
    final isSelected = isSameDay(day, _selectedDay);
    final eventsForDay = _getEventsForDay(day);
    final hasEvents = eventsForDay.isNotEmpty;
    final holidayKey = '${day.month}-${day.day}';
    final holiday = _holidays[holidayKey]?.first;
    final todayColor = _calSettings.todayBorderColor;
    final today = DateTime.now();
    final todayStart = DateTime(today.year, today.month, today.day);
    final dayStart = DateTime(day.year, day.month, day.day);
    final daysFromToday = dayStart.difference(todayStart).inDays;
    final weather = (_calSettings.showWeather && daysFromToday >= 0 && daysFromToday <= 7)
        ? _weatherData?.forDay(day) : null;

    return Padding(
      padding: const EdgeInsets.all(1.5),
      child: DecoratedBox(
        decoration: BoxDecoration(
          color: isOutsideMonth
              ? colorScheme.surfaceContainerLowest.withValues(alpha: 0.5)
              : isSelected
                  ? _calSettings.selectedDayColor.withValues(alpha: 0.12)
                  : colorScheme.surfaceContainerLowest,
          borderRadius: BorderRadius.circular(10),
          border: isToday
              ? Border.all(color: todayColor, width: 1.5)
              : Border.all(color: colorScheme.outlineVariant.withValues(alpha: 0.25), width: 0.5),
        ),
        child: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (weather != null && !isOutsideMonth)
                    Padding(
                      padding: const EdgeInsets.only(right: 1),
                      child: Text(weather.icon, style: const TextStyle(fontSize: 8)),
                    ),
                  Text(
                    '${day.day}',
                    style: getCalendarFontStyle(
                      _calSettings.fontFamily,
                      _calSettings.dayFontSize - 1,
                      isOutsideMonth
                          ? _calSettings.calendarColor.withValues(alpha: 0.35)
                          : isToday ? todayColor : Theme.of(context).colorScheme.onSurface,
                    ).copyWith(fontWeight: isToday ? FontWeight.bold : FontWeight.w600),
                  ),
                ],
              ),
              SizedBox(
                height: 12,
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (hasEvents && !isOutsideMonth)
                      _buildCategoryDots(eventsForDay, dotSize: 4),
                    if (holiday != null)
                      Text(holiday.emoji, style: const TextStyle(fontSize: 8)),
                    if (_auraSettings.cycleTrackingPurchased && _calSettings.showCycleTracking && _isCycleDay(day) && !isOutsideMonth)
                      Text('🩸', style: TextStyle(fontSize: _intensityFontSize(_getCycleIntensity(day), 8))),
                    if (_auraSettings.cycleTrackingPurchased && _calSettings.showCycleTracking && !_isCycleDay(day) && !isOutsideMonth && _isPredictedCycleDay(day))
                      Text('🩸', style: TextStyle(fontSize: 7, color: Colors.red.withValues(alpha: 0.3))),
                    if (isToday && !isOutsideMonth && _healthSnapshot?.allGoalsMet == true)
                      const Text('⭐', style: TextStyle(fontSize: 8)),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  TableCalendar _buildTableCalendar(ColorScheme colorScheme, {CalendarFormat format = CalendarFormat.month, double? rowHeight}) {
    return TableCalendar(
      firstDay: DateTime.utc(2000, 1, 1),
      lastDay: DateTime.utc(2100, 12, 31),
      focusedDay: _focusedDay,
      locale: _appLocale,
      startingDayOfWeek: StartingDayOfWeek.monday,
      calendarFormat: format,
      rowHeight: rowHeight ?? 52,
      sixWeekMonthsEnforced: _calSettings.showNextMonthPreview,
      selectedDayPredicate: (day) => isSameDay(_selectedDay, day),
      eventLoader: _getEventsForDay,
      onDaySelected: (selectedDay, focusedDay) {
        setState(() {
          _selectedDay = selectedDay;
          _focusedDay = focusedDay;
        });
        if (_calSettings.calendarLayout == 'fullScreen') {
          _showDayEventsBottomSheet(selectedDay);
        }
      },
      onPageChanged: (focusedDay) {
        setState(() => _focusedDay = focusedDay);
        if (GoogleCalendarService.isSignedIn) {
          _fetchGoogleEvents();
        }
      },
      onHeaderTapped: (_) => _showDateSearchDialog(),
      calendarBuilders: CalendarBuilders(
        defaultBuilder: (context, day, focusedDay) =>
            _calSettings.calendarLayout == 'fullScreen'
                ? _buildFullScreenCell(day, focusedDay)
                : _buildCalendarCell(day, focusedDay),
        outsideBuilder: _calSettings.showNextMonthPreview
            ? (context, day, focusedDay) {
                // Only show next month days (not previous month), max 7 days
                if (day.month != focusedDay.month && day.isAfter(focusedDay) && day.day <= 7) {
                  return _calSettings.calendarLayout == 'fullScreen'
                      ? _buildFullScreenCell(day, focusedDay, isOutsideMonth: true)
                      : _buildCalendarCell(day, focusedDay, isOutsideMonth: true);
                }
                // Previous month days or >7 next month: show empty
                return const SizedBox.shrink();
              }
            : null,
        selectedBuilder: (context, day, focusedDay) =>
            _calSettings.calendarLayout == 'fullScreen'
                ? _buildFullScreenCell(day, focusedDay)
                : _buildCalendarCell(day, focusedDay),
        todayBuilder: (context, day, focusedDay) =>
            _calSettings.calendarLayout == 'fullScreen'
                ? _buildFullScreenCell(day, focusedDay)
                : _buildCalendarCell(day, focusedDay),
      ),
      headerStyle: HeaderStyle(
        formatButtonVisible: false,
        titleCentered: true,
        titleTextFormatter: (date, locale) {
          final months = localizedMonths();
          final zodiacSuffix = _calSettings.showZodiac
              ? ' (${getZodiacSign(date.month, mode: _calSettings.zodiacDisplayMode)}${_calSettings.showChineseZodiac ? ' ${getChineseZodiac(date.year)}' : ''})'
              : _calSettings.showChineseZodiac ? ' ${getChineseZodiac(date.year)}' : '';
          final todayWeather = (_calSettings.showWeather && _weatherData != null)
              ? _weatherData!.forDay(DateTime.now())
              : null;
          final weatherPrefix = todayWeather != null ? '${todayWeather.icon} ' : '';
          return '$weatherPrefix${months[date.month]} ${date.year}$zodiacSuffix';
        },
        titleTextStyle: getCalendarFontStyle(
          _calSettings.fontFamily,
          _calSettings.headerFontSize,
          _calSettings.headerColor,
        ).copyWith(fontWeight: FontWeight.bold),
        leftChevronIcon: Icon(Icons.chevron_left, color: _calSettings.calendarColor, size: 28),
        rightChevronIcon: Icon(Icons.chevron_right, color: _calSettings.calendarColor, size: 28),
      ),
      calendarStyle: CalendarStyle(
        outsideDaysVisible: _calSettings.showNextMonthPreview,
        markersMaxCount: 0,
        markerDecoration: const BoxDecoration(color: Colors.amber, shape: BoxShape.circle),
        selectedTextStyle: TextStyle(
          color: colorScheme.onPrimary,
          fontWeight: FontWeight.bold,
          fontSize: _calSettings.dayFontSize,
        ),
      ),
    );
  }

  Widget _buildFullScreenCell(DateTime day, DateTime focusedDay, {bool isOutsideMonth = false}) {
    final colorScheme = Theme.of(context).colorScheme;
    final now = DateTime.now();
    final isToday = isSameDay(day, now);
    final isSelected = isSameDay(day, _selectedDay);
    final events = isOutsideMonth ? <CalendarEventFull>[] : _getEventsForDay(day);
    final todayStart = DateTime(now.year, now.month, now.day);
    final dayStart = DateTime(day.year, day.month, day.day);
    final daysFromNow = dayStart.difference(todayStart).inDays;
    final weather = (_calSettings.showWeather && !isOutsideMonth && daysFromNow >= 0 && daysFromNow <= 7)
        ? _weatherData?.forDay(day) : null;
    final todayColor = _calSettings.todayBorderColor;
    final holidayKey = '${day.month}-${day.day}';
    final holiday = isOutsideMonth ? null : _holidays[holidayKey]?.first;

    return Container(
      margin: const EdgeInsets.all(1.5),
      decoration: BoxDecoration(
        color: isOutsideMonth
            ? colorScheme.surfaceContainerHighest.withValues(alpha: 0.3)
            : isSelected
                ? _calSettings.selectedDayColor.withValues(alpha: 0.12)
                : colorScheme.surfaceContainerLowest,
        borderRadius: BorderRadius.circular(10),
        border: isToday && !isOutsideMonth
            ? Border.all(color: todayColor, width: 1.5)
            : Border.all(color: colorScheme.outlineVariant.withValues(alpha: isOutsideMonth ? 0.15 : 0.25), width: 0.5),
      ),
      child: Padding(
        padding: const EdgeInsets.all(3),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header row: day number + icons
            Row(
              children: [
                Text(
                  '${day.day}',
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: isToday && !isOutsideMonth ? FontWeight.bold : FontWeight.w600,
                    color: isOutsideMonth
                        ? colorScheme.onSurface.withValues(alpha: 0.35)
                        : isToday ? todayColor : colorScheme.onSurface,
                  ),
                ),
                const Spacer(),
                if (weather != null) Text(weather.icon, style: const TextStyle(fontSize: 13)),
                if (holiday != null) Text(holiday.emoji, style: const TextStyle(fontSize: 10)),
                if (_auraSettings.cycleTrackingPurchased && _calSettings.showCycleTracking && _isCycleDay(day)) Text('🩸', style: TextStyle(fontSize: _intensityFontSize(_getCycleIntensity(day), 10))),
                if (_auraSettings.cycleTrackingPurchased && _calSettings.showCycleTracking && !_isCycleDay(day) && _isPredictedCycleDay(day)) Text('🩸', style: TextStyle(fontSize: 8, color: Colors.red.withValues(alpha: 0.3))),
                if (isToday && _healthSnapshot?.allGoalsMet == true) const Text('⭐', style: TextStyle(fontSize: 10)),
              ],
            ),
            if (events.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 2),
                child: _buildCategoryDots(events, dotSize: 4),
              ),
            const Spacer(),
            // Events
            if (events.isNotEmpty) ...[
              for (int ei = 0; ei < events.take(2).length; ei++)
                GestureDetector(
                  onTap: () => _showDayEventsBottomSheet(day),
                  child: Container(
                    margin: const EdgeInsets.only(bottom: 1),
                    padding: const EdgeInsets.symmetric(horizontal: 3, vertical: 1),
                    decoration: BoxDecoration(
                      color: _getCalendarCategoryColor(events[ei].calendar).withValues(alpha: 0.12),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      '${events[ei].startTime.hour.toString().padLeft(2, '0')}:${events[ei].startTime.minute.toString().padLeft(2, '0')} ${events[ei].title}',
                      style: TextStyle(fontSize: 7, color: colorScheme.onSurface),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ),
              if (events.length > 2)
                Text('+${events.length - 2}', style: TextStyle(fontSize: 7, color: _calSettings.calendarColor, fontWeight: FontWeight.w500)),
            ],
          ],
        ),
      ),
    );
  }

  Future<void> _showDateSearchDialog() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _focusedDay,
      firstDate: DateTime(2000),
      lastDate: DateTime(2100),
    );
    if (picked != null) {
      if (!mounted) return;
      setState(() {
        _focusedDay = picked;
        _selectedDay = picked;
      });
    }
  }

  void _showEventSearchDialog() {
    final colorScheme = Theme.of(context).colorScheme;
    final searchCtrl = TextEditingController();

    showDialog(
      context: context,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (ctx, setDialogState) {
            final query = searchCtrl.text.toLowerCase();

            // Gather all events from local + Google
            final List<MapEntry<DateTime, CalendarEventFull>> results = [];
            if (query.length >= 2) {
              for (final entry in _events.entries) {
                for (final event in entry.value) {
                  if (event.title.toLowerCase().contains(query) ||
                      (event.notes ?? '').toLowerCase().contains(query)) {
                    results.add(MapEntry(event.startTime, event));
                  }
                }
              }
              for (final entry in _googleEvents.entries) {
                for (final event in entry.value) {
                  if (event.title.toLowerCase().contains(query) ||
                      (event.notes ?? '').toLowerCase().contains(query)) {
                    results.add(MapEntry(event.startTime, event));
                  }
                }
              }
              results.sort((a, b) => b.key.compareTo(a.key));
            }

            return Dialog(
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
              child: ConstrainedBox(
                constraints: BoxConstraints(maxHeight: MediaQuery.of(ctx).size.height * 0.6),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                      child: TextField(
                        controller: searchCtrl,
                        autofocus: true,
                        decoration: InputDecoration(
                          hintText: tr('search_events'),
                          prefixIcon: const Icon(Icons.search, size: 20),
                          suffixIcon: searchCtrl.text.isNotEmpty
                              ? IconButton(
                                  icon: const Icon(Icons.clear, size: 18),
                                  onPressed: () {
                                    searchCtrl.clear();
                                    setDialogState(() {});
                                  },
                                )
                              : null,
                          isDense: true,
                          contentPadding: const EdgeInsets.symmetric(vertical: 10),
                        ),
                        onChanged: (_) => setDialogState(() {}),
                      ),
                    ),
                    if (query.length >= 2 && results.isEmpty)
                      Padding(
                        padding: const EdgeInsets.all(24),
                        child: Text(
                          '${tr('no_results_for')} "${searchCtrl.text}"',
                          style: TextStyle(color: colorScheme.onSurfaceVariant),
                        ),
                      ),
                    if (results.isNotEmpty)
                      Flexible(
                        child: ListView.builder(
                          shrinkWrap: true,
                          itemCount: results.length,
                          itemBuilder: (ctx, index) {
                            final event = results[index].value;
                            final date = event.startTime;
                            return ListTile(
                              leading: Icon(
                                event.isCompleted ? Icons.check_circle : Icons.event,
                                color: event.isCompleted
                                    ? Colors.green
                                    : _calSettings.calendarColor,
                              ),
                              title: Text(
                                event.title,
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                              subtitle: Text(
                                '${date.day}/${date.month}/${date.year} - ${date.hour}:${date.minute.toString().padLeft(2, '0')}',
                                style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant),
                              ),
                              onTap: () {
                                Navigator.pop(ctx);
                                setState(() {
                                  _focusedDay = date;
                                  _selectedDay = date;
                                });
                              },
                            );
                          },
                        ),
                      ),
                    const SizedBox(height: 8),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }

  void _showDayEventsBottomSheet(DateTime day) {
    final colorScheme = Theme.of(context).colorScheme;
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (ctx) {
        return DraggableScrollableSheet(
          expand: false,
          initialChildSize: 0.45,
          minChildSize: 0.3,
          maxChildSize: 0.8,
          builder: (ctx, scrollController) {
            return StatefulBuilder(builder: (ctx, setSheetState) {
              final currentEvents = _getEventsForDay(day);
              return Column(
                children: [
                  const SizedBox(height: 8),
                  Container(width: 40, height: 4, decoration: BoxDecoration(color: colorScheme.outlineVariant, borderRadius: BorderRadius.circular(2))),
                  Padding(
                    padding: const EdgeInsets.all(16),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              '${day.day}/${day.month}/${day.year}',
                              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                            Text(
                              (currentEvents.length == 1 ? tr('n_events') : tr('n_events_plural')).replaceAll('{n}', '${currentEvents.length}'),
                              style: TextStyle(color: colorScheme.onSurfaceVariant),
                            ),
                          ],
                        ),
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            if (_auraSettings.cycleTrackingPurchased && _calSettings.showCycleTracking)
                              Padding(
                                padding: const EdgeInsets.only(right: 8),
                                child: _isCycleDay(day)
                                  ? Row(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        OutlinedButton.icon(
                                          onPressed: () => _showIntensityPicker(context, day, onChanged: () => setSheetState(() {})),
                                          icon: Text(_intensityDroplets(_getCycleIntensity(day)), style: const TextStyle(fontSize: 12)),
                                          label: Text(tr('flow_intensity')),
                                          style: OutlinedButton.styleFrom(
                                            foregroundColor: Colors.red,
                                            side: const BorderSide(color: Colors.red),
                                          ),
                                        ),
                                        const SizedBox(width: 4),
                                        IconButton(
                                          onPressed: () { _toggleCycleDay(day); setSheetState(() {}); },
                                          icon: const Icon(Icons.close, size: 18),
                                          tooltip: tr('remove_cycle'),
                                          style: IconButton.styleFrom(foregroundColor: Colors.red),
                                          visualDensity: VisualDensity.compact,
                                        ),
                                      ],
                                    )
                                  : OutlinedButton.icon(
                                      onPressed: () {
                                        _toggleCycleDay(day);
                                        setSheetState(() {});
                                        Future.delayed(const Duration(milliseconds: 300), () {
                                          if (mounted) _showIntensityPicker(context, day, onChanged: () => setSheetState(() {}));
                                        });
                                      },
                                      icon: const Text('🩸', style: TextStyle(fontSize: 14)),
                                      label: Text(tr('cycle_label')),
                                    ),
                              ),
                            FilledButton.icon(
                              onPressed: () {
                                Navigator.pop(ctx);
                                setState(() => _selectedDay = day);
                                _createEvent();
                              },
                              icon: const Icon(Icons.add, size: 18),
                              label: Text(tr('event')),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  const Divider(height: 1),
                  _buildProgressBar(day),
                  _buildCycleFlowBar(day),
                  Expanded(
                    child: currentEvents.isEmpty
                        ? Center(
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(Icons.event_note_outlined, size: 48, color: colorScheme.outlineVariant),
                                const SizedBox(height: 8),
                                Text(tr('no_events'), style: TextStyle(color: colorScheme.onSurfaceVariant)),
                              ],
                            ),
                          )
                        : ListView.builder(
                            controller: scrollController,
                            itemCount: currentEvents.length,
                            itemBuilder: (ctx, index) {
                              final event = currentEvents[index];
                              return GestureDetector(
                                onTap: () => _showEventPreview(ctx, event, day, index, setSheetState),
                                child: Container(
                                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                                  padding: const EdgeInsets.all(12),
                                  decoration: BoxDecoration(
                                    color: colorScheme.surfaceContainerLowest,
                                    borderRadius: BorderRadius.circular(12),
                                    border: Border.all(color: colorScheme.outlineVariant.withValues(alpha: 0.3)),
                                  ),
                                  child: Row(
                                    children: [
                                      GestureDetector(
                                        onTap: () {
                                          _toggleEventCompletion(day, index);
                                          setSheetState(() {});
                                        },
                                        child: Container(
                                          width: 28, height: 28,
                                          decoration: BoxDecoration(
                                            color: event.isCompleted ? _calSettings.calendarColor : Colors.transparent,
                                            shape: BoxShape.circle,
                                            border: Border.all(
                                              color: event.isCompleted ? _calSettings.calendarColor : colorScheme.outlineVariant,
                                              width: 2,
                                            ),
                                          ),
                                          child: event.isCompleted
                                              ? const Icon(Icons.check, size: 16, color: Colors.white)
                                              : null,
                                        ),
                                      ),
                                      const SizedBox(width: 12),
                                      Expanded(
                                        child: Column(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                            Text(
                                              event.title,
                                              style: TextStyle(
                                                fontSize: 15,
                                                fontWeight: FontWeight.w600,
                                                decoration: event.isCompleted ? TextDecoration.lineThrough : null,
                                                color: event.isCompleted ? colorScheme.onSurfaceVariant : colorScheme.onSurface,
                                              ),
                                            ),
                                            const SizedBox(height: 2),
                                            Text(
                                              '${event.startTime.hour}:${event.startTime.minute.toString().padLeft(2, '0')} - ${event.endTime.hour}:${event.endTime.minute.toString().padLeft(2, '0')}  •  ${event.calendar}',
                                              style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant),
                                            ),
                                            if (event.reminder != null)
                                              Padding(
                                                padding: const EdgeInsets.only(top: 2),
                                                child: Row(
                                                  children: [
                                                    Icon(Icons.notifications_outlined, size: 12, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7)),
                                                    const SizedBox(width: 4),
                                                    Text(event.reminder!, style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7))),
                                                  ],
                                                ),
                                              ),
                                          ],
                                        ),
                                      ),
                                      if (event.attachmentBase64 != null || event.attachmentPath != null)
                                        Padding(
                                          padding: const EdgeInsets.only(right: 8),
                                          child: Icon(Icons.image_outlined, size: 18, color: colorScheme.onSurfaceVariant),
                                        ),
                                      Icon(Icons.chevron_right, size: 20, color: colorScheme.onSurfaceVariant),
                                    ],
                                  ),
                                ),
                              );
                            },
                          ),
                  ),
                ],
              );
            });
          },
        );
      },
    );
  }

  void _showEventPreview(BuildContext parentCtx, CalendarEventFull event, DateTime day, int index, StateSetter setSheetState) {
    final colorScheme = Theme.of(context).colorScheme;
    showModalBottomSheet(
      context: parentCtx,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (ctx) => Padding(
        padding: EdgeInsets.only(left: 24, right: 24, top: 16, bottom: MediaQuery.of(ctx).viewInsets.bottom + 24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Center(child: Container(width: 40, height: 4, decoration: BoxDecoration(color: colorScheme.outlineVariant, borderRadius: BorderRadius.circular(2)))),
            const SizedBox(height: 20),
            // Date & time
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(10),
                  decoration: BoxDecoration(
                    color: (_calSettings.calendarColor).withValues(alpha: 0.12),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Column(
                    children: [
                      Text('${event.startTime.day}', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: _calSettings.calendarColor)),
                      Text(['', 'Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'][event.startTime.month], style: TextStyle(fontSize: 12, color: _calSettings.calendarColor)),
                    ],
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(event.title, style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: colorScheme.onSurface)),
                      const SizedBox(height: 4),
                      Text(
                        '${event.startTime.hour}:${event.startTime.minute.toString().padLeft(2, '0')} - ${event.endTime.hour}:${event.endTime.minute.toString().padLeft(2, '0')}',
                        style: TextStyle(fontSize: 14, color: colorScheme.onSurfaceVariant),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            // Info chips
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                _eventInfoChip(Icons.calendar_today, event.calendar, colorScheme),
                if (event.reminder != null)
                  _eventInfoChip(Icons.notifications_outlined, event.reminder!, colorScheme),
                if (event.sharedWith.isNotEmpty)
                  _eventInfoChip(Icons.people_outline, '${event.sharedWith.length} ${tr('shared')}', colorScheme),
              ],
            ),
            // Notes
            if (event.notes != null && event.notes!.isNotEmpty) ...[
              const SizedBox(height: 16),
              Text(event.notes!, style: TextStyle(fontSize: 14, color: colorScheme.onSurface, height: 1.5)),
            ],
            // Attachment image
            if (event.attachmentPath != null || event.attachmentBase64 != null) ...[
              const SizedBox(height: 16),
              StoredImage(
                imagePath: event.attachmentPath,
                imageBase64: event.attachmentBase64,
                width: double.infinity,
                height: 180,
                fit: BoxFit.cover,
                borderRadius: BorderRadius.circular(12),
              ),
            ],
            const SizedBox(height: 20),
            // Action buttons
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () {
                      Navigator.pop(ctx);
                      _toggleEventCompletion(day, index);
                      setSheetState(() {});
                    },
                    icon: Icon(event.isCompleted ? Icons.undo : Icons.check, size: 18),
                    label: Text(event.isCompleted ? tr('undo') : tr('complete')),
                    style: OutlinedButton.styleFrom(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: FilledButton.icon(
                    onPressed: () {
                      Navigator.pop(ctx);
                      Navigator.pop(parentCtx);
                      _editEvent(day, index);
                    },
                    icon: const Icon(Icons.edit_outlined, size: 18),
                    label: Text(tr('edit')),
                    style: FilledButton.styleFrom(
                      backgroundColor: _calSettings.calendarColor,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                IconButton(
                  onPressed: () async {
                    Navigator.pop(ctx);
                    await _deleteEvent(index);
                    setSheetState(() {});
                  },
                  icon: Icon(Icons.delete_outline, color: colorScheme.error),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _eventInfoChip(IconData icon, String label, ColorScheme colorScheme) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 14, color: colorScheme.onSurfaceVariant),
          const SizedBox(width: 6),
          Text(label, style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
        ],
      ),
    );
  }

  Widget _buildLayoutToggle() {
    final isFullScreen = _calSettings.calendarLayout == 'fullScreen';
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        children: [
          Expanded(
            flex: 5,
            child: SegmentedButton<String>(
              segments: [
                ButtonSegment(value: 'split', icon: const Icon(Icons.view_agenda, size: 16), label: Text(tr('split_layout'))),
                ButtonSegment(value: 'fullScreen', icon: const _CalendarIcon9(size: 16), label: Text(tr('full_layout'))),
              ],
              selected: {_calSettings.calendarLayout},
              onSelectionChanged: (v) {
                setState(() {
                  _calSettings = _calSettings.copyWith(calendarLayout: v.first);
                  if (v.first == 'split') _isCalendarCompact = false;
                });
                _calSettings.save();
              },
              showSelectedIcon: false,
              style: const ButtonStyle(
                visualDensity: VisualDensity.compact,
                tapTargetSize: MaterialTapTargetSize.shrinkWrap,
              ),
            ),
          ),
          const SizedBox(width: 6),
          Expanded(
            flex: 4,
            child: Opacity(
              opacity: isFullScreen ? 1.0 : 0.35,
              child: IgnorePointer(
                ignoring: !isFullScreen,
                child: SegmentedButton<String>(
                  segments: [
                    ButtonSegment(value: 'month', label: Text(tr('month'))),
                    ButtonSegment(value: 'week', label: Text(tr('week'))),
                  ],
                  selected: {_calSettings.calendarViewMode},
                  onSelectionChanged: (v) {
                    setState(() {
                      _calSettings = _calSettings.copyWith(calendarViewMode: v.first);
                    });
                    _calSettings.save();
                  },
                  showSelectedIcon: false,
                  style: const ButtonStyle(
                    visualDensity: VisualDensity.compact,
                    tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                  ),
                ),
              ),
            ),
          ),
          const SizedBox(width: 4),
          IconButton(
            icon: const Icon(Icons.search, size: 22),
            tooltip: tr('search'),
            onPressed: _showEventSearchDialog,
            visualDensity: VisualDensity.compact,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(minWidth: 36, minHeight: 36),
          ),
        ],
      ),
    );
  }

  Widget _buildSplitLayout(ColorScheme colorScheme) {
    final eventsForSelectedDay = _selectedDay != null
        ? _getEventsForDay(_selectedDay!)
        : <CalendarEventFull>[];

    // Progress data for bottom bar
    int completed = 0;
    double progress = 0;
    if (_selectedDay != null && eventsForSelectedDay.isNotEmpty) {
      for (final e in eventsForSelectedDay) {
        if (e.isCompleted) completed++;
      }
      progress = completed / eventsForSelectedDay.length;
    }

    return Column(
      children: [
        AnimatedSize(
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeInOut,
          alignment: Alignment.topCenter,
          child: _isCalendarCompact
              ? Card(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        IconButton(
                          icon: Icon(Icons.chevron_left, color: _calSettings.calendarColor),
                          onPressed: () {
                            setState(() {
                              _focusedDay = DateTime(_focusedDay.year, _focusedDay.month - 1);
                              _selectedDay = _focusedDay;
                              _isCalendarCompact = false;
                            });
                            _loadEvents();
                          },
                        ),
                        GestureDetector(
                          onTap: () => setState(() => _isCalendarCompact = false),
                          child: Text(
                            '${localizedMonths()[_focusedDay.month]} ${_focusedDay.year}',
                            style: TextStyle(
                              fontSize: _calSettings.headerFontSize,
                              fontWeight: FontWeight.bold,
                              color: _calSettings.headerColor,
                            ),
                          ),
                        ),
                        IconButton(
                          icon: Icon(Icons.chevron_right, color: _calSettings.calendarColor),
                          onPressed: () {
                            setState(() {
                              _focusedDay = DateTime(_focusedDay.year, _focusedDay.month + 1);
                              _selectedDay = _focusedDay;
                              _isCalendarCompact = false;
                            });
                            _loadEvents();
                          },
                        ),
                      ],
                    ),
                  ),
                )
              : Card(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(vertical: 8),
                    child: _buildTableCalendar(colorScheme),
                  ),
                ),
        ),
        const SizedBox.shrink(),
        const SizedBox(height: 8),
        if (_selectedDay != null) ...[
          Expanded(
            child: eventsForSelectedDay.isEmpty
                ? Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(Icons.event_note_outlined, size: 64, color: colorScheme.outlineVariant),
                        const SizedBox(height: 12),
                        Text(tr('no_events'), style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600, color: colorScheme.onSurfaceVariant)),
                        const SizedBox(height: 4),
                        Text(tr('no_events_hint'), style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7))),
                      ],
                    ),
                  )
                : ListView.builder(
                      controller: _eventsScrollController,
                      itemCount: eventsForSelectedDay.length,
                      itemBuilder: (context, index) {
                        final event = eventsForSelectedDay[index];
                        return _SlideInItem(index: index, child: Card(
                          margin: const EdgeInsets.only(bottom: 12),
                          child: ListTile(
                            contentPadding: const EdgeInsets.all(16),
                            leading: Checkbox(
                              value: event.isCompleted,
                              activeColor: _calSettings.calendarColor,
                              onChanged: (_) => _toggleEventCompletion(_selectedDay!, index),
                            ),
                            title: Text(
                              event.title,
                              style: TextStyle(
                                fontSize: 15,
                                fontWeight: FontWeight.w600,
                                decoration: event.isCompleted ? TextDecoration.lineThrough : null,
                                color: event.isCompleted ? colorScheme.onSurfaceVariant : null,
                              ),
                            ),
                            subtitle: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                const SizedBox(height: 4),
                                Text(
                                  '${event.startTime.hour}:${event.startTime.minute.toString().padLeft(2, '0')} - ${event.endTime.hour}:${event.endTime.minute.toString().padLeft(2, '0')}',
                                  style: TextStyle(color: colorScheme.onSurfaceVariant),
                                ),
                                const SizedBox(height: 2),
                                Row(
                                  children: [
                                    if (event.googleEventId != null) ...[
                                      Icon(Icons.cloud, size: 12, color: const Color(0xFF4285F4)),
                                      const SizedBox(width: 4),
                                    ],
                                    Text(
                                      '${event.calendar}${event.reminder != null ? ' · ${event.reminder}' : ''}',
                                      style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7)),
                                    ),
                                  ],
                                ),
                              ],
                            ),
                            trailing: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                IconButton(
                                  icon: const Icon(Icons.edit_outlined),
                                  color: _calSettings.calendarColor,
                                  iconSize: 22,
                                  onPressed: () => _editEvent(_selectedDay!, index),
                                ),
                                IconButton(
                                  icon: const Icon(Icons.delete_outline),
                                  color: colorScheme.error,
                                  iconSize: 22,
                                  onPressed: () => _deleteEvent(index),
                                ),
                              ],
                            ),
                          ),
                        ));
                      },
                    ),
          ),
          const SizedBox(height: 4),
          // Bottom bar: date + progress + actions
          Flexible(
            flex: 0,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              decoration: BoxDecoration(
                color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
                borderRadius: BorderRadius.circular(16),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      GestureDetector(
                        onTap: () => _showDayEventsBottomSheet(_selectedDay!),
                        child: Row(
                          children: [
                            Icon(
                              _isCalendarCompact ? Icons.expand_less : Icons.event,
                              color: _calSettings.calendarColor,
                              size: 20,
                            ),
                            const SizedBox(width: 6),
                            Text(
                              '${_selectedDay!.day}/${_selectedDay!.month}/${_selectedDay!.year}',
                              style: TextStyle(fontSize: 14, fontWeight: FontWeight.w600, color: colorScheme.onSurface),
                            ),
                          ],
                        ),
                      ),
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          if (_auraSettings.cycleTrackingPurchased && _calSettings.showCycleTracking)
                            Padding(
                              padding: const EdgeInsets.only(right: 4),
                              child: _isCycleDay(_selectedDay!)
                                ? GestureDetector(
                                    onTap: () => _showIntensityPicker(context, _selectedDay!),
                                    onLongPress: () => _toggleCycleDay(_selectedDay!),
                                    child: Chip(
                                      label: Text(_intensityDroplets(_getCycleIntensity(_selectedDay!)), style: const TextStyle(fontSize: 12)),
                                      deleteIcon: const Icon(Icons.close, size: 14),
                                      onDeleted: () => _toggleCycleDay(_selectedDay!),
                                      backgroundColor: Colors.red.shade50,
                                      side: BorderSide(color: Colors.red.shade200),
                                      visualDensity: VisualDensity.compact,
                                    ),
                                  )
                                : IconButton(
                                    onPressed: () {
                                      _toggleCycleDay(_selectedDay!);
                                      Future.delayed(const Duration(milliseconds: 300), () {
                                        if (mounted) _showIntensityPicker(context, _selectedDay!);
                                      });
                                    },
                                    icon: const Text('🩸', style: TextStyle(fontSize: 16)),
                                    tooltip: tr('mark_cycle'),
                                    visualDensity: VisualDensity.compact,
                                  ),
                            ),
                          FilledButton.icon(
                            onPressed: _createEvent,
                            icon: const Icon(Icons.add, size: 16),
                            label: Text(tr('event'), style: const TextStyle(fontSize: 13)),
                            style: FilledButton.styleFrom(
                              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                              visualDensity: VisualDensity.compact,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                  // Integrated progress bar
                  if (eventsForSelectedDay.isNotEmpty) ...[
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Expanded(
                          child: ClipRRect(
                            borderRadius: BorderRadius.circular(3),
                            child: LinearProgressIndicator(
                              value: progress,
                              minHeight: 3,
                              backgroundColor: _calSettings.calendarColor.withValues(alpha: 0.12),
                              valueColor: AlwaysStoppedAnimation<Color>(_calSettings.calendarColor),
                            ),
                          ),
                        ),
                        const SizedBox(width: 6),
                        Text(
                          '$completed/${eventsForSelectedDay.length}',
                          style: TextStyle(fontSize: 10, fontWeight: FontWeight.w600, color: _calSettings.calendarColor),
                        ),
                      ],
                    ),
                  ],
                  // Health progress bar
                  if (_auraSettings.cycleTrackingPurchased && _calSettings.showCycleTracking && _isCycleDay(DateTime.now()))
                    _buildCycleFlowBar(DateTime.now()),
                ],
              ),
            ),
          ),
          const SizedBox(height: 4),
        ],
      ],
    );
  }

  // Custom week view: 3 rows of 3 cells (7 days + 2 preview from next week)
  Widget _buildCustomWeekView(ColorScheme colorScheme) {
    // Get start of current week (Monday)
    final now = _focusedDay;
    final monday = now.subtract(Duration(days: now.weekday - 1));
    // 7 days of this week + 2 preview days of next week
    final days = List.generate(9, (i) => monday.add(Duration(days: i)));

    final weekDaysShort = [...localizedWeekdaysShort(), tr('mon'), tr('tue')];
    const monthsShort = ['', 'Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];

    Widget buildWeekDayCell(DateTime day, String label, {bool isPreview = false}) {
      final isToday = isSameDay(day, DateTime.now());
      final isSelected = isSameDay(day, _selectedDay);
      final events = _getEventsForDay(day);
      final todayNow = DateTime.now();
      final todayS = DateTime(todayNow.year, todayNow.month, todayNow.day);
      final dayS = DateTime(day.year, day.month, day.day);
      final daysAhead = dayS.difference(todayS).inDays;
      final weather = (_calSettings.showWeather && daysAhead >= 0 && daysAhead <= 7)
          ? _weatherData?.forDay(day) : null;
      final holidayKey = '${day.month}-${day.day}';
      final holiday = _holidays[holidayKey]?.first;
      final todayColor = _calSettings.todayBorderColor;

      return Expanded(
        child: GestureDetector(
          onTap: () {
            setState(() {
              _selectedDay = day;
              _focusedDay = day;
            });
            _showDayEventsBottomSheet(day);
          },
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            margin: const EdgeInsets.all(4),
            decoration: BoxDecoration(
              color: isSelected
                  ? _calSettings.selectedDayColor.withValues(alpha: 0.15)
                  : isPreview
                      ? colorScheme.surfaceContainerHighest.withValues(alpha: 0.4)
                      : colorScheme.surfaceContainerLowest,
              borderRadius: BorderRadius.circular(16),
              border: isToday
                  ? Border.all(color: todayColor, width: 2)
                  : Border.all(color: colorScheme.outlineVariant.withValues(alpha: 0.3), width: 1),
            ),
            child: Padding(
              padding: const EdgeInsets.all(8),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Header: weekday + day number + weather
                  Row(
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              label,
                              style: TextStyle(
                                fontSize: 11,
                                fontWeight: FontWeight.w500,
                                color: isPreview
                                    ? colorScheme.onSurfaceVariant.withValues(alpha: 0.5)
                                    : colorScheme.onSurfaceVariant,
                              ),
                            ),
                            Text(
                              '${day.day}',
                              style: TextStyle(
                                fontSize: 20,
                                fontWeight: isToday ? FontWeight.bold : FontWeight.w600,
                                color: isPreview
                                    ? colorScheme.onSurface.withValues(alpha: 0.4)
                                    : colorScheme.onSurface,
                              ),
                            ),
                          ],
                        ),
                      ),
                      Column(
                        children: [
                          if (weather != null) Text(weather.icon, style: const TextStyle(fontSize: 16)),
                          if (holiday != null) Text(holiday.emoji, style: const TextStyle(fontSize: 12)),
                          if (_auraSettings.cycleTrackingPurchased && _calSettings.showCycleTracking && _isCycleDay(day)) Text('🩸', style: TextStyle(fontSize: _intensityFontSize(_getCycleIntensity(day), 12))),
                          if (_auraSettings.cycleTrackingPurchased && _calSettings.showCycleTracking && !_isCycleDay(day) && _isPredictedCycleDay(day)) Text('🩸', style: TextStyle(fontSize: 10, color: Colors.red.withValues(alpha: 0.3))),
                        ],
                      ),
                    ],
                  ),
                  if (weather != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 2),
                      child: Text(
                        '${weather.tempMax.round()}°/${weather.tempMin.round()}°',
                        style: TextStyle(fontSize: 10, color: colorScheme.onSurfaceVariant),
                      ),
                    ),
                  if (events.isNotEmpty && !isPreview)
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: _buildCategoryDots(events, dotSize: 5),
                    ),
                  const Spacer(),
                  // Events
                  if (events.isNotEmpty && !isPreview) ...[
                    for (int ei = 0; ei < events.take(3).length; ei++)
                      GestureDetector(
                        onTap: () => _editEvent(day, ei),
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 2),
                          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
                          decoration: BoxDecoration(
                            color: _calSettings.calendarColor.withValues(alpha: 0.12),
                            borderRadius: BorderRadius.circular(6),
                          ),
                          child: Text(
                            '${events[ei].startTime.hour.toString().padLeft(2, '0')}:${events[ei].startTime.minute.toString().padLeft(2, '0')} ${events[ei].title}',
                            style: TextStyle(fontSize: 10, color: colorScheme.onSurface),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ),
                    if (events.length > 3)
                      Padding(
                        padding: const EdgeInsets.only(top: 2),
                        child: Text(
                          '+${events.length - 3} altri',
                          style: TextStyle(fontSize: 9, color: _calSettings.calendarColor, fontWeight: FontWeight.w500),
                        ),
                      ),
                  ],
                  if (events.isNotEmpty && isPreview)
                    Text(
                      (events.length == 1 ? tr('n_events') : tr('n_events_plural')).replaceAll('{n}', '${events.length}'),
                      style: TextStyle(fontSize: 9, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.5)),
                    ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    return Column(
      children: [
        // Week navigation header
        Padding(
          padding: const EdgeInsets.only(bottom: 8),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                icon: Icon(Icons.chevron_left, color: _calSettings.calendarColor, size: 28),
                onPressed: () => setState(() => _focusedDay = _focusedDay.subtract(const Duration(days: 7))),
              ),
              GestureDetector(
                onTap: () => setState(() => _focusedDay = DateTime.now()),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (_calSettings.showWeather && _weatherData != null)
                      Padding(
                        padding: const EdgeInsets.only(right: 6),
                        child: Text(
                          _weatherData!.forDay(DateTime.now())?.icon ?? '',
                          style: TextStyle(fontSize: _calSettings.headerFontSize),
                        ),
                      ),
                    Text(
                      '${days[0].day} ${monthsShort[days[0].month]} - ${days[6].day} ${monthsShort[days[6].month]} ${days[6].year}',
                      style: TextStyle(
                        fontSize: _calSettings.headerFontSize,
                        fontWeight: FontWeight.bold,
                        color: _calSettings.headerColor,
                      ),
                    ),
                  ],
                ),
              ),
              IconButton(
                icon: Icon(Icons.chevron_right, color: _calSettings.calendarColor, size: 28),
                onPressed: () => setState(() => _focusedDay = _focusedDay.add(const Duration(days: 7))),
              ),
            ],
          ),
        ),
        // Swipeable week grid
        Expanded(
          child: GestureDetector(
            onHorizontalDragEnd: (details) {
              if (details.primaryVelocity != null) {
                if (details.primaryVelocity! < -100) {
                  setState(() => _focusedDay = _focusedDay.add(const Duration(days: 7)));
                } else if (details.primaryVelocity! > 100) {
                  setState(() => _focusedDay = _focusedDay.subtract(const Duration(days: 7)));
                }
              }
            },
            child: Column(
              children: [
                // Row 1: days 0-2 (Lun, Mar, Mer)
                Expanded(
                  child: Row(
                    children: [
                      for (int i = 0; i < 3; i++)
                        buildWeekDayCell(days[i], weekDaysShort[i]),
                    ],
                  ),
                ),
                // Row 2: days 3-5 (Gio, Ven, Sab)
                Expanded(
                  child: Row(
                    children: [
                      for (int i = 3; i < 6; i++)
                        buildWeekDayCell(days[i], weekDaysShort[i]),
                    ],
                  ),
                ),
                // Row 3: day 6 (Dom) + preview days 7-8 (Lun, Mar next week)
                Expanded(
                  child: Row(
                    children: [
                      buildWeekDayCell(days[6], weekDaysShort[6]),
                      buildWeekDayCell(days[7], weekDaysShort[7], isPreview: true),
                      buildWeekDayCell(days[8], weekDaysShort[8], isPreview: true),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFullScreenLayout(ColorScheme colorScheme) {
    final isWeek = _calSettings.calendarViewMode == 'week';

    return Stack(
      children: [
        Column(
          children: [
            Expanded(
              child: isWeek
                  ? _buildCustomWeekView(colorScheme)
                  : LayoutBuilder(
                      builder: (context, constraints) {
                        // Calculate actual rows: 6 when preview enforced, else natural rows
                        final int displayRows;
                        if (_calSettings.showNextMonthPreview) {
                          displayRows = 6; // sixWeekMonthsEnforced forces 6 rows
                        } else {
                          final first = DateTime(_focusedDay.year, _focusedDay.month, 1);
                          final daysInMonth = DateTime(_focusedDay.year, _focusedDay.month + 1, 0).day;
                          final firstWeekday = first.weekday - 1; // Monday=0
                          displayRows = ((firstWeekday + daysInMonth) / 7).ceil();
                        }
                        // Header ~56, day-of-week row ~28 = ~84 total chrome
                        final availableHeight = constraints.maxHeight - 84;
                        final dynamicRowHeight = (availableHeight / displayRows).clamp(48.0, 200.0);
                        return _buildTableCalendar(colorScheme, format: CalendarFormat.month, rowHeight: dynamicRowHeight);
                      },
                    ),
            ),
          ],
        ),
        Positioned(
          bottom: 16,
          right: 16,
          child: FloatingActionButton(
            onPressed: () {
              if (_selectedDay == null) setState(() => _selectedDay = DateTime.now());
              _createEvent();
            },
            child: const Icon(Icons.add),
          ),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    final isFullScreen = _calSettings.calendarLayout == 'fullScreen';
    return Padding(
      padding: EdgeInsets.fromLTRB(isFullScreen ? 4.0 : 16.0, isFullScreen ? 4.0 : 16.0, isFullScreen ? 4.0 : 16.0, isFullScreen ? 0.0 : 16.0),
      child: Column(
        children: [
          _buildLayoutToggle(),
          Expanded(
            child: isFullScreen
                ? _buildFullScreenLayout(colorScheme)
                : _buildSplitLayout(colorScheme),
          ),
        ],
      ),
    );
  }
}

// ─── Calendar Settings Model ─────────────────────────────────────────────────

class CalendarAlertConfig {
  final String alertType; // 'sound', 'vibration', 'sound_vibration'
  final String? soundName;
  final int durationSeconds;

  const CalendarAlertConfig({
    this.alertType = 'sound_vibration',
    this.soundName,
    this.durationSeconds = 3,
  });

  Map<String, dynamic> toJson() => {
    'alertType': alertType,
    'soundName': soundName,
    'durationSeconds': durationSeconds,
  };

  factory CalendarAlertConfig.fromJson(Map<String, dynamic> json) =>
      CalendarAlertConfig(
        alertType: json['alertType'] ?? 'sound_vibration',
        soundName: json['soundName'],
        durationSeconds: json['durationSeconds'] ?? 3,
      );
}

// ── Google Calendar Service ──
class GoogleCalendarService {
  static final GoogleSignIn _googleSignIn = GoogleSignIn(
    serverClientId: '18187658102-mf0k5htarr8rvajdono1q7grtbbk0m1e.apps.googleusercontent.com',
    scopes: [
      gcal.CalendarApi.calendarScope,
      gdrive.DriveApi.driveFileScope,
    ],
  );

  static GoogleSignInAccount? _currentUser;
  static gcal.CalendarApi? _calendarApi;

  static bool get isSignedIn => _currentUser != null;
  static String? get userEmail => _currentUser?.email;
  static String? get userDisplayName => _currentUser?.displayName;
  static String? get userPhotoUrl => _currentUser?.photoUrl;

  static Future<bool> signIn() async {
    try {
      final account = await _googleSignIn.signIn();
      if (account == null) return false;
      _currentUser = account;
      final httpClient = await _googleSignIn.authenticatedClient();
      if (httpClient == null) return false;
      _calendarApi = gcal.CalendarApi(httpClient);
      // Persist sign-in state
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool('google_calendar_connected', true);
      return true;
    } catch (e) {
      if (kDebugMode) debugPrint('Google Sign-In error: $e');
      return false;
    }
  }

  static Future<gdrive.DriveApi?> getDriveApi() async {
    if (_currentUser == null) return null;
    try {
      final httpClient = await _googleSignIn.authenticatedClient();
      if (httpClient == null) return null;
      return gdrive.DriveApi(httpClient);
    } catch (e) {
      if (kDebugMode) debugPrint('Drive API error: $e');
      return null;
    }
  }

  static Future<void> signOut() async {
    await _googleSignIn.signOut();
    _currentUser = null;
    _calendarApi = null;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('google_calendar_connected', false);
  }

  static Future<bool> trySilentSignIn() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (!(prefs.getBool('google_calendar_connected') ?? false)) return false;
      final account = await _googleSignIn.signInSilently();
      if (account == null) return false;
      _currentUser = account;
      final httpClient = await _googleSignIn.authenticatedClient();
      if (httpClient == null) return false;
      _calendarApi = gcal.CalendarApi(httpClient);
      return true;
    } catch (e) {
      if (kDebugMode) debugPrint('Silent sign-in error: $e');
      return false;
    }
  }

  /// Fetch events from Google Calendar for a given date range
  static Future<List<CalendarEventFull>> fetchEvents(DateTime start, DateTime end) async {
    if (_calendarApi == null) return [];
    try {
      final events = await _calendarApi!.events.list(
        'primary',
        timeMin: start.toUtc(),
        timeMax: end.toUtc(),
        singleEvents: true,
        orderBy: 'startTime',
        maxResults: 250,
      );
      return (events.items ?? []).map((e) => _googleEventToLocal(e)).toList();
    } catch (e) {
      if (kDebugMode) debugPrint('Fetch Google events error: $e');
      return [];
    }
  }

  /// Push a local event to Google Calendar
  static Future<bool> pushEvent(CalendarEventFull event) async {
    if (_calendarApi == null) return false;
    try {
      final gEvent = gcal.Event(
        summary: event.title,
        start: gcal.EventDateTime(
          dateTime: event.startTime,
          timeZone: DateTime.now().timeZoneName,
        ),
        end: gcal.EventDateTime(
          dateTime: event.endTime,
          timeZone: DateTime.now().timeZoneName,
        ),
        description: tr('created_by_ethos'),
        reminders: gcal.EventReminders(useDefault: false, overrides: []),
      );
      await _calendarApi!.events.insert(gEvent, 'primary');
      return true;
    } catch (e) {
      if (kDebugMode) debugPrint('Push event error: $e');
      return false;
    }
  }

  /// Delete an event from Google Calendar
  static Future<bool> deleteEvent(String eventId) async {
    if (_calendarApi == null) return false;
    try {
      await _calendarApi!.events.delete('primary', eventId);
      return true;
    } catch (e) {
      if (kDebugMode) debugPrint('Delete Google event error: $e');
      return false;
    }
  }

  static CalendarEventFull _googleEventToLocal(gcal.Event gEvent) {
    DateTime startTime;
    DateTime endTime;
    if (gEvent.start?.dateTime != null) {
      startTime = gEvent.start!.dateTime!.toLocal();
      endTime = gEvent.end?.dateTime?.toLocal() ?? startTime.add(const Duration(hours: 1));
    } else if (gEvent.start?.date != null) {
      // All-day event
      startTime = DateTime(gEvent.start!.date!.year, gEvent.start!.date!.month, gEvent.start!.date!.day);
      endTime = startTime.add(const Duration(hours: 23, minutes: 59));
    } else {
      startTime = DateTime.now();
      endTime = startTime.add(const Duration(hours: 1));
    }
    return CalendarEventFull(
      title: gEvent.summary ?? '(${tr('untitled')})',
      startTime: startTime,
      endTime: endTime,
      calendar: 'Google',
      reminder: '15',
      isCompleted: false,
      googleEventId: gEvent.id,
    );
  }
}

// ── Health Service (Apple Health / Google Health Connect) ──
class HealthSnapshot {
  final int? steps;
  final double? heartRate;
  final double? calories;
  final double? weight;
  final double? bloodOxygen;
  final double? waterLiters;
  final DateTime fetchedAt;

  const HealthSnapshot({
    this.steps,
    this.heartRate,
    this.calories,
    this.weight,
    this.bloodOxygen,
    this.waterLiters,
    required this.fetchedAt,
  });

  bool get hasData => steps != null || heartRate != null || calories != null || weight != null || bloodOxygen != null || waterLiters != null;

  /// Steps progress: 0.0–1.0 (target 10000)
  double get stepsProgress => steps != null ? (steps! / 10000).clamp(0.0, 1.0) : 0.0;

  /// Calories progress: 0.0–1.0 (target 2000 kcal)
  double get caloriesProgress => calories != null ? (calories! / 2000).clamp(0.0, 1.0) : 0.0;

  /// Water progress: 0.0–1.0 (target 2.0 liters)
  double get waterProgress => waterLiters != null ? (waterLiters! / 2.0).clamp(0.0, 1.0) : 0.0;

  bool get allGoalsMet => stepsProgress >= 1.0 && caloriesProgress >= 1.0 && waterProgress >= 1.0;

  Map<String, dynamic> toJson() => {
    'steps': steps,
    'heartRate': heartRate,
    'calories': calories,
    'weight': weight,
    'bloodOxygen': bloodOxygen,
    'waterLiters': waterLiters,
    'fetchedAt': fetchedAt.toIso8601String(),
  };

  factory HealthSnapshot.fromJson(Map<String, dynamic> json) => HealthSnapshot(
    steps: json['steps'],
    heartRate: (json['heartRate'] as num?)?.toDouble(),
    calories: (json['calories'] as num?)?.toDouble(),
    weight: (json['weight'] as num?)?.toDouble(),
    bloodOxygen: (json['bloodOxygen'] as num?)?.toDouble(),
    waterLiters: (json['waterLiters'] as num?)?.toDouble(),
    fetchedAt: DateTime.tryParse(json['fetchedAt'] ?? '') ?? DateTime.now(),
  );
}

class HealthService {
  static bool get isSupported =>
      !kIsWeb &&
      (defaultTargetPlatform == TargetPlatform.iOS ||
       defaultTargetPlatform == TargetPlatform.android);

  static bool _authorized = false;
  static bool get isAuthorized => _authorized;
  static String? lastError;

  static final _types = [
    HealthDataType.STEPS,
    HealthDataType.HEART_RATE,
    HealthDataType.BLOOD_OXYGEN,
    HealthDataType.WEIGHT,
    HealthDataType.TOTAL_CALORIES_BURNED,
    HealthDataType.ACTIVE_ENERGY_BURNED,
    HealthDataType.WATER,
  ];

  static final _permissions = [
    HealthDataAccess.READ, // STEPS
    HealthDataAccess.READ, // HEART_RATE
    HealthDataAccess.READ, // BLOOD_OXYGEN
    HealthDataAccess.READ, // WEIGHT
    HealthDataAccess.READ, // TOTAL_CALORIES_BURNED
    HealthDataAccess.READ, // ACTIVE_ENERGY_BURNED
    HealthDataAccess.READ, // WATER
  ];

  static Future<bool> requestAuthorization() async {
    if (!isSupported) return false;
    lastError = null;
    try {
      final health = Health();
      await health.configure();

      // Check if Health Connect is available (Android only)
      if (defaultTargetPlatform == TargetPlatform.android) {
        final available = await health.isHealthConnectAvailable();
        if (!available) {
          lastError = 'health_connect_not_installed';
          if (kDebugMode) debugPrint('Health Connect not available');
          try { await health.installHealthConnect(); } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
          return false;
        }
      }

      // Request authorization — may return false even if user granted permissions
      await health.requestAuthorization(
        _types,
        permissions: _permissions,
      );

      // Verify actual permissions with hasPermissions (more reliable on Android)
      bool granted = false;
      if (defaultTargetPlatform == TargetPlatform.android) {
        // Check if at least STEPS permission was granted
        final hasSteps = await health.hasPermissions(
          [HealthDataType.STEPS],
          permissions: [HealthDataAccess.READ],
        );
        granted = hasSteps == true;
        if (kDebugMode) debugPrint('Health hasPermissions(STEPS): $hasSteps');
      } else {
        // On iOS, hasPermissions returns null for READ, so trust requestAuthorization
        granted = true;
      }

      if (granted) {
        _authorized = true;
        final prefs = await SharedPreferences.getInstance();
        await prefs.setBool('health_authorized', true);
      } else {
        lastError = 'auth_denied';
      }
      return _authorized;
    } on UnsupportedError {
      lastError = 'health_connect_not_installed';
      if (kDebugMode) debugPrint('Health Connect not installed');
      try { await Health().installHealthConnect(); } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
      return false;
    } catch (e) {
      if (kDebugMode) debugPrint('Health auth error: $e');
      lastError = e.toString();
      return false;
    }
  }

  static Future<void> checkAuthorization() async {
    if (!isSupported) return;
    final prefs = await SharedPreferences.getInstance();
    final savedAuth = prefs.getBool('health_authorized') ?? false;
    if (!savedAuth) { _authorized = false; return; }
    // Verify the permission is still valid with the OS
    try {
      final health = Health();
      await health.configure();
      if (defaultTargetPlatform == TargetPlatform.android) {
        final hasSteps = await health.hasPermissions(
          [HealthDataType.STEPS],
          permissions: [HealthDataAccess.READ],
        );
        _authorized = hasSteps == true;
        if (!_authorized) {
          await prefs.setBool('health_authorized', false);
          lastError = 'permissions_revoked';
        }
      } else {
        // iOS: trust saved flag (hasPermissions returns null for READ)
        _authorized = true;
      }
    } catch (e) {
      _authorized = savedAuth; // fallback to saved flag
      if (kDebugMode) debugPrint('Health checkAuth error: $e');
    }
  }

  static Future<void> disconnect() async {
    _authorized = false;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool('health_authorized', false);
  }

  static Future<HealthSnapshot> fetchTodayData() async {
    if (!isSupported || !_authorized) {
      return HealthSnapshot(fetchedAt: DateTime.now());
    }

    // Check cache (15 min)
    final cached = await DatabaseHelper().getCache('health_snapshot');
    if (cached != null && cached.isNotEmpty) {
      try {
        final snapshot = HealthSnapshot.fromJson(json.decode(cached));
        if (DateTime.now().difference(snapshot.fetchedAt).inMinutes < 15 && snapshot.hasData) {
          return snapshot;
        }
      } catch (_) {
        // Invalid cache, re-fetch
      }
    }

    try {
      final health = Health();
      await health.configure();

      final now = DateTime.now();
      final midnight = DateTime(now.year, now.month, now.day);

      // ── Steps (aggregated, de-duplicated by Health Connect) ──
      int? steps;
      try {
        steps = await health.getTotalStepsInInterval(midnight, now);
      } catch (e) {
        if (kDebugMode) debugPrint('Health steps error: $e');
      }

      // ── Heart rate, blood oxygen, weight ──
      double? heartRate;
      double? bloodOxygen;
      double? weight;

      try {
        final heartData = await health.getHealthDataFromTypes(
          types: [HealthDataType.HEART_RATE],
          startTime: midnight,
          endTime: now,
        );
        if (heartData.isNotEmpty) {
          final val = heartData.last.value;
          if (val is NumericHealthValue) heartRate = val.numericValue.toDouble();
        }
      } catch (e) {
        if (kDebugMode) debugPrint('Health heartRate error: $e');
      }

      try {
        final oxygenData = await health.getHealthDataFromTypes(
          types: [HealthDataType.BLOOD_OXYGEN],
          startTime: midnight,
          endTime: now,
        );
        if (oxygenData.isNotEmpty) {
          final val = oxygenData.last.value;
          if (val is NumericHealthValue) bloodOxygen = val.numericValue.toDouble();
        }
      } catch (e) {
        if (kDebugMode) debugPrint('Health oxygen error: $e');
      }

      try {
        final weightData = await health.getHealthDataFromTypes(
          types: [HealthDataType.WEIGHT],
          startTime: now.subtract(const Duration(days: 30)),
          endTime: now,
        );
        if (weightData.isNotEmpty) {
          final val = weightData.last.value;
          if (val is NumericHealthValue) weight = val.numericValue.toDouble();
        }
      } catch (e) {
        if (kDebugMode) debugPrint('Health weight error: $e');
      }

      // ── Calories burned today ──
      // Try TOTAL_CALORIES_BURNED first, fallback to ACTIVE_ENERGY_BURNED
      double? calories;
      try {
        final caloriesData = await health.getHealthDataFromTypes(
          types: [HealthDataType.TOTAL_CALORIES_BURNED],
          startTime: midnight,
          endTime: now,
        );
        if (caloriesData.isNotEmpty) {
          final deduped = health.removeDuplicates(caloriesData);
          double totalCal = 0;
          for (final dp in deduped) {
            final val = dp.value;
            if (val is NumericHealthValue) totalCal += val.numericValue.toDouble();
          }
          if (totalCal > 0) calories = totalCal;
        }
      } catch (e) {
        if (kDebugMode) debugPrint('Health totalCalories error: $e');
      }

      // Fallback: active energy burned
      if (calories == null) {
        try {
          final activeData = await health.getHealthDataFromTypes(
            types: [HealthDataType.ACTIVE_ENERGY_BURNED],
            startTime: midnight,
            endTime: now,
          );
          if (activeData.isNotEmpty) {
            final deduped = health.removeDuplicates(activeData);
            double totalCal = 0;
            for (final dp in deduped) {
              final val = dp.value;
              if (val is NumericHealthValue) totalCal += val.numericValue.toDouble();
            }
            if (totalCal > 0) calories = totalCal;
          }
        } catch (e) {
          if (kDebugMode) debugPrint('Health activeCalories error: $e');
        }
      }

      // ── Water intake today (liters) ──
      double? waterLiters;
      try {
        final waterData = await health.getHealthDataFromTypes(
          types: [HealthDataType.WATER],
          startTime: midnight,
          endTime: now,
        );
        if (waterData.isNotEmpty) {
          final deduped = health.removeDuplicates(waterData);
          double totalLiters = 0;
          for (final dp in deduped) {
            final val = dp.value;
            if (val is NumericHealthValue) totalLiters += val.numericValue.toDouble();
          }
          if (totalLiters > 0) waterLiters = totalLiters;
        }
      } catch (e) {
        if (kDebugMode) debugPrint('Health water error: $e');
      }

      final snapshot = HealthSnapshot(
        steps: steps,
        heartRate: heartRate,
        calories: calories,
        weight: weight,
        bloodOxygen: bloodOxygen,
        waterLiters: waterLiters,
        fetchedAt: now,
      );

      // Cache
      await DatabaseHelper().saveCache('health_snapshot', json.encode(snapshot.toJson()));
      return snapshot;
    } catch (e) {
      if (kDebugMode) debugPrint('Health fetch error: $e');
      return HealthSnapshot(fetchedAt: DateTime.now());
    }
  }

  /// Write cycle tracking data to Apple Health / Google Health Connect
  static Future<bool> writeMenstruationFlow(DateTime date) async {
    if (!isSupported || !_authorized) return false;
    try {
      final health = Health();
      await health.configure();
      final start = DateTime(date.year, date.month, date.day);
      final end = start.add(const Duration(hours: 23, minutes: 59));
      return await health.writeHealthData(
        value: 2, // medium flow
        type: HealthDataType.MENSTRUATION_FLOW,
        startTime: start,
        endTime: end,
      );
    } catch (e) {
      if (kDebugMode) debugPrint('Health write error: $e');
      return false;
    }
  }
}

// ── Notification Service ──

class NotificationService {
  static final _plugin = FlutterLocalNotificationsPlugin();
  static const _nativeChannel = MethodChannel('com.ethosnote.app/notification');
  static const _batteryChannel = MethodChannel('com.ethosnote.app/battery');
  static bool _initialized = false;
  static bool _permissionsGranted = false;
  static bool _exactAlarmChecked = false;
  static Future<bool>? _pendingPermissionRequest;
  static void Function(String payload)? onNotificationTap;

  /// Post a notification natively via Kotlin (bypasses flutter_local_notifications).
  /// This ensures Samsung shows it with sound/vibration/heads-up.
  static Future<bool> _showNative({
    required int id,
    required String title,
    required String body,
    required String channelId,
  }) async {
    if (kIsWeb || defaultTargetPlatform != TargetPlatform.android) return false;
    try {
      final result = await _nativeChannel.invokeMethod<bool>('showNotification', {
        'id': id,
        'title': title,
        'body': body,
        'channelId': channelId,
      });
      debugPrint('NotificationService: native show #$id result=$result');
      return result ?? false;
    } catch (e) {
      debugPrint('NotificationService: native show error: $e');
      return false;
    }
  }

  /// Schedule a notification via native AlarmManager + NotificationReceiver.
  /// Bypasses flutter_local_notifications zonedSchedule which fails on Android 16.
  static Future<bool> _scheduleNative({
    required int id,
    required String title,
    required String body,
    required String channelId,
    required DateTime triggerTime,
  }) async {
    if (kIsWeb || defaultTargetPlatform != TargetPlatform.android) return false;
    try {
      final result = await _nativeChannel.invokeMethod<bool>('scheduleNotification', {
        'id': id,
        'title': title,
        'body': body,
        'channelId': channelId,
        'triggerAtMs': triggerTime.millisecondsSinceEpoch,
      });
      debugPrint('NotificationService: native schedule #$id for $triggerTime result=$result');
      return result ?? false;
    } catch (e) {
      debugPrint('NotificationService: native schedule error: $e');
      return false;
    }
  }

  /// Cancel a notification via native channel (cancels both alarm and shown notification).
  static Future<void> _cancelNative(int id) async {
    if (kIsWeb || defaultTargetPlatform != TargetPlatform.android) return;
    try {
      await _nativeChannel.invokeMethod('cancelNotification', {'id': id});
    } catch (e) {
      debugPrint('NotificationService: native cancel error: $e');
    }
  }

  /// Get the channel ID for the given alert type.
  static String _channelIdForAlertType(String alertType) {
    switch (alertType) {
      case 'sound': return 'event_sound_v3';
      case 'vibration': return 'event_vibration_v3';
      default: return 'event_both_v3';
    }
  }

  /// Check if exact alarm permission is granted; if not, open system settings.
  static Future<void> _ensureExactAlarmPermission() async {
    if (_exactAlarmChecked || kIsWeb || defaultTargetPlatform != TargetPlatform.android) return;
    _exactAlarmChecked = true;
    try {
      final canSchedule = await _batteryChannel.invokeMethod<bool>('canScheduleExactAlarms');
      debugPrint('NotificationService: canScheduleExactAlarms = $canSchedule');
      if (canSchedule != true) {
        debugPrint('NotificationService: exact alarm NOT granted — opening settings');
        await _batteryChannel.invokeMethod('requestExactAlarmPermission');
      }
    } catch (e) {
      debugPrint('NotificationService: exact alarm check error: $e');
    }
  }

  /// Basic init — call from main(). Does NOT request permissions.
  static Future<void> init() async {
    if (_initialized || kIsWeb) return;
    try {
      tz.initializeTimeZones();
      final localTzInfo = await FlutterTimezone.getLocalTimezone();
      tz.setLocalLocation(tz.getLocation(localTzInfo.identifier));
      const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
      const iosSettings = DarwinInitializationSettings(
        requestAlertPermission: false, // request later when Activity is ready
        requestBadgePermission: false,
        requestSoundPermission: false,
      );
      const settings = InitializationSettings(android: androidSettings, iOS: iosSettings);
      await _plugin.initialize(
        settings,
        onDidReceiveNotificationResponse: (NotificationResponse response) {
          if (response.payload != null && response.payload!.isNotEmpty) {
            onNotificationTap?.call(response.payload!);
          }
        },
      );
      _initialized = true;
      // Delete old v2 channels so Samsung picks up fresh v3 settings
      try {
        final androidPlugin = _plugin.resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>();
        if (androidPlugin != null) {
          await androidPlugin.deleteNotificationChannel('event_both_v2');
          await androidPlugin.deleteNotificationChannel('event_sound_v2');
          await androidPlugin.deleteNotificationChannel('event_vibration_v2');
          // Also delete legacy v1 channels if they exist
          await androidPlugin.deleteNotificationChannel('event_reminders');
          debugPrint('NotificationService: deleted old channels');
        }
      } catch (e) {
        debugPrint('NotificationService: channel cleanup error (non-fatal): $e');
      }
      debugPrint('NotificationService: initialized OK');
    } catch (e) {
      debugPrint('NotificationService init error: $e');
    }
  }

  /// Request permissions — call AFTER the app UI is visible (e.g. from CalendarPage.initState).
  /// Uses a shared Future to prevent concurrent permission dialogs.
  static Future<bool> ensurePermissions() async {
    if (kIsWeb || !_initialized) return false;
    if (_permissionsGranted) return true;
    // Prevent concurrent permission requests — share a single Future
    if (_pendingPermissionRequest != null) {
      return _pendingPermissionRequest!;
    }
    _pendingPermissionRequest = _requestPermissions();
    try {
      return await _pendingPermissionRequest!;
    } finally {
      _pendingPermissionRequest = null;
    }
  }

  static Future<bool> _requestPermissions() async {
    try {
      final androidPlugin = _plugin.resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>();
      if (androidPlugin != null) {
        // Request POST_NOTIFICATIONS (Android 13+)
        final notifGranted = await androidPlugin.requestNotificationsPermission();
        debugPrint('NotificationService: POST_NOTIFICATIONS = $notifGranted');
        // Request SCHEDULE_EXACT_ALARM (Android 12+)
        final exactGranted = await androidPlugin.requestExactAlarmsPermission();
        debugPrint('NotificationService: EXACT_ALARM (plugin) = $exactGranted');
        // Double-check via native channel — Samsung may need manual enable
        await _ensureExactAlarmPermission();
        _permissionsGranted = (notifGranted ?? false);
      } else {
        // iOS
        final iosPlugin = _plugin.resolvePlatformSpecificImplementation<IOSFlutterLocalNotificationsPlugin>();
        final granted = await iosPlugin?.requestPermissions(alert: true, badge: true, sound: true);
        _permissionsGranted = granted ?? false;
      }
      debugPrint('NotificationService: permissions granted = $_permissionsGranted');
      return _permissionsGranted;
    } catch (e) {
      debugPrint('NotificationService permission error: $e');
      return false;
    }
  }

  static NotificationDetails _buildNotifDetails(String alertType) {
    final String channelId;
    final String channelName;
    final String channelDesc;
    final bool playSound;
    final bool enableVibration;
    Int64List? vibrationPattern;
    switch (alertType) {
      case 'sound':
        channelId = 'event_sound_v3';
        channelName = 'Promemoria (suono)';
        channelDesc = 'Promemoria eventi del calendario con suono';
        playSound = true;
        enableVibration = false;
        break;
      case 'vibration':
        channelId = 'event_vibration_v3';
        channelName = 'Promemoria (vibrazione)';
        channelDesc = 'Promemoria eventi del calendario con vibrazione';
        playSound = false;
        enableVibration = true;
        vibrationPattern = Int64List.fromList([0, 500, 200, 500]);
        break;
      default: // 'sound_vibration'
        channelId = 'event_both_v3';
        channelName = 'Promemoria (suono + vibrazione)';
        channelDesc = 'Promemoria eventi del calendario con suono e vibrazione';
        playSound = true;
        enableVibration = true;
        vibrationPattern = Int64List.fromList([0, 500, 200, 500]);
    }
    return NotificationDetails(
      android: AndroidNotificationDetails(
        channelId,
        channelName,
        channelDescription: channelDesc,
        importance: Importance.max,
        priority: Priority.high,
        playSound: playSound,
        enableVibration: enableVibration,
        vibrationPattern: vibrationPattern,
        category: AndroidNotificationCategory.reminder,
        visibility: NotificationVisibility.public,
        ticker: 'Promemoria Ethos Note',
      ),
      iOS: const DarwinNotificationDetails(presentAlert: true, presentBadge: true, presentSound: true),
    );
  }

  static String _buildBody(String title, int minutesBefore) {
    if (minutesBefore < 60) {
      return '$title tra $minutesBefore minuti';
    } else if (minutesBefore < 1440) {
      final hours = minutesBefore ~/ 60;
      return '$title tra $hours ${hours == 1 ? "ora" : "ore"}';
    } else if (minutesBefore < 10080) {
      final days = minutesBefore ~/ 1440;
      return '$title tra $days ${days == 1 ? "giorno" : "giorni"}';
    } else {
      final weeks = minutesBefore ~/ 10080;
      return '$title tra $weeks ${weeks == 1 ? "settimana" : "settimane"}';
    }
  }

  static Future<void> scheduleEventReminder({
    required int id,
    required String title,
    required DateTime eventTime,
    required int minutesBefore,
    String alertType = 'sound_vibration',
    bool allowImmediate = true,
  }) async {
    if (kIsWeb || !_initialized) {
      debugPrint('NotificationService: skip — web=$kIsWeb, initialized=$_initialized');
      return;
    }
    final permOk = await ensurePermissions();
    debugPrint('NotificationService: scheduling #$id "$title" — ${minutesBefore}min before $eventTime (permissions=$permOk, allowImmediate=$allowImmediate)');
    if (!permOk && !_permissionsGranted) {
      debugPrint('NotificationService: WARNING #$id — permissions not granted, attempting anyway');
    }

    final scheduledTime = eventTime.subtract(Duration(minutes: minutesBefore));
    final now = DateTime.now();

    // If the reminder time has already passed:
    if (scheduledTime.isBefore(now)) {
      // Only show immediate notification if explicitly allowed (new event creation)
      // and the event is truly imminent (within 30 minutes).
      // During bulk reschedule (allowImmediate=false), skip silently.
      if (!allowImmediate) {
        debugPrint('NotificationService: reminder time passed for #$id, bulk reschedule — skipping');
        return;
      }
      final minutesUntilEvent = eventTime.difference(now).inMinutes;
      if (eventTime.isAfter(now) && minutesUntilEvent <= 30) {
        debugPrint('NotificationService: reminder time passed for #$id, event imminent ($minutesUntilEvent min), showing immediate');
        final body = minutesUntilEvent <= 0
            ? '$title — adesso!'
            : '$title tra $minutesUntilEvent ${minutesUntilEvent == 1 ? "minuto" : "minuti"}';
        // Use native posting for immediate notifications (Samsung compatibility)
        final nativeOk = await _showNative(
          id: id,
          title: tr('reminder'),
          body: body,
          channelId: _channelIdForAlertType(alertType),
        );
        if (!nativeOk) {
          // Fallback to flutter_local_notifications
          final details = _buildNotifDetails(alertType);
          try {
            await _plugin.show(id, tr('reminder'), body, details, payload: 'event_$id');
          } catch (e) { debugPrint('NotificationService immediate show error: $e'); }
        }
      } else {
        debugPrint('NotificationService: reminder time passed for #$id, event is ${minutesUntilEvent}min away — skipping');
      }
      return;
    }

    final body = _buildBody(title, minutesBefore);
    final channelId = _channelIdForAlertType(alertType);
    // Use native AlarmManager scheduling (bypasses flutter_local_notifications
    // which silently fails on Android 16 / Samsung OneUI)
    final nativeOk = await _scheduleNative(
      id: id,
      title: tr('reminder'),
      body: body,
      channelId: channelId,
      triggerTime: scheduledTime,
    );
    if (!nativeOk) {
      // Fallback to flutter_local_notifications zonedSchedule
      final tzScheduled = tz.TZDateTime.from(scheduledTime, tz.local);
      final details = _buildNotifDetails(alertType);
      try {
        await _plugin.zonedSchedule(
          id,
          tr('reminder'),
          body,
          tzScheduled,
          details,
          androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
          uiLocalNotificationDateInterpretation: UILocalNotificationDateInterpretation.absoluteTime,
          payload: 'event_$id',
        );
        debugPrint('NotificationService: fallback zonedSchedule #$id for $tzScheduled');
      } catch (e) {
        debugPrint('NotificationService: all scheduling methods failed for #$id: $e');
      }
    }
  }

  /// Schedule a cycle reminder notification at 09:00 the day before predictedStart.
  static Future<void> scheduleCycleReminder(DateTime predictedStart, {String alertType = 'sound_vibration'}) async {
    if (kIsWeb || !_initialized) return;
    await ensurePermissions();
    if (!_permissionsGranted) return;
    final reminderTime = DateTime(predictedStart.year, predictedStart.month, predictedStart.day, 9, 0).subtract(const Duration(days: 1));
    if (reminderTime.isBefore(DateTime.now())) return;
    const id = 999888;
    final channelId = _channelIdForAlertType(alertType);
    await _scheduleNative(
      id: id,
      title: 'Promemoria Ciclo',
      body: 'Il ciclo è previsto per domani',
      channelId: channelId,
      triggerTime: reminderTime,
    );
  }

  /// Schedule cycle diary notification at a specific time.
  static Future<void> scheduleCycleDiaryNotification(DateTime time, {String alertType = 'sound_vibration'}) async {
    if (kIsWeb || !_initialized) return;
    await ensurePermissions();
    if (!_permissionsGranted) return;
    const id = 999777;
    await _scheduleNative(
      id: id,
      title: 'Ethos Note',
      body: tr('cycle_ended_notif'),
      channelId: _channelIdForAlertType(alertType),
      triggerTime: time,
    );
  }

  /// Show cycle diary notification immediately.
  static Future<void> showCycleDiaryNotification({String alertType = 'sound_vibration'}) async {
    if (kIsWeb || !_initialized) return;
    await ensurePermissions();
    if (!_permissionsGranted) return;
    try {
      await _plugin.show(999777, 'Ethos Note', tr('cycle_ended_notif'), _buildNotifDetails(alertType), payload: 'cycle_diary');
    } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
  }

  /// Cancel the cycle reminder notification.
  static Future<void> cancelCycleReminder() async {
    if (kIsWeb || !_initialized) return;
    await _plugin.cancel(999888);
  }

  static Future<void> cancelReminder(int id) async {
    if (kIsWeb || !_initialized) return;
    await _cancelNative(id);
    await _plugin.cancel(id);
  }

  static Future<void> cancelAll() async {
    if (kIsWeb || !_initialized) return;
    try { await _nativeChannel.invokeMethod('cancelAllNotifications'); } catch (_) {}
    await _plugin.cancelAll();
  }

  /// Check if battery optimization is already disabled for this app.
  static Future<bool> isIgnoringBatteryOptimizations() async {
    if (kIsWeb || defaultTargetPlatform != TargetPlatform.android) return true;
    try {
      final result = await _batteryChannel.invokeMethod<bool>('isIgnoringBatteryOptimizations');
      return result ?? false;
    } catch (e) {
      debugPrint('NotificationService: battery check error: $e');
      return false;
    }
  }

  /// Request to disable battery optimization (Samsung/Android).
  /// Shows a system dialog asking the user to allow unrestricted background usage.
  static Future<bool> requestIgnoreBatteryOptimization() async {
    if (kIsWeb || defaultTargetPlatform != TargetPlatform.android) return false;
    try {
      final result = await _batteryChannel.invokeMethod<bool>('requestIgnoreBatteryOptimizations');
      return result ?? false;
    } catch (e) {
      debugPrint('NotificationService: battery optimization request error: $e');
      return false;
    }
  }

  /// Immediate test notification — also requests permissions if needed.
  static Future<bool> showTestNotification({String alertType = 'sound_vibration'}) async {
    if (kIsWeb) return false;
    if (!_initialized) await init();
    await ensurePermissions();
    if (!_permissionsGranted) return false;
    // Use native posting for Samsung compatibility
    final nativeOk = await _showNative(
      id: 99999,
      title: 'Ethos Note',
      body: 'Le notifiche funzionano!',
      channelId: _channelIdForAlertType(alertType),
    );
    if (nativeOk) {
      debugPrint('NotificationService: test notification sent NATIVE (alertType=$alertType)');
      return true;
    }
    // Fallback to flutter_local_notifications
    try {
      await _plugin.show(
        99999,
        'Ethos Note',
        'Le notifiche funzionano!',
        _buildNotifDetails(alertType),
      );
      debugPrint('NotificationService: test notification sent via plugin (alertType=$alertType)');
      return true;
    } catch (e) {
      debugPrint('NotificationService test error: $e');
      return false;
    }
  }

  /// Schedule a test notification 10 seconds in the future to verify native scheduling works.
  static Future<bool> showScheduledTestNotification({String alertType = 'sound_vibration'}) async {
    if (kIsWeb) return false;
    if (!_initialized) await init();
    await ensurePermissions();
    if (!_permissionsGranted) {
      debugPrint('NotificationService: scheduled test FAILED — permissions not granted');
      return false;
    }
    final triggerTime = DateTime.now().add(const Duration(seconds: 10));
    final channelId = _channelIdForAlertType(alertType);
    final ok = await _scheduleNative(
      id: 99998,
      title: 'Ethos Note',
      body: 'Notifica programmata funziona! (10s)',
      channelId: channelId,
      triggerTime: triggerTime,
    );
    debugPrint('NotificationService: scheduled test for $triggerTime — native=$ok');
    return ok;
  }

  /// Returns the number of pending (scheduled) notifications.
  static Future<int> pendingCount() async {
    if (kIsWeb || !_initialized) return -1;
    try {
      final pending = await _plugin.pendingNotificationRequests();
      return pending.length;
    } catch (e) {
      return -1;
    }
  }
}

class CalendarSettings {
  // Alert settings
  final CalendarAlertConfig alertConfig;
  final List<int> alertMinutesBefore; // e.g. [10, 60] = 10 min + 1 hour before

  // Appearance
  final int calendarColorValue;        // Color stored as int
  final int headerColorValue;
  final int selectedDayColorValue;
  final int todayBorderColorValue;
  final String fontFamily;
  final double dayFontSize;
  final double headerFontSize;

  // Zodiac
  final bool showZodiac;
  final String zodiacDisplayMode; // 'icon_only', 'icon_and_text', 'text_only'
  final bool showChineseZodiac;

  // Next month preview
  final bool showNextMonthPreview;

  // Horoscope
  final bool showHoroscope;

  // Weather
  final bool showWeather;
  final String? weatherCity;
  final double? weatherLat;
  final double? weatherLon;

  // Layout
  final String calendarLayout; // 'split' or 'fullScreen'
  final String calendarViewMode; // 'month' or 'week'

  // Cycle tracking (private)
  final bool showCycleTracking;
  final int cyclePeriodDays; // default 28
  final int cycleDurationDays; // average flow duration in days (default 5, range 2-10)
  final bool cycleReminder; // auto-reminder the day before predicted start
  final String? manualNextCycleDate; // user-set expected date (ISO8601)

  // Religion (for holidays)
  final bool showHolidays;
  final String religione;

  const CalendarSettings({
    this.alertConfig = const CalendarAlertConfig(),
    this.alertMinutesBefore = const [10],
    this.calendarColorValue = 0xFF2196F3,   // Colors.blue
    this.headerColorValue = 0xFF2196F3,
    this.selectedDayColorValue = 0xFF2196F3,
    this.todayBorderColorValue = 0xFFF44336, // Colors.red
    this.fontFamily = 'Default',
    this.dayFontSize = 14.0,
    this.headerFontSize = 18.0,
    this.showZodiac = true,
    this.zodiacDisplayMode = 'icon_only',
    this.showChineseZodiac = false,
    this.showNextMonthPreview = true,
    this.showHoroscope = false,
    this.showWeather = false,
    this.weatherCity,
    this.weatherLat,
    this.weatherLon,
    this.calendarLayout = 'split',
    this.calendarViewMode = 'month',
    this.showCycleTracking = false,
    this.cyclePeriodDays = 28,
    this.cycleDurationDays = 5,
    this.cycleReminder = true,
    this.manualNextCycleDate,
    this.showHolidays = true,
    this.religione = 'Cattolica',
  });

  Color get calendarColor => Color(calendarColorValue);
  Color get headerColor => Color(headerColorValue);
  Color get selectedDayColor => Color(selectedDayColorValue);
  Color get todayBorderColor => Color(todayBorderColorValue);

  CalendarSettings copyWith({
    CalendarAlertConfig? alertConfig,
    List<int>? alertMinutesBefore,
    int? calendarColorValue,
    int? headerColorValue,
    int? selectedDayColorValue,
    int? todayBorderColorValue,
    String? fontFamily,
    double? dayFontSize,
    double? headerFontSize,
    bool? showZodiac,
    String? zodiacDisplayMode,
    bool? showChineseZodiac,
    bool? showNextMonthPreview,
    bool? showHoroscope,
    bool? showWeather,
    String? weatherCity,
    double? weatherLat,
    double? weatherLon,
    String? calendarLayout,
    String? calendarViewMode,
    bool? showCycleTracking,
    int? cyclePeriodDays,
    int? cycleDurationDays,
    bool? cycleReminder,
    String? manualNextCycleDate,
    bool clearManualNextCycleDate = false,
    bool? showHolidays,
    String? religione,
  }) {
    return CalendarSettings(
      alertConfig: alertConfig ?? this.alertConfig,
      alertMinutesBefore: alertMinutesBefore ?? this.alertMinutesBefore,
      calendarColorValue: calendarColorValue ?? this.calendarColorValue,
      headerColorValue: headerColorValue ?? this.headerColorValue,
      selectedDayColorValue: selectedDayColorValue ?? this.selectedDayColorValue,
      todayBorderColorValue: todayBorderColorValue ?? this.todayBorderColorValue,
      fontFamily: fontFamily ?? this.fontFamily,
      dayFontSize: dayFontSize ?? this.dayFontSize,
      headerFontSize: headerFontSize ?? this.headerFontSize,
      showZodiac: showZodiac ?? this.showZodiac,
      zodiacDisplayMode: zodiacDisplayMode ?? this.zodiacDisplayMode,
      showChineseZodiac: showChineseZodiac ?? this.showChineseZodiac,
      showNextMonthPreview: showNextMonthPreview ?? this.showNextMonthPreview,
      showHoroscope: showHoroscope ?? this.showHoroscope,
      showWeather: showWeather ?? this.showWeather,
      weatherCity: weatherCity ?? this.weatherCity,
      weatherLat: weatherLat ?? this.weatherLat,
      weatherLon: weatherLon ?? this.weatherLon,
      calendarLayout: calendarLayout ?? this.calendarLayout,
      calendarViewMode: calendarViewMode ?? this.calendarViewMode,
      showCycleTracking: showCycleTracking ?? this.showCycleTracking,
      cyclePeriodDays: cyclePeriodDays ?? this.cyclePeriodDays,
      cycleDurationDays: cycleDurationDays ?? this.cycleDurationDays,
      cycleReminder: cycleReminder ?? this.cycleReminder,
      manualNextCycleDate: clearManualNextCycleDate ? null : (manualNextCycleDate ?? this.manualNextCycleDate),
      showHolidays: showHolidays ?? this.showHolidays,
      religione: religione ?? this.religione,
    );
  }

  Map<String, dynamic> toJson() => {
    'alertConfig': alertConfig.toJson(),
    'alertMinutesBefore': alertMinutesBefore,
    'calendarColorValue': calendarColorValue,
    'headerColorValue': headerColorValue,
    'selectedDayColorValue': selectedDayColorValue,
    'todayBorderColorValue': todayBorderColorValue,
    'fontFamily': fontFamily,
    'dayFontSize': dayFontSize,
    'headerFontSize': headerFontSize,
    'showZodiac': showZodiac,
    'zodiacDisplayMode': zodiacDisplayMode,
    'showChineseZodiac': showChineseZodiac,
    'showNextMonthPreview': showNextMonthPreview,
    'showHoroscope': showHoroscope,
    'showWeather': showWeather,
    'weatherCity': weatherCity,
    'weatherLat': weatherLat,
    'weatherLon': weatherLon,
    'calendarLayout': calendarLayout,
    'calendarViewMode': calendarViewMode,
    'showCycleTracking': showCycleTracking,
    'cyclePeriodDays': cyclePeriodDays,
    'cycleDurationDays': cycleDurationDays,
    'cycleReminder': cycleReminder,
    'manualNextCycleDate': manualNextCycleDate,
    'showHolidays': showHolidays,
    'religione': religione,
  };

  factory CalendarSettings.fromJson(Map<String, dynamic> json) =>
      CalendarSettings(
        alertConfig: json['alertConfig'] != null
            ? CalendarAlertConfig.fromJson(json['alertConfig'])
            : const CalendarAlertConfig(),
        alertMinutesBefore: (json['alertMinutesBefore'] as List?)
                ?.map((e) => e as int)
                .toList() ??
            [10],
        calendarColorValue: json['calendarColorValue'] ?? 0xFF2196F3,
        headerColorValue: json['headerColorValue'] ?? 0xFF2196F3,
        selectedDayColorValue: json['selectedDayColorValue'] ?? 0xFF2196F3,
        todayBorderColorValue: json['todayBorderColorValue'] ?? 0xFFF44336,
        fontFamily: json['fontFamily'] ?? 'Default',
        dayFontSize: (json['dayFontSize'] ?? 14.0).toDouble(),
        headerFontSize: (json['headerFontSize'] ?? 18.0).toDouble(),
        showZodiac: json['showZodiac'] ?? true,
        zodiacDisplayMode: json['zodiacDisplayMode'] ?? 'icon_only',
        showChineseZodiac: json['showChineseZodiac'] ?? false,
        showNextMonthPreview: json['showNextMonthPreview'] ?? true,
        showHoroscope: json['showHoroscope'] ?? false,
        showWeather: json['showWeather'] ?? false,
        weatherCity: json['weatherCity'],
        weatherLat: (json['weatherLat'] as num?)?.toDouble(),
        weatherLon: (json['weatherLon'] as num?)?.toDouble(),
        calendarLayout: json['calendarLayout'] ?? 'split',
        calendarViewMode: json['calendarViewMode'] ?? 'month',
        showCycleTracking: json['showCycleTracking'] ?? false,
        cyclePeriodDays: json['cyclePeriodDays'] ?? 28,
        cycleDurationDays: json['cycleDurationDays'] ?? 5,
        cycleReminder: json['cycleReminder'] ?? true,
        manualNextCycleDate: json['manualNextCycleDate'],
        showHolidays: json['showHolidays'] ?? true,
        religione: json['religione'] ?? tr('catholic'),
      );

  static Future<CalendarSettings> load() async {
    final jsonStr = await DatabaseHelper().getSetting('calendar_settings');
    if (jsonStr != null) {
      return CalendarSettings.fromJson(json.decode(jsonStr));
    }
    return const CalendarSettings();
  }

  Future<void> save() async {
    await DatabaseHelper().saveSetting('calendar_settings', json.encode(toJson()));
  }
}

// ─── Calendar Settings Page ──────────────────────────────────────────────────

class CalendarSettingsPage extends StatefulWidget {
  final CalendarSettings settings;
  final Function(CalendarSettings) onSave;

  const CalendarSettingsPage({
    super.key,
    required this.settings,
    required this.onSave,
  });

  @override
  State<CalendarSettingsPage> createState() => _CalendarSettingsPageState();
}

class _CalendarSettingsPageState extends State<CalendarSettingsPage> {
  late CalendarSettings _settings;
  late TextEditingController _weatherCityController;
  List<WeatherCityResult> _citySuggestions = [];
  bool _isSearchingCity = false;
  Timer? _citySearchDebounce;
  DateTime? _nextPredictedCycleStart;
  EthosAuraSettings _auraSettings = const EthosAuraSettings();

  static final _availableAlertMinutes = <int, String>{
    5: tr('5_min_before'),
    10: tr('10_min_before'),
    15: tr('15_min_before'),
    30: tr('30_min_before'),
    60: tr('1_hour_before'),
  };

  static final _alertTypes = {
    'vibration': tr('vibration_only'),
    'sound': tr('sound_only'),
    'sound_vibration': 'Sound + Vibration',
  };

  static final _alertDurations = {
    3: tr('3_seconds'),
  };


  @override
  void initState() {
    super.initState();
    _settings = widget.settings;
    _weatherCityController = TextEditingController(text: _settings.weatherCity ?? '');
    _loadAuraSettings();
    _loadCyclePrediction();
  }

  Future<void> _loadAuraSettings() async {
    final s = await EthosAuraSettings.load();
    if (!mounted) return;
    setState(() => _auraSettings = s);
  }

  Future<void> _loadCyclePrediction() async {
    if (!_settings.showCycleTracking) {
      if (mounted) setState(() => _nextPredictedCycleStart = null);
      return;
    }
    final cyclePeriod = _settings.cyclePeriodDays;
    final now = DateTime.now();
    final todayNorm = DateTime(now.year, now.month, now.day);

    final days = await DatabaseHelper().getCycleDays();
    if (!mounted) return;

    if (days.isNotEmpty) {
      final dates = <DateTime>[];
      for (final k in days) {
        final parts = k.split('-');
        if (parts.length == 3) {
          dates.add(DateTime(int.parse(parts[0]), int.parse(parts[1]), int.parse(parts[2])));
        }
      }
      if (dates.isNotEmpty) {
        dates.sort();
        var start = dates.first;
        var end = dates.first;
        for (int i = 1; i < dates.length; i++) {
          if (dates[i].difference(end).inDays <= 1) {
            end = dates[i];
          } else {
            start = dates[i];
            end = dates[i];
          }
        }
        var predicted = start.add(Duration(days: cyclePeriod));
        while (predicted.isBefore(todayNorm)) {
          predicted = predicted.add(Duration(days: cyclePeriod));
        }
        setState(() => _nextPredictedCycleStart = predicted);
        return;
      }
    }

    // Fallback: use manual date
    if (_settings.manualNextCycleDate != null) {
      final manual = DateTime.tryParse(_settings.manualNextCycleDate!);
      if (manual != null) {
        var predicted = DateTime(manual.year, manual.month, manual.day);
        while (predicted.isBefore(todayNorm)) {
          predicted = predicted.add(Duration(days: cyclePeriod));
        }
        setState(() => _nextPredictedCycleStart = predicted);
        return;
      }
    }

    setState(() => _nextPredictedCycleStart = null);
  }

  @override
  void dispose() {
    _weatherCityController.dispose();
    _citySearchDebounce?.cancel();
    super.dispose();
  }

  void _searchCity(String query) {
    _citySearchDebounce?.cancel();
    if (query.trim().length < 2) {
      setState(() { _citySuggestions = []; _isSearchingCity = false; });
      return;
    }
    setState(() => _isSearchingCity = true);
    _citySearchDebounce = Timer(const Duration(milliseconds: 400), () async {
      final results = await WeatherService.searchCities(query);
      if (mounted) setState(() { _citySuggestions = results; _isSearchingCity = false; });
    });
  }

  void _selectCity(WeatherCityResult city) {
    _weatherCityController.text = city.name;
    setState(() => _citySuggestions = []);
    _updateSettings(_settings.copyWith(
      weatherCity: city.name,
      weatherLat: city.lat,
      weatherLon: city.lon,
    ));
  }

  void _updateSettings(CalendarSettings newSettings) {
    setState(() => _settings = newSettings);
  }

  void _saveAndPop() {
    widget.onSave(_settings);
    _settings.save();
    Navigator.pop(context);
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(
        title: Text(tr('calendar_settings')),
        elevation: 0,
        scrolledUnderElevation: 2,
        actions: [
          FilledButton.icon(
            onPressed: _saveAndPop,
            icon: const Icon(Icons.check, size: 18),
            label: Text(tr('save')),
            style: FilledButton.styleFrom(
              backgroundColor: colorScheme.primary,
              foregroundColor: colorScheme.onPrimary,
            ),
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            // ── SECTION: Segno Zodiacale ──
            _buildSectionHeader(tr('show_zodiac'), Icons.auto_awesome),
            const SizedBox(height: 8),
            _buildZodiacAndHoroscopeCard(),
            const SizedBox(height: 24),

            // ── SECTION: Anteprima Mese Successivo ──
            _buildSectionHeader(tr('show_next_month'), Icons.calendar_view_week),
            const SizedBox(height: 8),
            _buildNextMonthPreviewCard(),
            const SizedBox(height: 24),

            // ── SECTION: Meteo ──
            _buildSectionHeader(tr('weather'), Icons.cloud),
            const SizedBox(height: 8),
            _buildWeatherSettingsCard(),
            const SizedBox(height: 24),

            // ── SECTION: Avvisi (merged: type + sound + timing + duration) ──
            _buildSectionHeader(tr('alerts'), Icons.notifications_active),
            const SizedBox(height: 8),
            _buildUnifiedAlertCard(),
            const SizedBox(height: 24),

            // ── SECTION: Religione ──
            _buildSectionHeader(tr('holidays'), Icons.church),
            const SizedBox(height: 8),
            _buildReligioneCard(),
            const SizedBox(height: 24),

            // ── SECTION: Ciclo Mestruale ──
            _buildSectionHeader(tr('cycle_tracking'), Icons.water_drop),
            const SizedBox(height: 8),
            if (_auraSettings.cycleTrackingPurchased)
              _buildCycleTrackingSettingsCard()
            else
              Card(
                elevation: 0,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                color: colorScheme.surfaceContainerLowest,
                child: ListTile(
                  leading: const Icon(Icons.lock_outline),
                  title: Text(tr('cycle_tracking'), style: const TextStyle(fontWeight: FontWeight.w600)),
                  subtitle: Text(tr('ethos_aura'), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                ),
              ),
            const SizedBox(height: 24),

            const SizedBox(height: 8),

            // Save button
            SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: _saveAndPop,
                icon: const Icon(Icons.save),
                label: Text(tr('save')),
              ),
            ),
          ],
        ),
    );
  }

  Widget _buildSectionHeader(String title, IconData icon) {
    return Row(
      children: [
        Icon(icon, color: Color(_settings.calendarColorValue), size: 24),
        const SizedBox(width: 8),
        Text(
          title,
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: Color(_settings.calendarColorValue),
          ),
        ),
      ],
    );
  }


  bool get _isCustomDuration =>
      !_alertDurations.containsKey(_settings.alertConfig.durationSeconds);


  void _showCustomDurationDialog() {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('default_alert')),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(
            hintText: tr('insert'),
            suffixText: tr('seconds'),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(tr('cancel')),
          ),
          FilledButton(
            onPressed: () {
              final value = int.tryParse(controller.text);
              if (value != null && value >= 1) {
                _updateSettings(_settings.copyWith(
                  alertConfig: CalendarAlertConfig(
                    alertType: _settings.alertConfig.alertType,
                    durationSeconds: value,
                  ),
                ));
                Navigator.pop(context);
              }
            },
            child: Text(tr('confirm')),
          ),
        ],
      ),
    );
  }

  List<int> get _customAlertMinutes =>
      _settings.alertMinutesBefore
          .where((m) => !_availableAlertMinutes.containsKey(m))
          .toList();

  String _formatCustomMinutes(int m) {
    if (m < 60) return '$m ${tr('min_before')}';
    if (m < 1440) {
      final h = m ~/ 60;
      final rm = m % 60;
      return rm == 0 ? '$h ${tr('hours_before')}' : '$h ${tr('hours_min_before').replaceAll('{m}', '$rm')}';
    }
    final d = m ~/ 1440;
    return d == 1 ? tr('day_before') : '$d ${tr('days_before')}';
  }


  void _showCustomAlertTimeDialog() {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('alert_sound')),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(
            hintText: tr('insert'),
            suffixText: tr('minutes_before'),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(tr('cancel')),
          ),
          FilledButton(
            onPressed: () {
              final value = int.tryParse(controller.text);
              if (value != null && value >= 1) {
                final newList = List<int>.from(_settings.alertMinutesBefore);
                if (!newList.contains(value)) {
                  newList.add(value);
                  newList.sort();
                }
                _updateSettings(_settings.copyWith(alertMinutesBefore: newList));
                Navigator.pop(context);
              }
            },
            child: Text(tr('confirm')),
          ),
        ],
      ),
    );
  }


  Widget _buildNextMonthPreviewCard() {
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SwitchListTile(
              title: Text(tr('show_next_month'), style: const TextStyle(fontWeight: FontWeight.bold)),
              subtitle: Text(tr('next_month_lighter')),
              value: _settings.showNextMonthPreview,
              activeColor: Color(_settings.calendarColorValue),
              contentPadding: EdgeInsets.zero,
              onChanged: (v) {
                _updateSettings(_settings.copyWith(showNextMonthPreview: v));
              },
            ),
            if (_settings.showNextMonthPreview) ...[
              const Divider(),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceAround,
                  children: [
                    _buildPreviewDay('28', false),
                    _buildPreviewDay('29', false),
                    _buildPreviewDay('30', false),
                    Container(width: 1, height: 30, color: Theme.of(context).colorScheme.outlineVariant),
                    _buildPreviewDay('1', true),
                    _buildPreviewDay('2', true),
                    _buildPreviewDay('3', true),
                  ],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                tr('next_month_lighter'),
                style: TextStyle(fontSize: 12, color: Theme.of(context).colorScheme.onSurfaceVariant, fontStyle: FontStyle.italic),
              ),
            ],
          ],
        ),
      ),
    );
  }


  Widget _buildZodiacAndHoroscopeCard() {
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SwitchListTile(
              title: Text(tr('show_zodiac'), style: const TextStyle(fontWeight: FontWeight.bold)),
              subtitle: Text(tr('calendar_view')),
              value: _settings.showZodiac,
              activeColor: Color(_settings.calendarColorValue),
              contentPadding: EdgeInsets.zero,
              onChanged: (v) {
                _updateSettings(_settings.copyWith(showZodiac: v));
              },
            ),
            if (_settings.showZodiac) ...[
              const SizedBox(height: 8),
              Text(tr('zodiac_display'), style: const TextStyle(fontSize: 14)),
              const SizedBox(height: 8),
              SizedBox(
                width: double.infinity,
                child: SegmentedButton<String>(
                  segments: [
                    ButtonSegment(value: 'icon_only', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('icon_only'), style: const TextStyle(fontSize: 11)))),
                    ButtonSegment(value: 'icon_and_text', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('icon_and_text'), style: const TextStyle(fontSize: 11)))),
                    ButtonSegment(value: 'text_only', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('text_only'), style: const TextStyle(fontSize: 11)))),
                  ],
                  selected: {_settings.zodiacDisplayMode},
                  onSelectionChanged: (sel) => _updateSettings(_settings.copyWith(zodiacDisplayMode: sel.first)),
                  showSelectedIcon: false,
                  style: const ButtonStyle(visualDensity: VisualDensity.compact),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildUnifiedAlertCard() {
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Alert type
            Text(tr('alerts'), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
            const SizedBox(height: 8),
            SizedBox(
              width: double.infinity,
              child: SegmentedButton<String>(
                segments: _alertTypes.entries.map((entry) {
                  return ButtonSegment(value: entry.key, label: FittedBox(fit: BoxFit.scaleDown, child: Text(entry.value, style: const TextStyle(fontSize: 11))));
                }).toList(),
                selected: {_settings.alertConfig.alertType},
                onSelectionChanged: (sel) {
                  _updateSettings(_settings.copyWith(
                    alertConfig: CalendarAlertConfig(
                      alertType: sel.first,
                      durationSeconds: _settings.alertConfig.durationSeconds,
                    ),
                  ));
                },
                showSelectedIcon: false,
                style: const ButtonStyle(visualDensity: VisualDensity.compact),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildWeatherSettingsCard() {
    final colorScheme = Theme.of(context).colorScheme;
    final calColor = Color(_settings.calendarColorValue);
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SwitchListTile(
              title: Text(tr('show_weather'), style: const TextStyle(fontWeight: FontWeight.bold)),
              subtitle: Text(tr('weather_in_calendar')),
              value: _settings.showWeather,
              activeColor: calColor,
              contentPadding: EdgeInsets.zero,
              onChanged: (v) {
                _updateSettings(_settings.copyWith(showWeather: v));
              },
            ),
            if (_settings.showWeather) ...[
              const Divider(),
              // City currently selected
              if (_settings.weatherCity != null && _settings.weatherCity!.isNotEmpty) ...[
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                  decoration: BoxDecoration(
                    color: calColor.withValues(alpha: 0.08),
                    borderRadius: BorderRadius.circular(10),
                    border: Border.all(color: calColor.withValues(alpha: 0.2)),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.location_on, color: calColor, size: 20),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _settings.weatherCity!,
                          style: TextStyle(fontWeight: FontWeight.w600, color: calColor),
                        ),
                      ),
                      IconButton(
                        icon: Icon(Icons.close, size: 18, color: colorScheme.onSurfaceVariant),
                        visualDensity: VisualDensity.compact,
                        onPressed: () {
                          _weatherCityController.clear();
                          setState(() => _citySuggestions = []);
                          _updateSettings(_settings.copyWith(weatherCity: '', weatherLat: 0.0, weatherLon: 0.0));
                        },
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 12),
              ],
              // Search field
              TextField(
                controller: _weatherCityController,
                decoration: InputDecoration(
                  labelText: tr('weather_city'),
                  hintText: tr('city_hint'),
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(10)),
                  filled: true,
                  fillColor: colorScheme.surfaceContainerLowest,
                  prefixIcon: Icon(Icons.search, color: calColor),
                  suffixIcon: _isSearchingCity
                      ? const Padding(
                          padding: EdgeInsets.all(12),
                          child: SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2)),
                        )
                      : null,
                ),
                textInputAction: TextInputAction.search,
                onChanged: _searchCity,
              ),
              // Search results
              if (_citySuggestions.isNotEmpty)
                Container(
                  margin: const EdgeInsets.only(top: 4),
                  decoration: BoxDecoration(
                    color: colorScheme.surfaceContainerLowest,
                    borderRadius: BorderRadius.circular(10),
                    border: Border.all(color: colorScheme.outlineVariant.withValues(alpha: 0.3)),
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: _citySuggestions.map((city) {
                      return ListTile(
                        dense: true,
                        leading: Icon(Icons.location_on_outlined, size: 20, color: calColor),
                        title: Text(city.name, style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 14)),
                        subtitle: Text(
                          [if (city.admin != null && city.admin != city.name) city.admin!, if (city.country != null) city.country!].join(', '),
                          style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant),
                        ),
                        onTap: () => _selectCity(city),
                      );
                    }).toList(),
                  ),
                ),
              if (_citySuggestions.isEmpty && !_isSearchingCity && _settings.weatherCity != null && _settings.weatherCity!.isNotEmpty)
                Padding(
                  padding: const EdgeInsets.only(top: 8),
                  child: Text(
                    'Dati meteo da Open-Meteo.com',
                    style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.5)),
                  ),
                ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildReligioneCard() {
    final religions = {
      tr('catholic'): Icons.church,
      tr('jewish'): Icons.synagogue,
      tr('islamic'): Icons.mosque,
      tr('chinese'): Icons.temple_buddhist,
    };
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SwitchListTile(
              title: Text(tr('holidays'), style: const TextStyle(fontWeight: FontWeight.bold)),
              subtitle: Text(tr('show_holidays_subtitle')),
              value: _settings.showHolidays,
              activeColor: Color(_settings.calendarColorValue),
              contentPadding: EdgeInsets.zero,
              secondary: Icon(Icons.celebration, color: Color(_settings.calendarColorValue)),
              onChanged: (v) {
                _updateSettings(_settings.copyWith(showHolidays: v));
              },
            ),
            if (_settings.showHolidays) ...[
              const Divider(),
              SizedBox(
                width: double.infinity,
                child: SegmentedButton<String>(
                  segments: religions.entries.map((e) {
                    return ButtonSegment(
                      value: e.key,
                      icon: Icon(e.value, size: 18),
                      label: FittedBox(fit: BoxFit.scaleDown, child: Text(
                        e.key,
                        style: const TextStyle(fontSize: 10),
                      )),
                    );
                  }).toList(),
                  selected: {_settings.religione},
                  onSelectionChanged: (sel) {
                    _updateSettings(_settings.copyWith(religione: sel.first));
                  },
                  showSelectedIcon: false,
                  style: const ButtonStyle(visualDensity: VisualDensity.compact),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildCycleTrackingSettingsCard() {
    final colorScheme = Theme.of(context).colorScheme;
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      color: colorScheme.surfaceContainerLowest,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header row
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.red.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: const Icon(Icons.water_drop, color: Colors.red, size: 22),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(tr('cycle_tracking'), style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                      const SizedBox(height: 2),
                      Text(tr('show_cycle_tracking'), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                    ],
                  ),
                ),
                Switch(
                  value: _settings.showCycleTracking,
                  activeColor: Colors.red,
                  onChanged: (v) {
                    _updateSettings(_settings.copyWith(showCycleTracking: v));
                    if (v) _loadCyclePrediction();
                  },
                ),
              ],
            ),
            if (_settings.showCycleTracking) ...[
              const SizedBox(height: 16),
              // Prediction card (prominent)
              if (_nextPredictedCycleStart != null)
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [Colors.red.withValues(alpha: 0.12), Colors.red.withValues(alpha: 0.04)],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    ),
                    borderRadius: BorderRadius.circular(14),
                    border: Border.all(color: Colors.red.withValues(alpha: 0.15)),
                  ),
                  child: Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.all(8),
                        decoration: BoxDecoration(
                          color: Colors.red.withValues(alpha: 0.12),
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(Icons.event, color: Colors.red, size: 20),
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(tr('next_cycle_predicted'), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                            const SizedBox(height: 2),
                            Text(
                              '${_nextPredictedCycleStart!.day.toString().padLeft(2, '0')}/${_nextPredictedCycleStart!.month.toString().padLeft(2, '0')}/${_nextPredictedCycleStart!.year}',
                              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: Colors.red),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                )
              else
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.3),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.info_outline, color: colorScheme.onSurfaceVariant, size: 18),
                      const SizedBox(width: 10),
                      Expanded(child: Text(tr('no_cycle_data'), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant))),
                    ],
                  ),
                ),
              const SizedBox(height: 12),
              const Divider(height: 1),
              const SizedBox(height: 8),
              // Cycle period (interval between cycles)
              Text(tr('cycle_period_days'), style: const TextStyle(fontSize: 13, fontWeight: FontWeight.w600)),
              const SizedBox(height: 4),
              Row(
                children: [
                  Text('21', style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant)),
                  Expanded(
                    child: Slider(
                      value: _settings.cyclePeriodDays.toDouble().clamp(21, 40),
                      min: 21,
                      max: 40,
                      divisions: 19,
                      label: '${_settings.cyclePeriodDays} ${tr('days')}',
                      activeColor: Colors.red,
                      onChanged: (v) {
                        _updateSettings(_settings.copyWith(cyclePeriodDays: v.round()));
                        _loadCyclePrediction();
                      },
                    ),
                  ),
                  Text('40', style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant)),
                  const SizedBox(width: 8),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                    decoration: BoxDecoration(
                      color: Colors.red.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      '${_settings.cyclePeriodDays}',
                      style: const TextStyle(fontSize: 15, fontWeight: FontWeight.bold, color: Colors.red),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              // Flow duration
              Text(tr('cycle_duration_days'), style: const TextStyle(fontSize: 13, fontWeight: FontWeight.w600)),
              const SizedBox(height: 4),
              Row(
                children: [
                  Text('2', style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant)),
                  Expanded(
                    child: Slider(
                      value: _settings.cycleDurationDays.toDouble(),
                      min: 2,
                      max: 10,
                      divisions: 8,
                      label: '${_settings.cycleDurationDays} ${tr('days')}',
                      activeColor: Colors.red,
                      onChanged: (v) {
                        _updateSettings(_settings.copyWith(cycleDurationDays: v.round()));
                      },
                    ),
                  ),
                  Text('10', style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant)),
                  const SizedBox(width: 8),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                    decoration: BoxDecoration(
                      color: Colors.red.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      '${_settings.cycleDurationDays}',
                      style: const TextStyle(fontSize: 15, fontWeight: FontWeight.bold, color: Colors.red),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              const Divider(height: 1),
              const SizedBox(height: 4),
              // Reminder toggle
              SwitchListTile(
                title: Text(tr('cycle_reminder'), style: const TextStyle(fontSize: 14)),
                subtitle: Text(tr('cycle_reminder_sub'), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                value: _settings.cycleReminder,
                activeColor: Colors.red,
                contentPadding: EdgeInsets.zero,
                secondary: const Icon(Icons.notifications_outlined, color: Colors.red, size: 22),
                onChanged: (v) {
                  _updateSettings(_settings.copyWith(cycleReminder: v));
                },
              ),
              const Divider(height: 1),
              // Manual date picker
              ListTile(
                contentPadding: EdgeInsets.zero,
                leading: const Icon(Icons.edit_calendar, color: Colors.red, size: 22),
                title: Text(tr('cycle_set_next_date'), style: const TextStyle(fontSize: 14)),
                subtitle: Text(
                  _settings.manualNextCycleDate != null
                      ? () {
                          final d = DateTime.tryParse(_settings.manualNextCycleDate!);
                          return d != null ? '${d.day.toString().padLeft(2, '0')}/${d.month.toString().padLeft(2, '0')}/${d.year}' : tr('cycle_set_next_date_sub');
                        }()
                      : tr('cycle_set_next_date_sub'),
                  style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant),
                ),
                trailing: _settings.manualNextCycleDate != null
                    ? IconButton(
                        icon: Icon(Icons.clear, size: 18, color: colorScheme.onSurfaceVariant),
                        onPressed: () {
                          _updateSettings(_settings.copyWith(clearManualNextCycleDate: true));
                          _loadCyclePrediction();
                        },
                      )
                    : null,
                onTap: () async {
                  final initial = _settings.manualNextCycleDate != null
                      ? DateTime.tryParse(_settings.manualNextCycleDate!) ?? DateTime.now()
                      : DateTime.now();
                  final picked = await showDatePicker(
                    context: context,
                    initialDate: initial,
                    firstDate: DateTime.now().subtract(const Duration(days: 60)),
                    lastDate: DateTime.now().add(const Duration(days: 90)),
                  );
                  if (picked != null) {
                    _updateSettings(_settings.copyWith(manualNextCycleDate: picked.toIso8601String()));
                    _loadCyclePrediction();
                  }
                },
              ),
              const Divider(height: 1),
              const SizedBox(height: 8),
              // Test questionnaire button
              SizedBox(
                width: double.infinity,
                child: OutlinedButton.icon(
                  onPressed: () {
                    final months = localizedMonths();
                    final now = DateTime.now();
                    final testData = <String, dynamic>{
                      'periodStart': '${now.year}-${now.month}-${now.day}',
                      'periodEnd': '${now.year}-${now.month}-${now.day}',
                      'createdAt': now.toIso8601String(),
                      'month': months[now.month] ?? '',
                      'timing': null,
                      'flow': null,
                      'symptoms': <String>[],
                      'energy': null,
                      'cravings': <String>[],
                      'cravingsCustom': '',
                      'sleep': null,
                      'sleepCustom': '',
                      'emotions': <String>[],
                      'emotionsCustom': '',
                      'notes': '',
                    };
                    Navigator.push(context, MaterialPageRoute(
                      builder: (_) => CycleDiaryPage(
                        data: testData,
                        onSave: (_) async {},
                        onComplete: (_) async {},
                      ),
                    ));
                  },
                  icon: const Icon(Icons.science_outlined, size: 18),
                  label: Text(tr('cycle_test_questionnaire')),
                  style: OutlinedButton.styleFrom(
                    foregroundColor: Colors.red,
                    side: BorderSide(color: Colors.red.withValues(alpha: 0.3)),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    padding: const EdgeInsets.symmetric(vertical: 10),
                  ),
                ),
              ),
              const SizedBox(height: 10),
              Row(
                children: [
                  Icon(Icons.lock_outline, size: 14, color: colorScheme.onSurfaceVariant),
                  const SizedBox(width: 6),
                  Expanded(
                    child: Text(
                      tr('cycle_privacy'),
                      style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant),
                    ),
                  ),
                ],
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildPreviewDay(String day, bool isNextMonth) {
    final colorScheme = Theme.of(context).colorScheme;
    return Container(
      width: 36,
      height: 36,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: isNextMonth
            ? Color(_settings.calendarColorValue).withValues(alpha: 0.1)
            : null,
      ),
      child: Center(
        child: Text(
          day,
          style: TextStyle(
            fontSize: 14,
            color: isNextMonth
                ? Color(_settings.calendarColorValue).withValues(alpha: 0.4)
                : colorScheme.onSurface,
            fontWeight: isNextMonth ? FontWeight.normal : FontWeight.w500,
          ),
        ),
      ),
    );
  }
}

// ─── Cycle Diary Interactive Questionnaire ────────────────────────────────────

class CycleDiaryPage extends StatefulWidget {
  final Map<String, dynamic> data;
  final int? noteId;
  final Future<void> Function(Map<String, dynamic>) onSave;
  final Future<void> Function(Map<String, dynamic>) onComplete;

  const CycleDiaryPage({super.key, required this.data, this.noteId, required this.onSave, required this.onComplete});

  @override
  State<CycleDiaryPage> createState() => _CycleDiaryPageState();
}

class _CycleDiaryPageState extends State<CycleDiaryPage> {
  late String? _timing;
  late String? _flow;
  late Set<String> _symptoms;
  late String? _energy;
  late Set<String> _cravings;
  late TextEditingController _cravingsCustomCtrl;
  late String? _sleep;
  late TextEditingController _sleepCustomCtrl;
  late Set<String> _emotions;
  late TextEditingController _emotionsCustomCtrl;
  late TextEditingController _notesCtrl;
  // Missing cycle fields
  late String? _missingReason;
  late TextEditingController _missingReasonCustomCtrl;

  bool get _isMissingType => widget.data['type'] == 'cycle_missing';

  static const _symptomOptions = [
    'Crampi addominali',
    'Mal di testa',
    'Mal di schiena',
    'Gonfiore',
    'Stanchezza',
    'Nausea',
    'Acne',
    'Dolore al seno',
    'Sbalzi d\'umore',
    'Vertigini',
  ];

  static const _cravingOptions = [
    'Dolce', 'Salato', 'Cioccolato', 'Verdure', 'Carne', 'Carboidrati', 'Frutta',
  ];

  @override
  void initState() {
    super.initState();
    _timing = widget.data['timing'] as String?;
    _flow = widget.data['flow'] as String?;
    _symptoms = Set<String>.from((widget.data['symptoms'] as List?)?.cast<String>() ?? []);
    _energy = widget.data['energy'] as String?;
    _cravings = Set<String>.from((widget.data['cravings'] as List?)?.cast<String>() ?? []);
    _cravingsCustomCtrl = TextEditingController(text: widget.data['cravingsCustom'] as String? ?? '');
    _sleep = widget.data['sleep'] as String?;
    _sleepCustomCtrl = TextEditingController(text: widget.data['sleepCustom'] as String? ?? '');
    _emotions = Set<String>.from((widget.data['emotions'] as List?)?.cast<String>() ?? []);
    _emotionsCustomCtrl = TextEditingController(text: widget.data['emotionsCustom'] as String? ?? '');
    _notesCtrl = TextEditingController(text: widget.data['notes'] as String? ?? '');
    _missingReason = widget.data['missingReason'] as String?;
    _missingReasonCustomCtrl = TextEditingController(text: widget.data['missingReasonCustom'] as String? ?? '');
  }

  @override
  void dispose() {
    _cravingsCustomCtrl.dispose();
    _sleepCustomCtrl.dispose();
    _emotionsCustomCtrl.dispose();
    _notesCtrl.dispose();
    _missingReasonCustomCtrl.dispose();
    super.dispose();
  }

  Map<String, dynamic> _collectData() {
    final data = Map<String, dynamic>.from(widget.data);
    data['timing'] = _timing;
    data['flow'] = _flow;
    data['symptoms'] = _symptoms.toList();
    data['energy'] = _energy;
    data['cravings'] = _cravings.toList();
    data['cravingsCustom'] = _cravingsCustomCtrl.text;
    data['sleep'] = _sleep;
    data['sleepCustom'] = _sleepCustomCtrl.text;
    data['emotions'] = _emotions.toList();
    data['emotionsCustom'] = _emotionsCustomCtrl.text;
    data['notes'] = _notesCtrl.text;
    data['missingReason'] = _missingReason;
    data['missingReasonCustom'] = _missingReasonCustomCtrl.text;
    return data;
  }

  Future<void> _exportPdf() async {
    final data = _collectData();
    final pdfBytes = await _buildCycleDiaryPdf(data);
    if (!mounted) return;
    final title = _isMissingType
        ? '${tr('cycle_missing')} ${data['month'] ?? ''}'
        : '${tr('cycle_report')} ${data['month'] ?? ''}';
    Navigator.push(context, MaterialPageRoute(
      builder: (_) => _PdfViewerPage(pdfBytes: pdfBytes, title: '$title.pdf'),
    ));
  }

  static Future<Uint8List> _buildCycleDiaryPdf(Map<String, dynamic> data) async {
    final isMissing = data['type'] == 'cycle_missing';
    final pdf = pw.Document();

    // Load Nunito font + emoji fallback
    pw.Font regularFont;
    pw.Font boldFont;
    try {
      regularFont = await PdfGoogleFonts.nunitoRegular();
      boldFont = await PdfGoogleFonts.nunitoBold();
    } catch (_) {
      regularFont = pw.Font.helvetica();
      boldFont = pw.Font.helveticaBold();
    }
    pw.Font? emojiFont;
    try { emojiFont = await PdfGoogleFonts.notoColorEmojiRegular(); } catch (_) {}
    final fontFallback = <pw.Font>[if (emojiFont != null) emojiFont];

    // Always load logo for header; check pdfShowLogo for footer
    pw.MemoryImage? logoImage;
    try {
      final logoData = await rootBundle.load('assets/logo.png');
      logoImage = pw.MemoryImage(logoData.buffer.asUint8List());
    } catch (_) {}
    bool showFooterLogo = false;
    try {
      final noteSettings = await NoteProSettings.load();
      showFooterLogo = noteSettings.pdfShowLogo;
    } catch (_) {}

    // Helper: numbered section card — light rose background, modern Material style
    pw.Widget pdfSection(String number, String title, pw.Widget content) {
      return pw.Container(
        margin: const pw.EdgeInsets.only(bottom: 14),
        padding: const pw.EdgeInsets.all(16),
        decoration: pw.BoxDecoration(
          color: const PdfColor.fromInt(0xFFFFF5F5),
          borderRadius: pw.BorderRadius.circular(12),
        ),
        child: pw.Column(
          crossAxisAlignment: pw.CrossAxisAlignment.start,
          children: [
            pw.Row(children: [
              pw.Container(
                width: 26, height: 26,
                decoration: const pw.BoxDecoration(
                  color: PdfColor.fromInt(0xFFE53935),
                  shape: pw.BoxShape.circle,
                ),
                child: pw.Center(child: pw.Text(number, style: pw.TextStyle(font: boldFont, fontSize: 12, color: PdfColors.white))),
              ),
              pw.SizedBox(width: 10),
              pw.Expanded(child: pw.Text(title, style: pw.TextStyle(font: boldFont, fontSize: 13, color: const PdfColor.fromInt(0xFF37474F)))),
            ]),
            pw.SizedBox(height: 12),
            content,
          ],
        ),
      );
    }

    // Helper: compact chip row — only renders selected items
    pw.Widget pdfSelectedChips(List<String> items) {
      if (items.isEmpty) return pw.SizedBox();
      return pw.Wrap(
        spacing: 8,
        runSpacing: 7,
        children: items.map((item) => pw.Container(
          padding: const pw.EdgeInsets.symmetric(horizontal: 12, vertical: 5),
          decoration: pw.BoxDecoration(
            color: const PdfColor.fromInt(0xFFE53935),
            borderRadius: pw.BorderRadius.circular(16),
          ),
          child: pw.Text(item, style: pw.TextStyle(font: boldFont, fontSize: 10, color: PdfColors.white)),
        )).toList(),
      );
    }

    // Helper: text note box — clean white card
    pw.Widget pdfTextBox(String text) {
      if (text.isEmpty) return pw.SizedBox();
      return pw.Container(
        margin: const pw.EdgeInsets.only(top: 8),
        padding: const pw.EdgeInsets.all(12),
        width: double.infinity,
        decoration: pw.BoxDecoration(
          color: PdfColors.white,
          borderRadius: pw.BorderRadius.circular(10),
        ),
        child: pw.Text(text, style: pw.TextStyle(font: regularFont, fontSize: 11, color: const PdfColor.fromInt(0xFF455A64))),
      );
    }

    final pageTitle = isMissing
        ? '${tr('cycle_missing')} ${data['month'] ?? ''}'
        : '${tr('cycle_report')} ${data['month'] ?? ''}';

    final generatedDate = '${DateTime.now().day.toString().padLeft(2, '0')}/${DateTime.now().month.toString().padLeft(2, '0')}/${DateTime.now().year}';
    final footerStyle = pw.TextStyle(font: regularFont, fontSize: 9, color: PdfColors.grey500);

    pdf.addPage(pw.MultiPage(
      pageFormat: PdfPageFormat.a4,
      margin: const pw.EdgeInsets.all(36),
      header: (_) => pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(pageTitle, style: pw.TextStyle(font: boldFont, fontSize: 20, color: PdfColors.red, fontFallback: fontFallback)),
          pw.SizedBox(height: 8),
        ],
      ),
      footer: (ctx) => pw.Row(
        children: [
          pw.Expanded(
            child: pw.Text(generatedDate, style: footerStyle),
          ),
          pw.Expanded(
            child: pw.Center(
              child: pw.Text('Pagina ${ctx.pageNumber} di ${ctx.pagesCount}', style: footerStyle),
            ),
          ),
          pw.Expanded(
            child: pw.Align(
              alignment: pw.Alignment.centerRight,
              child: showFooterLogo && logoImage != null
                  ? pw.Image(logoImage, width: 20, height: 20)
                  : pw.SizedBox(),
            ),
          ),
        ],
      ),
      build: (ctx) {
        final sections = <pw.Widget>[];
        int sectionNum = 0;

        if (isMissing) {
          final reason = data['missingReason'] as String? ?? '';
          final reasonCustom = data['missingReasonCustom'] as String? ?? '';
          if (reason.isNotEmpty || reasonCustom.isNotEmpty) {
            sectionNum++;
            sections.add(pdfSection('$sectionNum', tr('cycle_missing_why'), pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                if (reason.isNotEmpty) pdfSelectedChips([reason]),
                if (reasonCustom.isNotEmpty) pdfTextBox(reasonCustom),
              ],
            )));
          }
        } else {
          // Timing
          final timing = data['timing'] as String? ?? '';
          if (timing.isNotEmpty) {
            sectionNum++;
            sections.add(pdfSection('$sectionNum', tr('cycle_q_timing'),
              pdfSelectedChips([timing]),
            ));
          }

          // Flow
          final flow = data['flow'] as String? ?? '';
          if (flow.isNotEmpty) {
            sectionNum++;
            sections.add(pdfSection('$sectionNum', tr('cycle_q_flow'),
              pdfSelectedChips([flow]),
            ));
          }

          // Symptoms
          final symptoms = (data['symptoms'] as List?)?.cast<String>() ?? [];
          if (symptoms.isNotEmpty) {
            sectionNum++;
            sections.add(pdfSection('$sectionNum', tr('cycle_q_symptoms'),
              pdfSelectedChips(symptoms),
            ));
          }

          // Energy
          final energy = data['energy'] as String? ?? '';
          if (energy.isNotEmpty) {
            sectionNum++;
            sections.add(pdfSection('$sectionNum', tr('cycle_q_energy'),
              pdfSelectedChips([energy]),
            ));
          }

          // Cravings
          final cravings = (data['cravings'] as List?)?.cast<String>() ?? [];
          final cravCustom = data['cravingsCustom'] as String? ?? '';
          if (cravings.isNotEmpty || cravCustom.isNotEmpty) {
            sectionNum++;
            sections.add(pdfSection('$sectionNum', tr('cycle_q_cravings'), pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                if (cravings.isNotEmpty) pdfSelectedChips(cravings),
                if (cravCustom.isNotEmpty) pdfTextBox(cravCustom),
              ],
            )));
          }

          // Sleep
          final sleep = data['sleep'] as String? ?? '';
          final sleepCustom = data['sleepCustom'] as String? ?? '';
          if (sleep.isNotEmpty || sleepCustom.isNotEmpty) {
            sectionNum++;
            sections.add(pdfSection('$sectionNum', tr('cycle_q_sleep'), pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                if (sleep.isNotEmpty) pdfSelectedChips([sleep]),
                if (sleepCustom.isNotEmpty) pdfTextBox(sleepCustom),
              ],
            )));
          }

          // Emotions
          final emotions = (data['emotions'] as List?)?.cast<String>() ?? [];
          final emoCustom = data['emotionsCustom'] as String? ?? '';
          if (emotions.isNotEmpty || emoCustom.isNotEmpty) {
            sectionNum++;
            sections.add(pdfSection('$sectionNum', tr('cycle_q_emotions'), pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                if (emotions.isNotEmpty) pdfSelectedChips(emotions),
                if (emoCustom.isNotEmpty) pdfTextBox(emoCustom),
              ],
            )));
          }

          // Notes
          final notes = data['notes'] as String? ?? '';
          if (notes.isNotEmpty) {
            sectionNum++;
            sections.add(pdfSection('$sectionNum', tr('cycle_q_notes'),
              pdfTextBox(notes),
            ));
          }
        }

        return sections;
      },
    ));
    return pdf.save();
  }

  Future<void> _handlePregnant() async {
    final settings = await CalendarSettings.load();
    await settings.copyWith(showCycleTracking: false).save();
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('cycle_predictions_disabled')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final month = widget.data['month'] as String? ?? '';

    final appBarTitle = _isMissingType
        ? '${tr('cycle_missing')} $month'
        : '${tr('cycle_report')} $month';

    return PopScope(
      onPopInvokedWithResult: (didPop, _) {
        if (didPop) widget.onSave(_collectData());
      },
      child: Scaffold(
      appBar: AppBar(
        title: Text(appBarTitle, style: const TextStyle(fontWeight: FontWeight.bold)),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
        actions: [
          IconButton(
            onPressed: _exportPdf,
            icon: const Icon(Icons.picture_as_pdf_outlined),
            tooltip: tr('pdf'),
            color: Colors.red,
          ),
          TextButton.icon(
            onPressed: () async {
              // Handle "Sono incinta" option
              if (_isMissingType && _missingReason == tr('cycle_missing_pregnant')) {
                await _handlePregnant();
              }
              await widget.onComplete(_collectData());
              if (mounted) Navigator.pop(context);
            },
            icon: const Icon(Icons.check, size: 18),
            label: Text(tr('save')),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.fromLTRB(16, 8, 16, 100),
        children: [
          if (_isMissingType) ...[
            _buildSectionCard(
              number: '1',
              title: tr('cycle_missing_why'),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildSingleChoice(
                    options: [tr('cycle_missing_arrived'), tr('cycle_missing_not_yet'), tr('cycle_missing_pregnant'), tr('cycle_missing_other')],
                    selected: _missingReason,
                    onChanged: (v) => setState(() => _missingReason = v),
                  ),
                  if (_missingReason == tr('cycle_missing_other')) ...[
                    const SizedBox(height: 10),
                    TextField(
                      controller: _missingReasonCustomCtrl,
                      decoration: InputDecoration(
                        hintText: tr('cycle_q_notes_hint'),
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                        filled: true,
                        fillColor: colorScheme.surfaceContainerLowest,
                        contentPadding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                      ),
                      style: const TextStyle(fontSize: 14),
                    ),
                  ],
                  if (_missingReason == tr('cycle_missing_arrived')) ...[
                    const SizedBox(height: 12),
                    Text(tr('cycle_mark_days_or_skip'), style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant)),
                    const SizedBox(height: 8),
                    Row(
                      children: [
                        Expanded(
                          child: OutlinedButton.icon(
                            onPressed: () {
                              // Go back to calendar to mark days
                              Navigator.pop(context);
                            },
                            icon: const Icon(Icons.calendar_month, size: 16),
                            label: Text(tr('cycle_mark_days'), style: const TextStyle(fontSize: 12)),
                            style: OutlinedButton.styleFrom(
                              foregroundColor: Colors.red,
                              side: BorderSide(color: Colors.red.withValues(alpha: 0.3)),
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ],
              ),
            ),
          ] else ...[
          // 1. Timing
          _buildSectionCard(
            number: '1',
            title: tr('cycle_q_timing'),
            child: _buildSingleChoice(
              options: [tr('cycle_q_timing_early'), tr('cycle_q_timing_ontime'), tr('cycle_q_timing_late')],
              selected: _timing,
              onChanged: (v) => setState(() => _timing = v),
            ),
          ),
          const SizedBox(height: 12),

          // 2. Flow
          _buildSectionCard(
            number: '2',
            title: tr('cycle_q_flow'),
            child: _buildSingleChoice(
              options: [tr('cycle_q_flow_light'), tr('cycle_q_flow_medium'), tr('cycle_q_flow_heavy'), tr('cycle_q_flow_very_heavy')],
              selected: _flow,
              onChanged: (v) => setState(() => _flow = v),
            ),
          ),
          const SizedBox(height: 12),

          // 3. Symptoms
          _buildSectionCard(
            number: '3',
            title: tr('cycle_q_symptoms'),
            child: Wrap(
              spacing: 8,
              runSpacing: 6,
              children: _symptomOptions.map((s) => FilterChip(
                label: Text(s, style: const TextStyle(fontSize: 13)),
                selected: _symptoms.contains(s),
                selectedColor: Colors.red.withValues(alpha: 0.15),
                checkmarkColor: Colors.red,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                onSelected: (v) => setState(() => v ? _symptoms.add(s) : _symptoms.remove(s)),
              )).toList(),
            ),
          ),
          const SizedBox(height: 12),

          // 4. Energy
          _buildSectionCard(
            number: '4',
            title: tr('cycle_q_energy'),
            child: _buildSingleChoice(
              options: [tr('cycle_q_energy_low'), tr('cycle_q_energy_normal'), tr('cycle_q_energy_high')],
              selected: _energy,
              onChanged: (v) => setState(() => _energy = v),
            ),
          ),
          const SizedBox(height: 12),

          // 5. Cravings
          _buildSectionCard(
            number: '5',
            title: tr('cycle_q_cravings'),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Wrap(
                  spacing: 8,
                  runSpacing: 6,
                  children: _cravingOptions.map((c) => FilterChip(
                    label: Text(c, style: const TextStyle(fontSize: 13)),
                    selected: _cravings.contains(c),
                    selectedColor: Colors.red.withValues(alpha: 0.15),
                    checkmarkColor: Colors.red,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                    onSelected: (v) => setState(() => v ? _cravings.add(c) : _cravings.remove(c)),
                  )).toList(),
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: _cravingsCustomCtrl,
                  decoration: InputDecoration(
                    hintText: tr('cycle_q_cravings_other'),
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                    filled: true,
                    fillColor: colorScheme.surfaceContainerLowest,
                    contentPadding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                  ),
                  style: const TextStyle(fontSize: 14),
                ),
              ],
            ),
          ),
          const SizedBox(height: 12),

          // 6. Sleep
          _buildSectionCard(
            number: '6',
            title: tr('cycle_q_sleep'),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildSingleChoice(
                  options: [tr('cycle_q_sleep_normal'), tr('cycle_q_sleep_deep'), tr('cycle_q_sleep_restless'), tr('cycle_q_sleep_insomnia')],
                  selected: _sleep,
                  onChanged: (v) => setState(() => _sleep = v),
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: _sleepCustomCtrl,
                  decoration: InputDecoration(
                    hintText: tr('cycle_q_cravings_other'),
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                    filled: true,
                    fillColor: colorScheme.surfaceContainerLowest,
                    contentPadding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                  ),
                  style: const TextStyle(fontSize: 14),
                ),
              ],
            ),
          ),
          const SizedBox(height: 12),

          // 7. Emotions
          _buildSectionCard(
            number: '7',
            title: tr('cycle_q_emotions'),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Wrap(
                  spacing: 8,
                  runSpacing: 6,
                  children: [
                    tr('cycle_q_emotions_calm'),
                    tr('cycle_q_emotions_irritable'),
                    tr('cycle_q_emotions_sensitive'),
                    tr('cycle_q_emotions_sad'),
                  ].map((e) => FilterChip(
                    label: Text(e, style: const TextStyle(fontSize: 13)),
                    selected: _emotions.contains(e),
                    selectedColor: Colors.red.withValues(alpha: 0.15),
                    checkmarkColor: Colors.red,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                    onSelected: (v) => setState(() => v ? _emotions.add(e) : _emotions.remove(e)),
                  )).toList(),
                ),
                const SizedBox(height: 10),
                TextField(
                  controller: _emotionsCustomCtrl,
                  decoration: InputDecoration(
                    hintText: tr('cycle_q_cravings_other'),
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                    filled: true,
                    fillColor: colorScheme.surfaceContainerLowest,
                    contentPadding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                  ),
                  style: const TextStyle(fontSize: 14),
                ),
              ],
            ),
          ),
          const SizedBox(height: 12),

          // 8. Notes
          _buildSectionCard(
            number: '8',
            title: tr('cycle_q_notes'),
            child: TextField(
              controller: _notesCtrl,
              maxLines: 5,
              decoration: InputDecoration(
                hintText: tr('cycle_q_notes_hint'),
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                filled: true,
                fillColor: colorScheme.surfaceContainerLowest,
                contentPadding: const EdgeInsets.all(14),
              ),
              style: const TextStyle(fontSize: 14),
            ),
          ),
          ],
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () async {
          if (_isMissingType && _missingReason == tr('cycle_missing_pregnant')) {
            await _handlePregnant();
          }
          await widget.onComplete(_collectData());
          if (mounted) Navigator.pop(context);
        },
        backgroundColor: Colors.red,
        foregroundColor: Colors.white,
        icon: const Icon(Icons.check),
        label: Text(tr('save')),
      ),
    ),
    );
  }

  Widget _buildSectionCard({required String number, required String title, required Widget child}) {
    final colorScheme = Theme.of(context).colorScheme;
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      color: colorScheme.surfaceContainerLowest,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  width: 28, height: 28,
                  decoration: BoxDecoration(
                    color: Colors.red.withValues(alpha: 0.12),
                    shape: BoxShape.circle,
                  ),
                  child: Center(child: Text(number, style: const TextStyle(fontSize: 13, fontWeight: FontWeight.bold, color: Colors.red))),
                ),
                const SizedBox(width: 10),
                Expanded(child: Text(title, style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 15))),
              ],
            ),
            const SizedBox(height: 14),
            child,
          ],
        ),
      ),
    );
  }

  Widget _buildSingleChoice({required List<String> options, required String? selected, required ValueChanged<String> onChanged}) {
    return Wrap(
      spacing: 8,
      runSpacing: 6,
      children: options.map((opt) {
        final isSelected = selected == opt;
        return FilterChip(
          label: Text(opt, style: TextStyle(fontSize: 13, fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal)),
          selected: isSelected,
          selectedColor: Colors.red.withValues(alpha: 0.15),
          checkmarkColor: Colors.red,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          onSelected: (_) => onChanged(opt),
        );
      }).toList(),
    );
  }
}

class EventEditorPage extends StatefulWidget {
  final DateTime selectedDate;
  final Function(CalendarEventFull) onSave;
  final CalendarEventFull? existingEvent;

  const EventEditorPage({
    super.key,
    required this.selectedDate,
    required this.onSave,
    this.existingEvent,
  });

  @override
  State<EventEditorPage> createState() => _EventEditorPageState();
}

class _EventEditorPageState extends State<EventEditorPage> {
  final TextEditingController _titleController = TextEditingController();
  late DateTime _startTime;
  late DateTime _endTime;
  String _selectedCalendar = tr('personal');
  String? _selectedReminder;
  List<String> _sharedWith = [];
  List<String> _availableFriends = [];
  String? _attachmentBase64;
  String? _attachmentFileName;
  String? _attachmentFilePath;
  String? _recurrence; // null/daily/weekly/monthly/yearly
  DateTime? _recurrenceEndDate;

  final List<String> _calendars = [
    tr('personal'),
    tr('work'),
    tr('family'),
    tr('birthday'),
  ];
  final List<String> _reminders = [
    tr('10_min_before'),
    tr('15_min_before'),
    tr('30_min_before'),
    tr('1_hour_before'),
    tr('day_before'),
    tr('1_week_before'),
  ];

  @override
  void initState() {
    super.initState();
    final existing = widget.existingEvent;
    if (existing != null) {
      _titleController.text = existing.title;
      _startTime = existing.startTime;
      _endTime = existing.endTime;
      _selectedCalendar = existing.calendar;
      _selectedReminder = existing.reminder;
      _sharedWith = List<String>.from(existing.sharedWith);
      _attachmentBase64 = existing.attachmentBase64;
      _attachmentFilePath = existing.attachmentPath;
      _recurrence = existing.recurrence;
      _recurrenceEndDate = existing.recurrenceEndDate != null ? DateTime.tryParse(existing.recurrenceEndDate!) : null;
    } else {
      final now = DateTime.now();
      // Always start from current time, rounded up to next 15-minute slot
      var roundedMin = ((now.minute / 15).ceil()) * 15;
      var hour = now.hour;
      if (roundedMin >= 60) {
        roundedMin = 0;
        hour = hour + 1;
      }
      if (hour > 23) { hour = 23; roundedMin = 45; }
      _startTime = DateTime(
        widget.selectedDate.year,
        widget.selectedDate.month,
        widget.selectedDate.day,
        hour,
        roundedMin,
      );
      _endTime = _startTime.add(const Duration(hours: 1));
    }
    _loadFriends();
  }

  Future<void> _loadFriends() async {
    final profile = await DatabaseHelper().getProfile();
    if (profile != null && mounted) {
      setState(() {
        _availableFriends = profile.friends;
      });
    }
  }

  void _saveEvent() {
    final title = _titleController.text.isNotEmpty
        ? _titleController.text
        : ((_attachmentBase64 != null || _attachmentFilePath != null) ? tr('event') : null);
    if (title != null) {
      final baseEvent = CalendarEventFull(
        title: title,
        startTime: _startTime,
        endTime: _endTime,
        calendar: _selectedCalendar,
        reminder: _selectedReminder,
        sharedWith: _sharedWith,
        attachmentBase64: _attachmentBase64,
        attachmentPath: _attachmentFilePath,
        recurrence: _recurrence,
        recurrenceEndDate: _recurrenceEndDate?.toIso8601String(),
      );
      // Pass single event — CalendarPage handles recurrence expansion
      widget.onSave(baseEvent);

      Navigator.pop(context);
    }
  }

  Future<void> _pickDate(bool isStart) async {
    final initial = isStart ? _startTime : _endTime;
    final date = await showDatePicker(
      context: context,
      initialDate: initial,
      firstDate: DateTime(2000),
      lastDate: DateTime(2100),
    );
    if (date != null) {
      if (!mounted) return;
      setState(() {
        if (isStart) {
          _startTime = DateTime(date.year, date.month, date.day, _startTime.hour, _startTime.minute);
          if (_startTime.isAfter(_endTime)) {
            _endTime = _startTime.add(const Duration(hours: 1));
          }
        } else {
          _endTime = DateTime(date.year, date.month, date.day, _endTime.hour, _endTime.minute);
        }
      });
    }
  }

  Future<void> _pickTime(bool isStart) async {
    final time = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(isStart ? _startTime : _endTime),
      initialEntryMode: TimePickerEntryMode.input,
    );
    if (time != null) {
      if (!mounted) return;
      setState(() {
        if (isStart) {
          _startTime = DateTime(
            _startTime.year,
            _startTime.month,
            _startTime.day,
            time.hour,
            time.minute,
          );
          // Auto-adjust end time to start + 1 hour
          _endTime = _startTime.add(const Duration(hours: 1));
        } else {
          _endTime = DateTime(
            _endTime.year,
            _endTime.month,
            _endTime.day,
            time.hour,
            time.minute,
          );
        }
      });
    }
  }

  Future<void> _pickPhoto() async {
    try {
      final picker = ImagePicker();
      final XFile? image = await picker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1200,
        maxHeight: 1200,
        imageQuality: 80,
      );
      if (image != null) {
        final bytes = await image.readAsBytes();
        final imgHelper = ImageStorageHelper();
        final fileName = imgHelper.generateFileName('event');
        final filePath = await imgHelper.saveBytesToFile(bytes, fileName);
        if (!mounted) return;
        setState(() {
          _attachmentFilePath = filePath;
          _attachmentBase64 = null;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${tr('photo_error')}: $e'),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  Future<void> _pickFile() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.any,
        withData: true,
      );
      if (result != null && result.files.single.bytes != null) {
        if (!mounted) return;
        setState(() {
          _attachmentBase64 = base64Encode(result.files.single.bytes!);
          _attachmentFileName = result.files.single.name;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Errore: $e'),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  String _formatDate(DateTime dt) => '${dt.day}/${dt.month}/${dt.year}';

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.existingEvent != null ? tr('edit_event') : tr('new_event')),
        elevation: 0,
        scrolledUnderElevation: 2,
        actions: [
          FilledButton.icon(
            onPressed: _saveEvent,
            icon: const Icon(Icons.check, size: 18),
            label: Text(tr('save')),
            style: FilledButton.styleFrom(
              backgroundColor: colorScheme.primary,
              foregroundColor: colorScheme.onPrimary,
            ),
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            TextField(
              controller: _titleController,
              decoration: InputDecoration(
                labelText: tr('event_title'),
                hintText: '${tr('meeting')}, ${tr('birthday')}, ${tr('appointment')}...',
                prefixIcon: Icon(Icons.event, color: colorScheme.primary),
              ),
              style: const TextStyle(fontSize: 18),
            ),
            const SizedBox(height: 24),
            Text(
              tr('date_and_time'),
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: InkWell(
                    onTap: () => _pickDate(true),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        labelText: tr('start_time'),
                        prefixIcon: const Icon(Icons.calendar_today, size: 20),
                      ),
                      child: Text(_formatDate(_startTime)),
                    ),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: InkWell(
                    onTap: () => _pickDate(false),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        labelText: tr('end_time'),
                        prefixIcon: const Icon(Icons.calendar_today, size: 20),
                      ),
                      child: Text(_formatDate(_endTime)),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: InkWell(
                    onTap: () => _pickTime(true),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        labelText: tr('start_time'),
                        prefixIcon: const Icon(Icons.access_time),
                      ),
                      child: Text(
                        '${_startTime.hour}:${_startTime.minute.toString().padLeft(2, '0')}',
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: InkWell(
                    onTap: () => _pickTime(false),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        labelText: tr('end_time'),
                        prefixIcon: const Icon(Icons.access_time),
                      ),
                      child: Text(
                        '${_endTime.hour}:${_endTime.minute.toString().padLeft(2, '0')}',
                      ),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 24),
            DropdownButtonFormField<String>(
              value: _selectedCalendar,
              decoration: InputDecoration(
                labelText: tr('calendar_name'),
                prefixIcon: const Icon(Icons.calendar_today, size: 20),
              ),
              items: _calendars
                  .map((cal) => DropdownMenuItem(value: cal, child: Text(cal)))
                  .toList(),
              onChanged: (value) => setState(() => _selectedCalendar = value!),
            ),
            const SizedBox(height: 24),
            Text(
              tr('alert'),
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                ..._reminders.map((reminder) {
                  final isSelected = _selectedReminder == reminder;
                  return FilterChip(
                    label: Text(reminder),
                    selected: isSelected,
                    onSelected: (selected) {
                      setState(
                        () => _selectedReminder = selected ? reminder : null,
                      );
                    },
                    selectedColor: colorScheme.primaryContainer,
                  );
                }),
                FilterChip(
                  label: Text(_selectedReminder != null && !_reminders.contains(_selectedReminder!)
                      ? _selectedReminder!
                      : tr('custom')),
                  selected: _selectedReminder != null && !_reminders.contains(_selectedReminder!),
                  onSelected: (_) async {
                    final controller = TextEditingController();
                    final minutes = await showDialog<int>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Text(tr('custom_alert_time')),
                        content: TextField(
                          controller: controller,
                          keyboardType: TextInputType.number,
                          autofocus: true,
                          decoration: InputDecoration(
                            labelText: tr('insert_minutes'),
                            suffixText: tr('minutes'),
                          ),
                        ),
                        actions: [
                          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
                          FilledButton(onPressed: () {
                            final val = int.tryParse(controller.text);
                            if (val != null && val > 0) Navigator.pop(ctx, val);
                          }, child: Text(tr('confirm'))),
                        ],
                      ),
                    );
                    if (minutes != null && mounted) {
                      setState(() => _selectedReminder = '$minutes min');
                    }
                  },
                  selectedColor: colorScheme.primaryContainer,
                ),
              ],
            ),
            const SizedBox(height: 24),
            Text(
              tr('recurrence'),
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                ChoiceChip(
                  label: Text(tr('no_recurrence')),
                  selected: _recurrence == null,
                  onSelected: (_) => setState(() { _recurrence = null; _recurrenceEndDate = null; }),
                ),
                for (final r in ['daily', 'weekly', 'monthly', 'yearly'])
                  ChoiceChip(
                    label: Text(tr(r)),
                    selected: _recurrence == r,
                    onSelected: (sel) => setState(() {
                      _recurrence = sel ? r : null;
                      if (!sel) _recurrenceEndDate = null;
                    }),
                    selectedColor: colorScheme.primaryContainer,
                  ),
              ],
            ),
            if (_recurrence != null) ...[
              const SizedBox(height: 12),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: [
                  ChoiceChip(
                    label: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.all_inclusive, size: 16),
                        const SizedBox(width: 6),
                        Text(tr('forever')),
                      ],
                    ),
                    selected: _recurrenceEndDate == null,
                    onSelected: (_) => setState(() => _recurrenceEndDate = null),
                    selectedColor: colorScheme.primaryContainer,
                  ),
                  ChoiceChip(
                    label: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.event, size: 16),
                        const SizedBox(width: 6),
                        Text(_recurrenceEndDate != null
                            ? '${_recurrenceEndDate!.day}/${_recurrenceEndDate!.month}/${_recurrenceEndDate!.year}'
                            : tr('repeat_until')),
                      ],
                    ),
                    selected: _recurrenceEndDate != null,
                    onSelected: (_) async {
                      final picked = await showDatePicker(
                        context: context,
                        initialDate: _recurrenceEndDate ?? _startTime.add(const Duration(days: 30)),
                        firstDate: _startTime,
                        lastDate: DateTime(2100),
                      );
                      if (picked != null && mounted) setState(() => _recurrenceEndDate = picked);
                    },
                    selectedColor: colorScheme.primaryContainer,
                  ),
                ],
              ),
            ],
            if (_availableFriends.isNotEmpty) ...[
              const SizedBox(height: 24),
              Text(
                tr('share_with'),
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 12),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: _availableFriends.map((friend) {
                  final isSelected = _sharedWith.contains(friend);
                  return FilterChip(
                    avatar: CircleAvatar(
                      backgroundColor: colorScheme.primaryContainer,
                      child: Text(friend[0], style: TextStyle(fontSize: 12, color: colorScheme.primary)),
                    ),
                    label: Text(friend),
                    selected: isSelected,
                    onSelected: (selected) {
                      setState(() {
                        if (selected) {
                          _sharedWith.add(friend);
                        } else {
                          _sharedWith.remove(friend);
                        }
                      });
                    },
                    selectedColor: colorScheme.primaryContainer,
                  );
                }).toList(),
              ),
            ],
            const SizedBox(height: 24),
            Text(
              tr('attachment'),
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            if (_attachmentBase64 != null || _attachmentFilePath != null) ...[
              if (_attachmentFileName != null) ...[
                // File attachment preview
                Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12),
                    color: colorScheme.surfaceContainerLowest,
                    border: Border.all(color: colorScheme.outlineVariant),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.attach_file, color: colorScheme.primary),
                      const SizedBox(width: 12),
                      Expanded(child: Text(_attachmentFileName!, overflow: TextOverflow.ellipsis)),
                      GestureDetector(
                        onTap: () => setState(() { _attachmentBase64 = null; _attachmentFileName = null; _attachmentFilePath = null; }),
                        child: Icon(Icons.close, color: colorScheme.error, size: 20),
                      ),
                    ],
                  ),
                ),
              ] else ...[
                // Image attachment preview
                Stack(
                  children: [
                    StoredImage(
                      imagePath: _attachmentFilePath,
                      imageBase64: _attachmentBase64,
                      width: double.infinity,
                      height: 200,
                      fit: BoxFit.cover,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    Positioned(
                      top: 8,
                      right: 8,
                      child: GestureDetector(
                        onTap: () => setState(() { _attachmentBase64 = null; _attachmentFilePath = null; }),
                        child: Container(
                          padding: const EdgeInsets.all(6),
                          decoration: BoxDecoration(
                            color: colorScheme.error,
                            shape: BoxShape.circle,
                          ),
                          child: Icon(Icons.close, color: colorScheme.onError, size: 18),
                        ),
                      ),
                    ),
                  ],
                ),
              ],
              const SizedBox(height: 12),
            ] else
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: _pickPhoto,
                      icon: const Icon(Icons.add_a_photo),
                      label: Text(tr('insert_image')),
                      style: OutlinedButton.styleFrom(
                        minimumSize: const Size(0, 48),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: _pickFile,
                      icon: const Icon(Icons.attach_file),
                      label: Text(tr('from_file')),
                      style: OutlinedButton.styleFrom(
                        minimumSize: const Size(0, 48),
                      ),
                    ),
                  ),
                ],
              ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: FilledButton.icon(
                onPressed: _saveEvent,
                icon: const Icon(Icons.save),
                label: Text(tr('save')),
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    _titleController.dispose();
    super.dispose();
  }
} // SETTINGS PAGE

class SettingsPage extends StatefulWidget {
  final UserProfile userProfile;
  final String themeMode;
  final Function(String) onThemeModeChanged;
  final Function(String) onLocaleChanged;
  final Function(UserProfile) onSave;

  const SettingsPage({
    super.key,
    required this.userProfile,
    required this.themeMode,
    required this.onThemeModeChanged,
    required this.onLocaleChanged,
    required this.onSave,
  });

  @override
  State<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends State<SettingsPage> {
  late UserProfile _profile;
  EthosAuraSettings _auraSettings = const EthosAuraSettings();

  @override
  void initState() {
    super.initState();
    _loadAuraSettings();
    _profile = UserProfile(
      nome: widget.userProfile.nome,
      cognome: widget.userProfile.cognome,
      email: widget.userProfile.email,
      dataNascita: widget.userProfile.dataNascita,
      isPro: widget.userProfile.isPro,
      photoPath: widget.userProfile.photoPath,
      photoBase64: widget.userProfile.photoBase64,
      googleCalendarConnected: widget.userProfile.googleCalendarConnected,
      googleDriveConnected: widget.userProfile.googleDriveConnected,
      geminiConnected: widget.userProfile.geminiConnected,
      backupMode: widget.userProfile.backupMode,
      religione: widget.userProfile.religione,
      telefono: widget.userProfile.telefono,
      password: widget.userProfile.password,
      socialLinks: List<String>.from(widget.userProfile.socialLinks),
      friends: List<String>.from(widget.userProfile.friends),
      oldPhotos: List<String>.from(widget.userProfile.oldPhotos),
      accounts: widget.userProfile.accounts.map((e) => Map<String, String>.from(e)).toList(),
      activeAccountIndex: widget.userProfile.activeAccountIndex,
      nickname: widget.userProfile.nickname,
      lockDeepNote: widget.userProfile.lockDeepNote,
      lockFlashNotes: widget.userProfile.lockFlashNotes,
    );
  }

  Future<void> _loadAuraSettings() async {
    final s = await EthosAuraSettings.load();
    if (!mounted) return;
    setState(() => _auraSettings = s);
  }

  static bool _isBaseTheme(String mode) => mode == 'light' || mode == 'dark' || mode == 'ethos';

  static String _themeModeLabel(String mode) {
    switch (mode) {
      case 'light': return tr('light');
      case 'dark': return tr('dark');
      case 'ephemera': return 'Ephemera';
      case 'nordic_zen': return 'Nordic Zen';
      case 'green_salvia': return 'Green Salvia';
      case 'sakura': return 'Sakura';
      case 'spadaccino': return 'Spadaccino Errante';
      case 'sogno_re': return 'Sogno del Re';
      case 'mappa_tesoro': return 'Mappa del Tesoro';
      case 'fulmine': return 'Fulmine Vendicatore';
      case 'eremita': return 'Eremita Volpe';
      case 'saggio': return 'Saggio dei Rospi';
      case 'cabina_tempo': return 'Cabina del Tempo';
      case 'sottosopra': return 'Sottosopra';
      case 'rifugio': return 'Rifugio Atomico';
      case 'yellow_note': return 'Yellow Note';
      case 'deep_abyss': return 'Deep Abyss';
      case 'midnight_forest': return 'Midnight Forest';
      case 'cyberpunk_void': return 'Cyberpunk Void';
      case 'block_note': return 'Like a Block Note';
      default: return 'Ethos';
    }
  }

  void _saveProfile() {
    widget.onSave(_profile);
    Navigator.pop(context);
  }

  Future<void> _addPhoto() async {
    final hasPhoto = _profile.photoBase64 != null && _profile.photoBase64!.isNotEmpty;

    if (hasPhoto) {
      // Show options: change or remove
      final action = await showDialog<String>(
        context: context,
        builder: (context) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('profile_photo')),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: Icon(Icons.photo_library, color: Theme.of(context).colorScheme.primary),
                title: Text(tr('change_photo')),
                onTap: () => Navigator.pop(context, 'change'),
              ),
              ListTile(
                leading: Icon(Icons.delete_outline, color: Theme.of(context).colorScheme.error),
                title: Text(tr('remove_photo')),
                onTap: () => Navigator.pop(context, 'remove'),
              ),
            ],
          ),
        ),
      );

      if (!mounted) return;
      if (action == 'remove') {
        setState(() {
          _profile.photoBase64 = null;
          _profile.photoPath = null;
        });
        _saveProfile();
        return;
      }
      if (action != 'change') return;
    }

    try {
      final picker = ImagePicker();
      final XFile? image = await picker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 80,
      );
      if (!mounted) return;

      if (image != null) {
        final bytes = await image.readAsBytes();
        if (!mounted) return;
        final base64String = base64Encode(bytes);
        setState(() {
          // Save old photo to history (max 10)
          if (_profile.photoBase64 != null && _profile.photoBase64!.isNotEmpty) {
            _profile.oldPhotos.insert(0, _profile.photoBase64!);
            if (_profile.oldPhotos.length > 10) _profile.oldPhotos.removeLast();
          }
          _profile.photoBase64 = base64String;
        });
        _saveProfile();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${tr('photo_error')}: $e'),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  void _showProfileDetails() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (ctx) {
        final colorScheme = Theme.of(ctx).colorScheme;
        return DraggableScrollableSheet(
          initialChildSize: 0.7,
          minChildSize: 0.4,
          maxChildSize: 0.92,
          expand: false,
          builder: (ctx, scrollController) => SingleChildScrollView(
            controller: scrollController,
            padding: const EdgeInsets.all(20),
            child: Column(
              children: [
                Container(width: 40, height: 4, decoration: BoxDecoration(color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3), borderRadius: BorderRadius.circular(2))),
                const SizedBox(height: 20),
                // Avatar grande + camera
                Stack(
                  children: [
                    CircleAvatar(
                      radius: 60,
                      backgroundColor: _profile.photoBytes != null ? colorScheme.primary : Colors.transparent,
                      backgroundImage: _profile.photoBytes != null ? MemoryImage(_profile.photoBytes!) : null,
                      child: _profile.photoBytes == null ? ClipOval(child: Image.asset('assets/logo.png', width: 120, height: 120, fit: BoxFit.cover)) : null,
                    ),
                    Positioned(
                      bottom: 0, right: 0,
                      child: GestureDetector(
                        onTap: () { Navigator.pop(ctx); _addPhoto(); },
                        child: Container(
                          padding: const EdgeInsets.all(8),
                          decoration: BoxDecoration(color: colorScheme.primary, shape: BoxShape.circle),
                          child: Icon(Icons.camera_alt, color: colorScheme.onPrimary, size: 20),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(_profile.fullName, style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
                if (_profile.nickname != null && _profile.nickname!.isNotEmpty)
                  Text('@${_profile.nickname}', style: TextStyle(fontSize: 15, color: colorScheme.primary)),
                if (_profile.eta != null)
                  Text('${_profile.eta} ${tr('years_old')}', style: TextStyle(color: colorScheme.onSurfaceVariant)),
                const SizedBox(height: 16),
                FilledButton.icon(
                  onPressed: () { Navigator.pop(ctx); _showProfileEditor(); },
                  icon: const Icon(Icons.edit, size: 18),
                  label: Text(tr('edit')),
                  style: FilledButton.styleFrom(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
                ),

                const Divider(height: 32),
                if (!_profile.hasAccount) ...[
                  Text(tr('email'),
                      style: TextStyle(color: colorScheme.onSurfaceVariant, fontSize: 14)),
                  const SizedBox(height: 12),
                  SizedBox(
                    width: double.infinity,
                    child: FilledButton.icon(
                      onPressed: () {
                        Navigator.pop(ctx);
                        showDialog(
                          context: context,
                          builder: (context) {
                            final emailController = TextEditingController();
                            return AlertDialog(
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
                              title: Text(tr('email')),
                              content: TextField(
                                controller: emailController,
                                decoration: InputDecoration(
                                  labelText: tr('email'),
                                  hintText: tr('email_hint'),
                                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                                  prefixIcon: const Icon(Icons.email),
                                ),
                                keyboardType: TextInputType.emailAddress,
                              ),
                              actions: [
                                TextButton(onPressed: () => Navigator.pop(context), child: Text(tr('cancel'))),
                                FilledButton(
                                  onPressed: () {
                                    if (emailController.text.contains('@')) {
                                      setState(() => _profile.email = emailController.text);
                                      Navigator.pop(context);
                                    }
                                  },
                                  child: Text(tr('confirm')),
                                ),
                              ],
                            );
                          },
                        );
                      },
                      icon: const Icon(Icons.email),
                      label: Text(tr('email')),
                    ),
                  ),
                ] else
                  ListTile(
                    contentPadding: EdgeInsets.zero,
                    leading: const Icon(Icons.email_outlined),
                    title: Text(tr('email')),
                    subtitle: Text(_profile.email!),
                    dense: true,
                  ),
                ListTile(
                  contentPadding: EdgeInsets.zero,
                  leading: const Icon(Icons.phone_outlined),
                  title: Text(tr('phone')),
                  subtitle: Text(_profile.telefono ?? tr('not_set_m')),
                  trailing: const Icon(Icons.chevron_right, size: 20),
                  dense: true,
                  onTap: () { Navigator.pop(ctx); _showPhoneEditor(); },
                ),
                ListTile(
                  contentPadding: EdgeInsets.zero,
                  leading: const Icon(Icons.lock_outline),
                  title: Text(tr('password')),
                  subtitle: Text(_profile.password != null && _profile.password!.isNotEmpty ? '********' : tr('not_set_f')),
                  trailing: const Icon(Icons.chevron_right, size: 20),
                  dense: true,
                  onTap: () { Navigator.pop(ctx); _showPasswordEditor(); },
                ),
                // Cronologia Foto
                if (_profile.oldPhotos.isNotEmpty) ...[
                  const Divider(height: 32),
                  Row(
                    children: [
                      Icon(Icons.photo_library_outlined, color: colorScheme.primary),
                      const SizedBox(width: 8),
                      Text(tr('photo_history'), style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                    ],
                  ),
                  const SizedBox(height: 12),
                  SizedBox(
                    height: 80,
                    child: ListView.builder(
                      scrollDirection: Axis.horizontal,
                      itemCount: _profile.oldPhotos.length,
                      itemBuilder: (context, i) => Padding(
                        padding: const EdgeInsets.only(right: 8),
                        child: ClipRRect(
                          borderRadius: BorderRadius.circular(12),
                          child: Image.memory(
                            base64Decode(_profile.oldPhotos[i]),
                            width: 80, height: 80, fit: BoxFit.cover,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
                const SizedBox(height: 20),
              ],
            ),
          ),
        );
      },
    );
  }

  void _showProfileEditor() {
    final nomeController = TextEditingController(text: _profile.nome);
    final cognomeController = TextEditingController(text: _profile.cognome);
    final nicknameController = TextEditingController(text: _profile.nickname);
    DateTime selectedDate = _profile.dataNascita ?? DateTime(2000, 1, 1);

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) => AlertDialog(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(24),
          ),
          title: Text(tr('edit_profile')),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: nomeController,
                  decoration: InputDecoration(
                    labelText: tr('name'),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    prefixIcon: const Icon(Icons.person),
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: cognomeController,
                  decoration: InputDecoration(
                    labelText: tr('surname'),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    prefixIcon: const Icon(Icons.person_outline),
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: nicknameController,
                  decoration: InputDecoration(
                    labelText: tr('nickname'),
                    hintText: tr('nickname_hint'),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    prefixIcon: const Icon(Icons.alternate_email),
                  ),
                ),
                const SizedBox(height: 12),
                InkWell(
                  onTap: () async {
                    final picked = await showDatePicker(
                      context: context,
                      initialDate: selectedDate,
                      firstDate: DateTime(1900),
                      lastDate: DateTime.now(),
                    );
                    if (picked != null) {
                      setDialogState(() {
                        selectedDate = picked;
                      });
                    }
                  },
                  child: InputDecorator(
                    decoration: InputDecoration(
                      labelText: tr('birth_date'),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      prefixIcon: const Icon(Icons.cake),
                    ),
                    child: Text(
                      '${selectedDate.day}/${selectedDate.month}/${selectedDate.year}',
                      style: const TextStyle(fontSize: 16),
                    ),
                  ),
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(tr('cancel')),
            ),
            ElevatedButton(
              onPressed: () {
                setState(() {
                  _profile.nome = nomeController.text;
                  _profile.cognome = cognomeController.text;
                  _profile.nickname = nicknameController.text.isEmpty ? null : nicknameController.text;
                  _profile.dataNascita = selectedDate;
                });
                Navigator.pop(context);
              },
              child: Text(tr('save')),
            ),
          ],
        ),
      ),
    );
  }

  void _showPhoneEditor() {
    final controller = TextEditingController(text: _profile.telefono ?? '');
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('phone')),
        content: TextField(
          controller: controller,
          decoration: InputDecoration(
            labelText: tr('phone'),
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
            prefixIcon: const Icon(Icons.phone),
          ),
          keyboardType: TextInputType.phone,
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () {
              setState(() => _profile.telefono = controller.text.isEmpty ? null : controller.text);
              Navigator.pop(context);
            },
            child: Text(tr('save')),
          ),
        ],
      ),
    );
  }

  void _showPasswordEditor() {
    final oldController = TextEditingController();
    final newController = TextEditingController();
    String? error;
    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('change_pin')),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (_profile.password != null && _profile.password!.isNotEmpty)
                TextField(
                  controller: oldController,
                  obscureText: true,
                  decoration: InputDecoration(
                    labelText: tr('password'),
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                    prefixIcon: const Icon(Icons.lock_outline),
                    errorText: error,
                  ),
                ),
              if (_profile.password != null && _profile.password!.isNotEmpty) const SizedBox(height: 12),
              TextField(
                controller: newController,
                obscureText: true,
                decoration: InputDecoration(
                  labelText: tr('password'),
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                  prefixIcon: const Icon(Icons.lock),
                ),
              ),
            ],
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context), child: Text(tr('cancel'))),
            FilledButton(
              onPressed: () {
                if (_profile.password != null && _profile.password!.isNotEmpty && oldController.text != _profile.password) {
                  setDialogState(() => error = tr('wrong_password'));
                  return;
                }
                setState(() => _profile.password = newController.text.isEmpty ? null : newController.text);
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(tr('success')),
                    behavior: SnackBarBehavior.floating,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  ),
                );
              },
              child: Text(tr('save')),
            ),
          ],
        ),
      ),
    );
  }

  void _shareProfile() {
    final vcard = StringBuffer();
    vcard.writeln('BEGIN:VCARD');
    vcard.writeln('VERSION:3.0');
    vcard.writeln('FN:${_profile.fullName}');
    if (_profile.nome != null) vcard.writeln('N:${_profile.cognome ?? ''};${_profile.nome};;;');
    if (_profile.email != null) vcard.writeln('EMAIL:${_profile.email}');
    if (_profile.telefono != null) vcard.writeln('TEL:${_profile.telefono}');
    for (final link in _profile.socialLinks) {
      vcard.writeln('URL:$link');
    }
    vcard.writeln('END:VCARD');
    Clipboard.setData(ClipboardData(text: vcard.toString()));
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(tr('copied_to_clipboard')),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );
  }

  void _addSocialLink() {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('add_social_link')),
        content: TextField(
          controller: controller,
          decoration: InputDecoration(
            labelText: tr('url_or_username'),
            hintText: 'https://...',
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
            prefixIcon: const Icon(Icons.link),
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () {
              if (controller.text.isNotEmpty) {
                setState(() => _profile.socialLinks.add(controller.text));
                Navigator.pop(context);
              }
            },
            child: Text(tr('add')),
          ),
        ],
      ),
    );
  }

  void _addFriend() {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('add_friend')),
        content: TextField(
          controller: controller,
          decoration: InputDecoration(
            labelText: tr('friend_name'),
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
            prefixIcon: const Icon(Icons.person_add),
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () {
              if (controller.text.isNotEmpty) {
                setState(() => _profile.friends.add(controller.text));
                Navigator.pop(context);
              }
            },
            child: Text(tr('add')),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(
        title: Text(tr('profile')),
        elevation: 0,
        scrolledUnderElevation: 2,
        actions: [
          FilledButton.icon(
            onPressed: _saveProfile,
            icon: const Icon(Icons.check, size: 18),
            label: Text(tr('save')),
            style: FilledButton.styleFrom(
              backgroundColor: colorScheme.primary,
              foregroundColor: colorScheme.onPrimary,
            ),
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // --- CARD 1: Profilo (compatto — tap foto per dettagli) ---
          Card(
            elevation: 0,
            color: colorScheme.surfaceContainerLowest,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                children: [
                  GestureDetector(
                    onTap: _showProfileDetails,
                    child: CircleAvatar(
                      radius: 50,
                      backgroundColor: _profile.photoBytes != null
                          ? colorScheme.primary
                          : Colors.transparent,
                      backgroundImage: _profile.photoBytes != null
                          ? MemoryImage(_profile.photoBytes!)
                          : null,
                      child: _profile.photoBytes == null
                          ? ClipOval(child: Image.asset('assets/logo.png', width: 100, height: 100, fit: BoxFit.cover))
                          : null,
                    ),
                  ),
                  const SizedBox(height: 12),
                  Text(
                    _profile.fullName,
                    style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
                  ),
                  if (_profile.nickname != null && _profile.nickname!.isNotEmpty)
                    Text('@${_profile.nickname}', style: TextStyle(fontSize: 14, color: colorScheme.primary)),
                  const SizedBox(height: 4),
                  Text(tr('profile'), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.6))),
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // --- CARD: Impostazioni Generali ---
          Padding(
            padding: const EdgeInsets.only(left: 4, bottom: 6),
            child: Text(tr('settings_section'), style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600, color: colorScheme.onSurfaceVariant)),
          ),
          Card(
            elevation: 0,
            color: colorScheme.surfaceContainerLowest,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: ListTile(
              leading: Container(
                padding: const EdgeInsets.all(6),
                decoration: BoxDecoration(
                  color: colorScheme.primary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(Icons.settings, color: colorScheme.primary, size: 22),
              ),
              title: Text(tr('general_settings'), style: const TextStyle(fontWeight: FontWeight.bold)),
              trailing: const Icon(Icons.chevron_right),
              onTap: () {
                Navigator.push(context, MaterialPageRoute(
                  builder: (_) => GeneralSettingsPage(
                    profile: _profile,
                    themeMode: widget.themeMode,
                    onLocaleChanged: widget.onLocaleChanged,
                    onProfileChanged: (p) {
                      setState(() => _profile = p);
                      widget.onSave(p);
                    },
                  ),
                )).then((_) { if (mounted) setState(() {}); });
              },
            ),
          ),
          const SizedBox(height: 16),

          // --- CARD: App (Tema, Deep Note, Calendario, Flash Notes) ---
          Padding(
            padding: const EdgeInsets.only(left: 4, bottom: 6),
            child: Text(tr('app_section'), style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600, color: colorScheme.onSurfaceVariant)),
          ),
          Card(
            elevation: 0,
            color: colorScheme.surfaceContainerLowest,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Column(
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 12, 16, 4),
                  child: Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.all(6),
                        decoration: BoxDecoration(
                          color: Colors.deepPurple.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: const Icon(Icons.palette, color: Colors.deepPurple, size: 22),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(tr('theme'), style: const TextStyle(fontSize: 16)),
                            Text(_themeModeLabel(widget.themeMode), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                          ],
                        ),
                      ),
                      IconButton(
                        icon: const Icon(Icons.chevron_right),
                        tooltip: tr('theme_catalog'),
                        onPressed: () {
                          Navigator.push(context, MaterialPageRoute(
                            builder: (_) => _ThemeCatalogPage(
                              currentTheme: widget.themeMode,
                              auraSettings: _auraSettings,
                              onThemeSelected: (mode) {
                                widget.onThemeModeChanged(mode);
                                setState(() {});
                              },
                              onAuraSettingsChanged: () => _loadAuraSettings(),
                            ),
                          ));
                        },
                      ),
                    ],
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 0, 16, 12),
                  child: SizedBox(
                    width: double.infinity,
                    child: SegmentedButton<String>(
                      segments: const [
                        ButtonSegment(value: 'light', icon: Icon(Icons.light_mode, size: 18)),
                        ButtonSegment(value: 'dark', icon: Icon(Icons.dark_mode, size: 18)),
                        ButtonSegment(value: 'ethos', icon: Icon(Icons.auto_awesome, size: 18)),
                      ],
                      selected: {_isBaseTheme(widget.themeMode) ? widget.themeMode : 'ethos'},
                      onSelectionChanged: (sel) => widget.onThemeModeChanged(sel.first),
                      showSelectedIcon: false,
                      style: const ButtonStyle(visualDensity: VisualDensity.compact),
                    ),
                  ),
                ),
                const Divider(height: 1),
                ListTile(
                  leading: Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: const Color(0xFFE53935).withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(Icons.note, color: Color(0xFFE53935), size: 22),
                  ),
                  title: Text(tr('deep_note_settings'), style: const TextStyle(fontWeight: FontWeight.bold)),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () async {
                    final currentSettings = await NoteProSettings.load();
                    if (!context.mounted) return;
                    Navigator.push(context, MaterialPageRoute(
                      builder: (context) => NoteProSettingsPage(settings: currentSettings, onSave: (s) => s.save()),
                    ));
                  },
                ),
                ListTile(
                  leading: Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: const Color(0xFF1E88E5).withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const _CalendarIcon9(size: 22, color: Color(0xFF1E88E5)),
                  ),
                  title: Text(tr('calendar_settings'), style: const TextStyle(fontWeight: FontWeight.bold)),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () async {
                    final currentSettings = await CalendarSettings.load();
                    if (!context.mounted) return;
                    Navigator.push(context, MaterialPageRoute(
                      builder: (context) => CalendarSettingsPage(settings: currentSettings, onSave: (s) => s.save()),
                    ));
                  },
                ),
                ListTile(
                  leading: Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: const Color(0xFFFFA726).withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(Icons.flash_on, color: Color(0xFFFFA726), size: 22),
                  ),
                  title: Text(tr('flash_notes_settings'), style: const TextStyle(fontWeight: FontWeight.bold)),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () async {
                    final currentSettings = await FlashNotesSettings.load();
                    if (!context.mounted) return;
                    Navigator.push(context, MaterialPageRoute(
                      builder: (context) => FlashNotesSettingsPage(settings: currentSettings, onSave: (s) => s.save()),
                    ));
                  },
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),

          // --- CARD: Altro (Ethos Aura, Cestino, Info) ---
          Padding(
            padding: const EdgeInsets.only(left: 4, bottom: 6),
            child: Text(tr('other_section'), style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600, color: colorScheme.onSurfaceVariant)),
          ),
          Card(
            elevation: 0,
            color: colorScheme.surfaceContainerLowest,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Column(
              children: [
                ListTile(
                  leading: Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: const Color(0xFFAB47BC).withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(Icons.auto_awesome, color: Color(0xFFAB47BC), size: 22),
                  ),
                  title: Text(tr('ethos_aura'), style: const TextStyle(fontWeight: FontWeight.bold)),
                  subtitle: Text(tr('ethos_aura_desc'), style: const TextStyle(fontSize: 12)),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () {
                    Navigator.push(context, MaterialPageRoute(builder: (context) => const EthosAuraPage()));
                  },
                ),
                const Divider(height: 1),
                ListTile(
                  leading: Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: colorScheme.error.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Icon(Icons.delete_outline, color: colorScheme.error, size: 22),
                  ),
                  title: Text(tr('trash'), style: const TextStyle(fontWeight: FontWeight.bold)),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () {
                    Navigator.push(context, MaterialPageRoute(builder: (context) => const TrashPage()));
                  },
                ),
                const Divider(height: 1),
                ListTile(
                  leading: Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: colorScheme.primary.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Icon(Icons.info_outline, color: colorScheme.primary, size: 22),
                  ),
                  title: Text(tr('info')),
                  subtitle: Text('${tr('version')} 1.0.0'),
                  onTap: () {
                    showDialog(
                      context: context,
                      builder: (context) => AlertDialog(
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
                        title: const Text('Ethos Note') /* brand name */,
                        content: Text('${tr('version')} 1.0.0\n\n© 2025 Ethos Note'),
                        actions: [
                          TextButton(onPressed: () => Navigator.pop(context), child: Text(tr('ok'))),
                        ],
                      ),
                    );
                  },
                ),
              ],
            ),
          ),
          if (GoogleCalendarService.isSignedIn) ...[
            const SizedBox(height: 16),
            Padding(
              padding: const EdgeInsets.only(left: 4, bottom: 6),
              child: Text(tr('account'), style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600, color: colorScheme.onSurfaceVariant)),
            ),
            Card(
              elevation: 0,
              color: colorScheme.surfaceContainerLowest,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              child: Column(
                children: [
                  ListTile(
                    leading: Container(
                      padding: const EdgeInsets.all(6),
                      decoration: BoxDecoration(
                        color: Colors.green.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Icon(Icons.account_circle, color: Colors.green.shade600, size: 22),
                    ),
                    title: Text('${tr('signed_in_as')}', style: const TextStyle(fontSize: 13)),
                    subtitle: Text(GoogleCalendarService.userEmail ?? '', style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                  ),
                  const Divider(height: 1),
                  ListTile(
                    leading: Container(
                      padding: const EdgeInsets.all(6),
                      decoration: BoxDecoration(
                        color: colorScheme.error.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Icon(Icons.logout, color: colorScheme.error, size: 22),
                    ),
                    title: Text(tr('sign_out'), style: TextStyle(color: colorScheme.error, fontWeight: FontWeight.w600)),
                    onTap: () async {
                      await GoogleCalendarService.signOut();
                      if (!mounted) return;
                      _profile.googleCalendarConnected = false;
                      widget.onSave(_profile);
                      setState(() {});
                    },
                  ),
                ],
              ),
            ),
          ],
          const SizedBox(height: 40),
        ],
      ),
    );
  }

}

// ─── General Settings Page ────────────────────────────────────────

class GeneralSettingsPage extends StatefulWidget {
  final UserProfile profile;
  final String themeMode;
  final Function(String) onLocaleChanged;
  final Function(UserProfile) onProfileChanged;

  const GeneralSettingsPage({
    super.key,
    required this.profile,
    required this.themeMode,
    required this.onLocaleChanged,
    required this.onProfileChanged,
  });

  @override
  State<GeneralSettingsPage> createState() => _GeneralSettingsPageState();
}

class _GeneralSettingsPageState extends State<GeneralSettingsPage> {
  late UserProfile _profile;
  String? _biometricPin;
  String _backupDestination = 'device';
  String _autoBackupMode = 'off';
  String? _lastBackupDate;
  bool _isBackingUp = false;

  @override
  void initState() {
    super.initState();
    _profile = widget.profile;
    _loadBiometricPin();
    _loadBackupSettings();
  }

  Future<void> _loadBackupSettings() async {
    final db = DatabaseHelper();
    final dest = await db.getSetting('backup_destination');
    final mode = await db.getSetting('auto_backup_mode');
    final lastDate = await db.getSetting('last_backup_date');
    if (mounted) {
      setState(() {
        _backupDestination = dest ?? 'device';
        _autoBackupMode = mode ?? 'off';
        _lastBackupDate = lastDate;
      });
    }
  }

  Future<void> _loadBiometricPin() async {
    final pin = await DatabaseHelper().getCache('biometric_pin');
    if (mounted) setState(() => _biometricPin = pin);
  }

  Future<void> _saveBiometricPin(String pin) async {
    await DatabaseHelper().saveCache('biometric_pin', pin);
    if (mounted) setState(() => _biometricPin = pin);
  }

  Future<Uint8List> _buildBackupZipBytes() async {
    final dbPath = await getDatabasesPath();
    final sourcePath = p.join(dbPath, 'ethos_note.db');
    final sourceFile = File(sourcePath);

    // Flush WAL data into the main DB file before reading
    final db = await DatabaseHelper().database;
    await db.rawQuery('PRAGMA wal_checkpoint(TRUNCATE)');

    final zip = archive.Archive();

    // Add database file
    final dbBytes = await sourceFile.readAsBytes();
    zip.addFile(archive.ArchiveFile('ethos_note.db', dbBytes.length, dbBytes));

    // Add images directory
    final imgDir = await ImageStorageHelper().imagesDir;
    if (await imgDir.exists()) {
      await for (final entity in imgDir.list()) {
        if (entity is File) {
          final fileName = p.basename(entity.path);
          final fileBytes = await entity.readAsBytes();
          zip.addFile(archive.ArchiveFile('images/$fileName', fileBytes.length, fileBytes));
        }
      }
    }

    return Uint8List.fromList(archive.ZipEncoder().encode(zip));
  }

  Future<void> _exportBackup() async {
    try {
      final dbPath = await getDatabasesPath();
      final sourcePath = p.join(dbPath, 'ethos_note.db');
      final sourceFile = File(sourcePath);
      if (!await sourceFile.exists()) return;

      final now = DateTime.now();
      final zipFileName = 'ethos_note_backup_${now.year}${now.month.toString().padLeft(2, '0')}${now.day.toString().padLeft(2, '0')}_${now.hour.toString().padLeft(2, '0')}${now.minute.toString().padLeft(2, '0')}.zip';

      final zipBytes = await _buildBackupZipBytes();

      // Save via file picker
      final result = await FilePicker.platform.saveFile(
        dialogTitle: tr('backup_export'),
        fileName: zipFileName,
        bytes: zipBytes,
      );

      if (!mounted) return;
      if (result != null) {
        // Save last backup date
        final nowIso = DateTime.now().toIso8601String();
        await DatabaseHelper().saveSetting('last_backup_date', nowIso);
        if (mounted) setState(() => _lastBackupDate = nowIso);

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(tr('backup_exported')),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('backup_error')}: $e'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  Future<void> _importBackup() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        dialogTitle: tr('backup_import'),
        type: FileType.any,
      );
      if (result == null || result.files.single.path == null) return;
      if (!mounted) return;

      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('backup_import')),
          content: Text(tr('backup_import_confirm')),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
            FilledButton(onPressed: () => Navigator.pop(ctx, true), child: Text(tr('backup_import'))),
          ],
        ),
      );
      if (confirmed != true || !mounted) return;

      final pickedFile = File(result.files.single.path!);
      final fileBytes = await pickedFile.readAsBytes();
      final dbPath = await getDatabasesPath();
      final targetPath = p.join(dbPath, 'ethos_note.db');

      // Close the current database connection
      await DatabaseHelper().close();

      // Detect format: ZIP (PK magic) vs legacy .db
      final isZip = fileBytes.length >= 4 && fileBytes[0] == 0x50 && fileBytes[1] == 0x4B;

      if (isZip) {
        final zip = archive.ZipDecoder().decodeBytes(fileBytes);
        for (final file in zip) {
          if (file.isFile) {
            if (file.name == 'ethos_note.db') {
              await File(targetPath).writeAsBytes(file.content as List<int>);
            } else if (file.name.startsWith('images/')) {
              final imgDir = await ImageStorageHelper().imagesDir;
              final imgFile = File(p.join(imgDir.path, p.basename(file.name)));
              await imgFile.writeAsBytes(file.content as List<int>);
            }
          }
        }
      } else {
        // Legacy .db file — copy directly, migration will run on next restart
        await pickedFile.copy(targetPath);
      }

      if (!mounted) return;
      await showDialog(
        context: context,
        barrierDismissible: false,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('backup_imported')),
          content: Text(tr('app_will_close_reopen')),
          actions: [
            FilledButton(
              onPressed: () {
                Navigator.pop(ctx);
                SystemNavigator.pop();
              },
              child: Text(tr('ok')),
            ),
          ],
        ),
      );
    } catch (e) {
      // Re-open DB on error so the app remains functional
      await DatabaseHelper().database;
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('backup_error')}: $e'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  Future<bool> _ensureGoogleDriveSignIn() async {
    if (GoogleCalendarService.isSignedIn) return true;
    // Try silent sign-in first
    final silent = await GoogleCalendarService.trySilentSignIn();
    if (silent) return true;
    // Prompt interactive sign-in
    final ok = await GoogleCalendarService.signIn();
    return ok;
  }

  Future<void> _exportBackupToDrive({int retryCount = 0}) async {
    setState(() => _isBackingUp = true);
    try {
      final signedIn = await _ensureGoogleDriveSignIn();
      if (!signedIn) {
        if (!mounted) return;
        setState(() => _isBackingUp = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(tr('backup_error')),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
        return;
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('backup_uploading')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );

      final driveApi = await GoogleCalendarService.getDriveApi();
      if (driveApi == null) throw Exception('Drive API unavailable');

      final zipBytes = await _buildBackupZipBytes();

      final now = DateTime.now();
      final fileName = 'ethos_note_backup_${now.year}${now.month.toString().padLeft(2, '0')}${now.day.toString().padLeft(2, '0')}_${now.hour.toString().padLeft(2, '0')}${now.minute.toString().padLeft(2, '0')}.zip';

      final driveFile = gdrive.File()
        ..name = fileName
        ..parents = ['appDataFolder'];

      await driveApi.files.create(
        driveFile,
        uploadMedia: gdrive.Media(
          Stream.value(zipBytes),
          zipBytes.length,
        ),
      );

      // Save last backup date
      final nowIso = now.toIso8601String();
      await DatabaseHelper().saveSetting('last_backup_date', nowIso);

      // Cleanup old backups (keep last 5)
      await _cleanupOldDriveBackups(driveApi);

      if (!mounted) return;
      setState(() {
        _isBackingUp = false;
        _lastBackupDate = nowIso;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('backup_exported')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    } catch (e) {
      if (!mounted) return;
      setState(() => _isBackingUp = false);

      // Handle 403 scope upgrade: sign out and re-sign in (max 1 retry)
      if (retryCount < 1 &&
          (e.toString().contains('403') || e.toString().contains('insufficientPermissions'))) {
        await GoogleCalendarService.signOut();
        final ok = await GoogleCalendarService.signIn();
        if (ok && mounted) {
          _exportBackupToDrive(retryCount: retryCount + 1);
          return;
        }
      }

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('backup_error')}: $e'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  Future<void> _importBackupFromDrive() async {
    setState(() => _isBackingUp = true);
    try {
      final signedIn = await _ensureGoogleDriveSignIn();
      if (!signedIn) {
        if (!mounted) return;
        setState(() => _isBackingUp = false);
        return;
      }

      final driveApi = await GoogleCalendarService.getDriveApi();
      if (driveApi == null) throw Exception('Drive API unavailable');

      // List backup files in appDataFolder
      final fileList = await driveApi.files.list(
        spaces: 'appDataFolder',
        q: "name contains 'ethos_note_backup'",
        orderBy: 'createdTime desc',
        pageSize: 1,
        $fields: 'files(id,name,createdTime,size)',
      );

      if (!mounted) return;

      if (fileList.files == null || fileList.files!.isEmpty) {
        setState(() => _isBackingUp = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(tr('no_backup_found')),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
        return;
      }

      final latestFile = fileList.files!.first;
      final backupDate = latestFile.createdTime != null
          ? _formatBackupDate(latestFile.createdTime!.toIso8601String())
          : '?';

      // Confirm with user
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('backup_from_drive')),
          content: Text('${tr('backup_import_confirm')}\n\n${latestFile.name}\n$backupDate'),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
            FilledButton(onPressed: () => Navigator.pop(ctx, true), child: Text(tr('backup_import'))),
          ],
        ),
      );
      if (confirmed != true || !mounted) {
        setState(() => _isBackingUp = false);
        return;
      }

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('backup_downloading')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );

      // Download the file
      final media = await driveApi.files.get(
        latestFile.id!,
        downloadOptions: gdrive.DownloadOptions.fullMedia,
      ) as gdrive.Media;

      final chunks = <int>[];
      await for (final chunk in media.stream) {
        chunks.addAll(chunk);
      }
      final fileBytes = Uint8List.fromList(chunks);

      // Close DB and extract
      await DatabaseHelper().close();

      final dbPath = await getDatabasesPath();
      final targetPath = p.join(dbPath, 'ethos_note.db');

      final isZip = fileBytes.length >= 4 && fileBytes[0] == 0x50 && fileBytes[1] == 0x4B;
      if (isZip) {
        final zip = archive.ZipDecoder().decodeBytes(fileBytes);
        for (final file in zip) {
          if (file.isFile) {
            if (file.name == 'ethos_note.db') {
              await File(targetPath).writeAsBytes(file.content as List<int>);
            } else if (file.name.startsWith('images/')) {
              final imgDir = await ImageStorageHelper().imagesDir;
              final imgFile = File(p.join(imgDir.path, p.basename(file.name)));
              await imgFile.writeAsBytes(file.content as List<int>);
            }
          }
        }
      } else {
        await File(targetPath).writeAsBytes(fileBytes);
      }

      if (!mounted) return;
      setState(() => _isBackingUp = false);
      await showDialog(
        context: context,
        barrierDismissible: false,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('backup_imported')),
          content: Text(tr('app_will_close_reopen')),
          actions: [
            FilledButton(
              onPressed: () {
                Navigator.pop(ctx);
                SystemNavigator.pop();
              },
              child: Text(tr('ok')),
            ),
          ],
        ),
      );
    } catch (e) {
      // Re-open DB on error so the app remains functional
      await DatabaseHelper().database;
      if (!mounted) return;
      setState(() => _isBackingUp = false);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('backup_error')}: $e'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  Future<void> _cleanupOldDriveBackups(gdrive.DriveApi driveApi) async {
    try {
      final fileList = await driveApi.files.list(
        spaces: 'appDataFolder',
        q: "name contains 'ethos_note_backup'",
        orderBy: 'createdTime desc',
        pageSize: 20,
        $fields: 'files(id,name,createdTime)',
      );
      if (fileList.files == null || fileList.files!.length <= 5) return;
      // Delete all but the 5 most recent
      for (var i = 5; i < fileList.files!.length; i++) {
        final fileId = fileList.files![i].id;
        if (fileId != null) {
          await driveApi.files.delete(fileId);
        }
      }
    } catch (e) {
      if (kDebugMode) debugPrint('Cleanup old Drive backups error: $e');
    }
  }

  String _formatBackupDate(String isoDate) {
    try {
      final dt = DateTime.parse(isoDate).toLocal();
      return '${dt.day.toString().padLeft(2, '0')}/${dt.month.toString().padLeft(2, '0')}/${dt.year} ${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } catch (_) {
      return isoDate;
    }
  }

  Future<bool> _authenticateBiometric() async {
    final localAuth = LocalAuthentication();
    final canAuth = await localAuth.canCheckBiometrics || await localAuth.isDeviceSupported();
    if (!canAuth) return false;
    try {
      return await localAuth.authenticate(
        localizedReason: tr('authenticate_to_change'),
        options: const AuthenticationOptions(biometricOnly: false),
      );
    } catch (_) {
      return false;
    }
  }

  Future<void> _showSetPinDialog() async {
    final pinController = TextEditingController();
    final confirmController = TextEditingController();
    final result = await showDialog<String>(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('set_pin')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: pinController,
              keyboardType: TextInputType.number,
              maxLength: 4,
              obscureText: true,
              decoration: InputDecoration(
                labelText: tr('enter_4_digit_pin'),
                counterText: '',
                prefixIcon: const Icon(Icons.pin),
              ),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: confirmController,
              keyboardType: TextInputType.number,
              maxLength: 4,
              obscureText: true,
              decoration: InputDecoration(
                labelText: tr('confirm_4_digit_pin'),
                counterText: '',
                prefixIcon: const Icon(Icons.pin),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
          FilledButton(onPressed: () {
            if (pinController.text.length == 4 && pinController.text == confirmController.text) {
              Navigator.pop(ctx, pinController.text);
            }
          }, child: Text(tr('confirm'))),
        ],
      ),
    );
    if (result != null && result.length == 4) {
      await _saveBiometricPin(result);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(tr('pin_created')), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
        );
      }
    }
  }

  Future<void> _toggleLock(bool value, bool Function() getCurrent, void Function(bool) setter) async {
    if (value) {
      // Activating: require PIN setup if no PIN, then set
      if (_biometricPin == null || _biometricPin!.length != 4) {
        await _showSetPinDialog();
        if (!mounted) return;
        if (_biometricPin == null || _biometricPin!.length != 4) return;
      }
      setter(value);
      widget.onProfileChanged(_profile);
    } else {
      // Deactivating: require biometric auth
      final authenticated = await _authenticateBiometric();
      if (!mounted) return;
      if (!authenticated) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(tr('auth_required')), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
          );
        }
        return;
      }
      setter(value);
      widget.onProfileChanged(_profile);
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: Text(tr('general_settings')),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // ── Integrazioni ──
          Card(
            elevation: 0,
            color: colorScheme.surfaceContainerLowest,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: ListTile(
              leading: Icon(Icons.extension, color: colorScheme.primary),
              title: Text(tr('integrations'), style: const TextStyle(fontWeight: FontWeight.bold)),
              trailing: const Icon(Icons.chevron_right),
              onTap: () {
                Navigator.push(context, MaterialPageRoute(builder: (_) => const IntegrationsPage())).then((_) {
                  setState(() {});
                });
              },
            ),
          ),
          const SizedBox(height: 12),

          // ── Lingua ──
          Card(
            elevation: 0,
            color: colorScheme.surfaceContainerLowest,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.all(6),
                        decoration: BoxDecoration(
                          color: Colors.blue.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: const Icon(Icons.language, color: Colors.blue, size: 22),
                      ),
                      const SizedBox(width: 16),
                      Text(tr('language'), style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                    ],
                  ),
                  const SizedBox(height: 10),
                  SizedBox(
                    width: double.infinity,
                    child: SegmentedButton<String>(
                      segments: const [
                        ButtonSegment(value: 'it', label: Text('Italiano', style: TextStyle(fontSize: 12))),
                        ButtonSegment(value: 'en', label: Text('English', style: TextStyle(fontSize: 12))),
                        ButtonSegment(value: 'fr', label: Text('Français', style: TextStyle(fontSize: 12))),
                        ButtonSegment(value: 'es', label: Text('Español', style: TextStyle(fontSize: 12))),
                      ],
                      selected: {_appLocale},
                      onSelectionChanged: (sel) => widget.onLocaleChanged(sel.first),
                      showSelectedIcon: false,
                      style: const ButtonStyle(visualDensity: VisualDensity.compact),
                    ),
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 12),

          // ── Backup ──
          Card(
            elevation: 0,
            color: colorScheme.surfaceContainerLowest,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Column(
              children: [
                ListTile(
                  leading: Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: Colors.teal.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(Icons.backup, color: Colors.teal, size: 22),
                  ),
                  title: Text(tr('backup')),
                  subtitle: Text(tr('backup_destination')),
                ),

                // Destination SegmentedButton
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: SizedBox(
                    width: double.infinity,
                    child: SegmentedButton<String>(
                      showSelectedIcon: false,
                      style: ButtonStyle(
                        visualDensity: VisualDensity.compact,
                        textStyle: WidgetStatePropertyAll(TextStyle(fontSize: 12)),
                      ),
                      segments: [
                        ButtonSegment(value: 'device', label: Text(tr('backup_device')), icon: const Icon(Icons.phone_android, size: 16)),
                        ButtonSegment(value: 'drive', label: Text(tr('backup_google_drive')), icon: const Icon(Icons.cloud, size: 16)),
                      ],
                      selected: {_backupDestination},
                      onSelectionChanged: (sel) async {
                        if (sel.first == _backupDestination) return;
                        final destLabel = sel.first == 'drive' ? tr('backup_google_drive') : tr('backup_device');
                        final confirmed = await showDialog<bool>(
                          context: context,
                          builder: (ctx) => AlertDialog(
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
                            icon: Icon(sel.first == 'drive' ? Icons.cloud : Icons.phone_android, size: 32, color: colorScheme.primary),
                            title: Text(tr('backup_dest_confirm_title')),
                            content: Text(tr('backup_dest_confirm_body').replaceAll('{dest}', destLabel)),
                            actions: [
                              TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
                              FilledButton(onPressed: () => Navigator.pop(ctx, true), child: Text(tr('confirm'))),
                            ],
                          ),
                        );
                        if (confirmed != true || !mounted) return;
                        setState(() => _backupDestination = sel.first);
                        await DatabaseHelper().saveSetting('backup_destination', sel.first);
                        if (mounted) {
                          ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                            content: Text('${tr('backup_destination')}: $destLabel'),
                            behavior: SnackBarBehavior.floating,
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                            duration: const Duration(seconds: 2),
                          ));
                        }
                      },
                    ),
                  ),
                ),

                // Info text: where future backups will go
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 6, 16, 8),
                  child: Row(
                    children: [
                      Icon(Icons.info_outline, size: 14, color: colorScheme.onSurfaceVariant),
                      const SizedBox(width: 6),
                      Expanded(
                        child: Text(
                          tr('backup_dest_info').replaceAll('{dest}', _backupDestination == 'drive' ? tr('backup_google_drive') : tr('backup_device')),
                          style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 4),

                // Connect Google Drive button (if Drive selected but not signed in)
                if (_backupDestination == 'drive' && !GoogleCalendarService.isSignedIn)
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    child: SizedBox(
                      width: double.infinity,
                      child: OutlinedButton.icon(
                        onPressed: () async {
                          final ok = await GoogleCalendarService.signIn();
                          if (ok && mounted) setState(() {});
                        },
                        icon: const Icon(Icons.link, size: 18),
                        label: Text(tr('connect_google_drive'), style: const TextStyle(fontSize: 13)),
                        style: OutlinedButton.styleFrom(
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        ),
                      ),
                    ),
                  ),

                // Export / Import buttons
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 4, 16, 12),
                  child: Row(
                    children: [
                      Expanded(
                        child: OutlinedButton.icon(
                          onPressed: _isBackingUp
                              ? null
                              : (_backupDestination == 'drive' ? _exportBackupToDrive : _exportBackup),
                          icon: _isBackingUp
                              ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2))
                              : const Icon(Icons.upload, size: 18),
                          label: Text(tr('backup_export'), style: const TextStyle(fontSize: 13)),
                          style: OutlinedButton.styleFrom(
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          ),
                        ),
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: OutlinedButton.icon(
                          onPressed: _isBackingUp
                              ? null
                              : (_backupDestination == 'drive' ? _importBackupFromDrive : _importBackup),
                          icon: const Icon(Icons.download, size: 18),
                          label: Text(tr('backup_import'), style: const TextStyle(fontSize: 13)),
                          style: OutlinedButton.styleFrom(
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),

                Divider(height: 1, indent: 16, endIndent: 16, color: colorScheme.outlineVariant.withValues(alpha: 0.5)),

                // Auto-backup section
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 12, 16, 4),
                  child: Align(
                    alignment: Alignment.centerLeft,
                    child: Text(tr('backup_auto'), style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600, color: colorScheme.onSurface)),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: SizedBox(
                    width: double.infinity,
                    child: SegmentedButton<String>(
                      showSelectedIcon: false,
                      style: const ButtonStyle(
                        visualDensity: VisualDensity.compact,
                        textStyle: WidgetStatePropertyAll(TextStyle(fontSize: 11)),
                        tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                      segments: [
                        ButtonSegment(value: 'off', label: Text(tr('backup_auto_off'), maxLines: 1, overflow: TextOverflow.ellipsis)),
                        ButtonSegment(value: 'daily', label: Text(tr('backup_auto_daily'), maxLines: 1, overflow: TextOverflow.ellipsis)),
                        ButtonSegment(value: 'weekly', label: Text(tr('backup_auto_weekly'), maxLines: 1, overflow: TextOverflow.ellipsis)),
                        ButtonSegment(value: 'monthly', label: Text(tr('backup_auto_monthly'), maxLines: 1, overflow: TextOverflow.ellipsis)),
                      ],
                      selected: {_autoBackupMode},
                      onSelectionChanged: (sel) async {
                        setState(() => _autoBackupMode = sel.first);
                        await DatabaseHelper().saveSetting('auto_backup_mode', sel.first);
                        if (mounted) {
                          final label = {
                            'off': tr('backup_auto_off'),
                            'daily': tr('backup_auto_daily'),
                            'weekly': tr('backup_auto_weekly'),
                            'monthly': tr('backup_auto_monthly'),
                          }[sel.first] ?? sel.first;
                          ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                            content: Text('${tr('backup_auto')}: $label'),
                            behavior: SnackBarBehavior.floating,
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                            duration: const Duration(seconds: 2),
                          ));
                        }
                      },
                    ),
                  ),
                ),

                // Last backup info
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
                  child: Row(
                    children: [
                      Icon(Icons.info_outline, size: 14, color: colorScheme.onSurfaceVariant),
                      const SizedBox(width: 6),
                      Text(
                        '${tr('last_backup')}: ${_lastBackupDate != null ? _formatBackupDate(_lastBackupDate!) : tr('never')}',
                        style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),

          // ── PIN e Blocco Biometrico ──
          Padding(
            padding: const EdgeInsets.only(left: 4, bottom: 6),
            child: Row(
              children: [
                Icon(Icons.fingerprint, color: colorScheme.primary, size: 20),
                const SizedBox(width: 8),
                Text(tr('pin_and_biometric_lock'), style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: colorScheme.primary)),
              ],
            ),
          ),
          Card(
            elevation: 0,
            color: colorScheme.surfaceContainerLowest,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // PIN status / set / change
                  if (_biometricPin != null && _biometricPin!.length == 4) ...[
                    ListTile(
                      contentPadding: EdgeInsets.zero,
                      leading: const Icon(Icons.pin),
                      title: Text('PIN: ****', style: const TextStyle(fontWeight: FontWeight.w600)),
                      trailing: OutlinedButton(
                        onPressed: () async {
                          final ok = await _authenticateBiometric();
                          if (!ok || !mounted) return;
                          _showSetPinDialog();
                        },
                        child: Text(tr('change_pin')),
                      ),
                    ),
                  ] else ...[
                    ListTile(
                      contentPadding: EdgeInsets.zero,
                      leading: const Icon(Icons.pin_outlined),
                      title: Text(tr('set_pin_to_enable'), style: TextStyle(color: colorScheme.onSurfaceVariant)),
                      trailing: FilledButton.tonal(
                        onPressed: () => _showSetPinDialog(),
                        child: Text(tr('set_pin')),
                      ),
                    ),
                  ],
                  const Divider(),
                  SwitchListTile(
                    contentPadding: EdgeInsets.zero,
                    secondary: const Icon(Icons.note),
                    title: Text(tr('lock_deep_note'), style: const TextStyle(fontWeight: FontWeight.w600)),
                    subtitle: Text(tr('lock_deep_note_desc')),
                    value: _profile.lockDeepNote,
                    onChanged: (value) {
                      _toggleLock(value, () => _profile.lockDeepNote, (v) => setState(() => _profile.lockDeepNote = v));
                    },
                  ),
                  const Divider(height: 1),
                  SwitchListTile(
                    contentPadding: EdgeInsets.zero,
                    secondary: const Icon(Icons.flash_on),
                    title: Text(tr('lock_flash_notes'), style: const TextStyle(fontWeight: FontWeight.w600)),
                    subtitle: Text(tr('lock_flash_notes_desc')),
                    value: _profile.lockFlashNotes,
                    onChanged: (value) {
                      _toggleLock(value, () => _profile.lockFlashNotes, (v) => setState(() => _profile.lockFlashNotes = v));
                    },
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// ─── Integrations Page ────────────────────────────────────────────

class IntegrationsPage extends StatefulWidget {
  const IntegrationsPage({super.key});

  @override
  State<IntegrationsPage> createState() => _IntegrationsPageState();
}

class _IntegrationsPageState extends State<IntegrationsPage> {
  FlashNotesSettings _flashSettings = const FlashNotesSettings();
  late TextEditingController _apiKeyController;
  bool _isLoadingGoogle = false;
  bool _isApiKeyRevealed = false;

  @override
  void initState() {
    super.initState();
    _apiKeyController = TextEditingController();
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    final settings = await FlashNotesSettings.load();
    if (mounted) {
      setState(() {
        _flashSettings = settings;
        _apiKeyController.text = settings.geminiApiKey;
      });
    }
  }

  @override
  void dispose() {
    _apiKeyController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(
        title: Text(tr('integrations')),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _buildGoogleSection(colorScheme),
          const SizedBox(height: 16),
          _buildGeminiSection(colorScheme),
        ],
      ),
    );
  }

  // ── Google (Calendar + Drive) ──
  Widget _buildGoogleSection(ColorScheme colorScheme) {
    final isConnected = GoogleCalendarService.isSignedIn;
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      color: colorScheme.surfaceContainerLowest,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.blue.shade700.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Icon(Icons.account_circle, color: Colors.blue.shade700, size: 28),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text('Google', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                      Text(
                        isConnected
                            ? (GoogleCalendarService.userEmail ?? tr('connected'))
                            : tr('not_connected'),
                        style: TextStyle(
                          fontSize: 13,
                          color: isConnected ? Colors.green : colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
                if (_isLoadingGoogle)
                  const SizedBox(width: 24, height: 24, child: CircularProgressIndicator(strokeWidth: 2)),
              ],
            ),
            const SizedBox(height: 16),
            _buildSubService('Google Calendar', Icons.calendar_month, Colors.blue.shade600, isConnected),
            const SizedBox(height: 8),
            _buildSubService('Google Drive', Icons.cloud, Colors.blue.shade700, isConnected),
            if (!isConnected) ...[
              const SizedBox(height: 12),
              Text(
                tr('google_cal_desc'),
                style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant),
              ),
            ],
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: isConnected
                  ? OutlinedButton.icon(
                      onPressed: () async {
                        await GoogleCalendarService.signOut();
                        if (mounted) setState(() {});
                      },
                      icon: const Icon(Icons.logout, size: 18),
                      label: Text(tr('disconnect')),
                      style: OutlinedButton.styleFrom(foregroundColor: colorScheme.error),
                    )
                  : FilledButton.icon(
                      onPressed: () async {
                        setState(() => _isLoadingGoogle = true);
                        final success = await GoogleCalendarService.signIn();
                        if (mounted) {
                          setState(() => _isLoadingGoogle = false);
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(success
                                  ? 'Google ${tr('connected')}'
                                  : tr('error')),
                              behavior: SnackBarBehavior.floating,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                            ),
                          );
                        }
                      },
                      icon: const Icon(Icons.login, size: 18),
                      label: Text('${tr('connect')} Google'),
                    ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSubService(String title, IconData icon, Color color, bool isActive) {
    return Row(
      children: [
        Icon(icon, size: 20, color: isActive ? color : Colors.grey),
        const SizedBox(width: 8),
        Expanded(child: Text(title, style: TextStyle(color: isActive ? null : Colors.grey))),
        Icon(
          isActive ? Icons.check_circle : Icons.radio_button_unchecked,
          size: 18,
          color: isActive ? Colors.green : Colors.grey,
        ),
      ],
    );
  }

  // ── Biometric auth for API key ──
  Future<bool> _authenticateBiometric() async {
    try {
      final localAuth = LocalAuthentication();
      final canAuth = await localAuth.canCheckBiometrics || await localAuth.isDeviceSupported();
      if (!canAuth) return true; // no biometric available, allow access
      return await localAuth.authenticate(
        localizedReason: tr('auth_for_api_key'),
        options: const AuthenticationOptions(biometricOnly: false),
      );
    } catch (_) {
      return false;
    }
  }

  void _showInsertApiKeyDialog() {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('enter_api_key')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              tr('paste_gemini_api_key'),
              style: TextStyle(fontSize: 13, color: Theme.of(ctx).colorScheme.onSurfaceVariant),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: controller,
              autofocus: true,
              decoration: InputDecoration(
                labelText: 'API Key',
                hintText: 'AIza...',
                prefixIcon: const Icon(Icons.key),
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () {
              final key = controller.text.trim();
              if (key.isNotEmpty) {
                setState(() {
                  _flashSettings = _flashSettings.copyWith(geminiApiKey: key);
                  _apiKeyController.text = key;
                });
                _flashSettings.save();
              }
              Navigator.pop(ctx);
            },
            child: Text(tr('save')),
          ),
        ],
      ),
    );
  }

  void _showEditApiKeyDialog() {
    final controller = TextEditingController(text: _flashSettings.geminiApiKey);
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('edit_api_key')),
        content: TextField(
          controller: controller,
          autofocus: true,
          decoration: InputDecoration(
            labelText: 'API Key',
            prefixIcon: const Icon(Icons.key),
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () {
              final key = controller.text.trim();
              setState(() {
                _flashSettings = _flashSettings.copyWith(geminiApiKey: key);
                _apiKeyController.text = key;
                _isApiKeyRevealed = false;
              });
              _flashSettings.save();
              Navigator.pop(ctx);
            },
            child: Text(tr('save')),
          ),
        ],
      ),
    );
  }

  // ── Gemini AI ──
  Widget _buildGeminiSection(ColorScheme colorScheme) {
    final hasKey = _flashSettings.geminiApiKey.isNotEmpty;
    final isConnected = _flashSettings.geminiEnabled && hasKey;
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      color: colorScheme.surfaceContainerLowest,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.purple.shade700.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Icon(Icons.auto_awesome, color: Colors.purple.shade700, size: 28),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text('Gemini AI', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                      Text(
                        isConnected ? tr('connected') : tr('not_connected'),
                        style: TextStyle(
                          fontSize: 13,
                          color: isConnected ? Colors.green : colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
                Switch(
                  value: _flashSettings.geminiEnabled,
                  onChanged: (val) {
                    setState(() {
                      _flashSettings = _flashSettings.copyWith(geminiEnabled: val);
                      _isApiKeyRevealed = false;
                    });
                    _flashSettings.save();
                  },
                ),
              ],
            ),
            if (_flashSettings.geminiEnabled) ...[
              const SizedBox(height: 16),
              // ── API Key area ──
              if (!hasKey) ...[
                // No key yet → show "Inserisci API Key" button
                SizedBox(
                  width: double.infinity,
                  child: FilledButton.icon(
                    onPressed: _showInsertApiKeyDialog,
                    icon: const Icon(Icons.key, size: 18),
                    label: Text(tr('enter_api_key')),
                    style: FilledButton.styleFrom(
                      backgroundColor: Colors.purple.shade700,
                      foregroundColor: Colors.white,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                      padding: const EdgeInsets.symmetric(vertical: 14),
                    ),
                  ),
                ),
              ] else ...[
                // Key exists → show masked key + action buttons
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: colorScheme.surfaceContainerHigh.withValues(alpha: 0.5),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Column(
                    children: [
                      Row(
                        children: [
                          Icon(Icons.key, size: 18, color: Colors.green.shade600),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              _isApiKeyRevealed
                                  ? _flashSettings.geminiApiKey
                                  : '${'•' * 8}${_flashSettings.geminiApiKey.substring(_flashSettings.geminiApiKey.length > 4 ? _flashSettings.geminiApiKey.length - 4 : 0)}',
                              style: TextStyle(
                                fontSize: 14,
                                fontFamily: 'monospace',
                                color: colorScheme.onSurface,
                              ),
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          Icon(Icons.check_circle, size: 18, color: Colors.green.shade600),
                        ],
                      ),
                      const SizedBox(height: 10),
                      Row(
                        children: [
                          Expanded(
                            child: _buildApiKeyAction(
                              icon: _isApiKeyRevealed ? Icons.visibility_off : Icons.visibility,
                              label: _isApiKeyRevealed ? tr('hide_label') : tr('show_label'),
                              onTap: () async {
                                if (_isApiKeyRevealed) {
                                  setState(() => _isApiKeyRevealed = false);
                                } else {
                                  final ok = await _authenticateBiometric();
                                  if (ok && mounted) setState(() => _isApiKeyRevealed = true);
                                }
                              },
                            ),
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: _buildApiKeyAction(
                              icon: Icons.copy,
                              label: tr('copy'),
                              onTap: () async {
                                final ok = await _authenticateBiometric();
                                if (ok && mounted) {
                                  Clipboard.setData(ClipboardData(text: _flashSettings.geminiApiKey));
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text(tr('api_key_copied')),
                                      behavior: SnackBarBehavior.floating,
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                                    ),
                                  );
                                }
                              },
                            ),
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: _buildApiKeyAction(
                              icon: Icons.edit,
                              label: tr('edit'),
                              onTap: () async {
                                final ok = await _authenticateBiometric();
                                if (ok && mounted) _showEditApiKeyDialog();
                              },
                            ),
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: _buildApiKeyAction(
                              icon: Icons.delete_outline,
                              label: tr('remove'),
                              color: Colors.red,
                              onTap: () async {
                                final ok = await _authenticateBiometric();
                                if (ok && mounted) {
                                  setState(() {
                                    _flashSettings = _flashSettings.copyWith(geminiApiKey: '');
                                    _apiKeyController.text = '';
                                    _isApiKeyRevealed = false;
                                  });
                                  _flashSettings.save();
                                }
                              },
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
              const SizedBox(height: 8),
              Text(
                tr('api_key_privacy'),
                style: TextStyle(
                  fontSize: 12,
                  fontStyle: FontStyle.italic,
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(height: 16),
              // Mini guida per ottenere API Key
              Container(
                padding: const EdgeInsets.all(14),
                decoration: BoxDecoration(
                  color: Colors.purple.shade700.withValues(alpha: 0.06),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.purple.shade700.withValues(alpha: 0.15)),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(Icons.help_outline, size: 18, color: Colors.purple.shade700),
                        const SizedBox(width: 8),
                        Text('Come ottenere la API Key', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 13, color: Colors.purple.shade700)),
                      ],
                    ),
                    const SizedBox(height: 10),
                    _buildGuideStep('1', 'Vai su aistudio.google.com'),
                    const SizedBox(height: 6),
                    _buildGuideStep('2', 'Accedi con il tuo account Google'),
                    const SizedBox(height: 6),
                    _buildGuideStep('3', 'Clicca su "Get API Key" nella barra laterale'),
                    const SizedBox(height: 6),
                    _buildGuideStep('4', 'Clicca "Create API Key" e seleziona un progetto'),
                    const SizedBox(height: 6),
                    _buildGuideStep('5', 'Copia la chiave e incollala qui sopra'),
                    const SizedBox(height: 10),
                    SizedBox(
                      width: double.infinity,
                      child: OutlinedButton.icon(
                        onPressed: () => launchUrl(Uri.parse('https://aistudio.google.com/apikey')),
                        icon: Icon(Icons.open_in_new, size: 16, color: Colors.purple.shade700),
                        label: Text('Apri Google AI Studio', style: TextStyle(fontSize: 13, color: Colors.purple.shade700)),
                        style: OutlinedButton.styleFrom(
                          side: BorderSide(color: Colors.purple.shade700.withValues(alpha: 0.4)),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                          padding: const EdgeInsets.symmetric(vertical: 10),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildApiKeyAction({
    required IconData icon,
    required String label,
    required VoidCallback onTap,
    Color? color,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(10),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 8),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(10),
        ),
        child: Column(
          children: [
            Icon(icon, size: 20, color: color ?? Theme.of(context).colorScheme.primary),
            const SizedBox(height: 4),
            Text(label, style: TextStyle(fontSize: 11, color: color ?? Theme.of(context).colorScheme.onSurfaceVariant)),
          ],
        ),
      ),
    );
  }

  Widget _buildGuideStep(String number, String text) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: 20, height: 20,
          decoration: BoxDecoration(
            color: Colors.purple.shade700.withValues(alpha: 0.12),
            shape: BoxShape.circle,
          ),
          child: Center(child: Text(number, style: TextStyle(fontSize: 11, fontWeight: FontWeight.bold, color: Colors.purple.shade700))),
        ),
        const SizedBox(width: 8),
        Expanded(child: Text(text, style: const TextStyle(fontSize: 13))),
      ],
    );
  }

}

// FLASH NOTES
// ─── NLP Event Extraction ─────────────────────────────────────────

class ParsedEvent {
  final String title;
  final DateTime startDate;
  final DateTime endDate;
  final bool isAllDay;

  ParsedEvent({
    required this.title,
    required this.startDate,
    required this.endDate,
    this.isAllDay = false,
  });

  CalendarEventFull toCalendarEvent() => CalendarEventFull(
    title: title,
    startTime: startDate,
    endTime: endDate,
    calendar: 'Personale',
  );
}

ParsedEvent parseFlashNote(String text) {
  final now = DateTime.now();
  final today = DateTime(now.year, now.month, now.day);
  String remaining = text;
  DateTime? parsedDate;
  int? startHour;
  int? startMinute;
  int? endHour;
  int? endMinute;

  // a) Explicit @date syntax
  final dateFullRe = RegExp(r'@(\d{1,2})/(\d{1,2})/(\d{4})');
  final dateShortRe = RegExp(r'@(\d{1,2})/(\d{1,2})(?!/\d)');
  final atTimeRe = RegExp(r'@(\d{1,2}):(\d{2})');

  final fullMatch = dateFullRe.firstMatch(remaining);
  if (fullMatch != null) {
    parsedDate = DateTime(
      int.parse(fullMatch.group(3)!),
      int.parse(fullMatch.group(2)!),
      int.parse(fullMatch.group(1)!),
    );
    remaining = remaining.replaceFirst(fullMatch.group(0)!, '');
  } else {
    final shortMatch = dateShortRe.firstMatch(remaining);
    if (shortMatch != null) {
      parsedDate = DateTime(
        now.year,
        int.parse(shortMatch.group(2)!),
        int.parse(shortMatch.group(1)!),
      );
      remaining = remaining.replaceFirst(shortMatch.group(0)!, '');
    }
  }

  final atTimeMatch = atTimeRe.firstMatch(remaining);
  if (atTimeMatch != null) {
    startHour = int.parse(atTimeMatch.group(1)!);
    startMinute = int.parse(atTimeMatch.group(2)!);
    remaining = remaining.replaceFirst(atTimeMatch.group(0)!, '');
  }

  // b) Natural language relative dates (IT)
  if (parsedDate == null) {
    final relativeDays = {
      'dopodomani': 2,
      'domani': 1,
      'oggi': 0,
    };
    for (final entry in relativeDays.entries) {
      final re = RegExp('\\b${entry.key}\\b', caseSensitive: false);
      if (re.hasMatch(remaining)) {
        parsedDate = today.add(Duration(days: entry.value));
        remaining = remaining.replaceFirst(re, '');
        break;
      }
    }
  }

  if (parsedDate == null) {
    final weekdays = {
      'lunedì': DateTime.monday,
      'lunedi': DateTime.monday,
      'martedì': DateTime.tuesday,
      'martedi': DateTime.tuesday,
      'mercoledì': DateTime.wednesday,
      'mercoledi': DateTime.wednesday,
      'giovedì': DateTime.thursday,
      'giovedi': DateTime.thursday,
      'venerdì': DateTime.friday,
      'venerdi': DateTime.friday,
      'sabato': DateTime.saturday,
      'domenica': DateTime.sunday,
    };
    for (final entry in weekdays.entries) {
      final re = RegExp('\\bprossimo\\s+${entry.key}\\b|\\b${entry.key}\\b', caseSensitive: false);
      final m = re.firstMatch(remaining);
      if (m != null) {
        var daysAhead = entry.value - now.weekday;
        if (daysAhead <= 0) daysAhead += 7;
        parsedDate = today.add(Duration(days: daysAhead));
        remaining = remaining.replaceFirst(m.group(0)!, '');
        break;
      }
    }
  }

  // c) Time ranges and single times
  final rangeRe = RegExp(r'dalle\s+(\d{1,2})([:.]\d{2})?\s+alle\s+(\d{1,2})([:.]\d{2})?', caseSensitive: false);
  final rangeMatch = rangeRe.firstMatch(remaining);
  if (rangeMatch != null) {
    startHour ??= int.parse(rangeMatch.group(1)!);
    startMinute ??= rangeMatch.group(2) != null ? int.parse(rangeMatch.group(2)!.substring(1)) : 0;
    endHour = int.parse(rangeMatch.group(3)!);
    endMinute = rangeMatch.group(4) != null ? int.parse(rangeMatch.group(4)!.substring(1)) : 0;
    remaining = remaining.replaceFirst(rangeMatch.group(0)!, '');
  }

  if (startHour == null) {
    final singleTimeRe = RegExp(r'(?:ore|alle)\s+(\d{1,2})([:.]\d{2})?', caseSensitive: false);
    final singleMatch = singleTimeRe.firstMatch(remaining);
    if (singleMatch != null) {
      startHour = int.parse(singleMatch.group(1)!);
      startMinute = singleMatch.group(2) != null ? int.parse(singleMatch.group(2)!.substring(1)) : 0;
      remaining = remaining.replaceFirst(singleMatch.group(0)!, '');
    }
  }

  // d) Clean title
  String title = remaining.replaceAll(RegExp(r'\s+'), ' ').trim();
  if (title.isEmpty) title = text.trim();

  // e) Defaults
  final date = parsedDate ?? today;
  final bool isAllDay = (startHour == null);

  DateTime startDate;
  DateTime endDate;

  if (isAllDay) {
    startDate = DateTime(date.year, date.month, date.day, 0, 0);
    endDate = DateTime(date.year, date.month, date.day, 23, 59);
  } else {
    startDate = DateTime(date.year, date.month, date.day, startHour, startMinute ?? 0);
    if (endHour != null) {
      endDate = DateTime(date.year, date.month, date.day, endHour, endMinute ?? 0);
    } else {
      endDate = startDate.add(const Duration(hours: 1));
    }
  }

  return ParsedEvent(
    title: title,
    startDate: startDate,
    endDate: endDate,
    isAllDay: isAllDay,
  );
}

// ──────────────────────────────────────────────────────────────────

class _HighlightPattern {
  final RegExp regex;
  final Color color;
  _HighlightPattern(this.regex, this.color);
}

class _TextMatch implements Comparable<_TextMatch> {
  final int start;
  final int end;
  final Color color;
  _TextMatch(this.start, this.end, this.color);

  @override
  int compareTo(_TextMatch other) => start.compareTo(other.start);
}

class _HighlightingTextEditingController extends TextEditingController {
  static final List<_HighlightPattern> _patterns = [
    // @HH:MM — time syntax (blue)
    _HighlightPattern(RegExp(r'@\d{1,2}:\d{2}'), const Color(0xFF2196F3)),
    // @DD/MM or @DD/MM/YYYY — date syntax (purple)
    _HighlightPattern(RegExp(r'@\d{1,2}/\d{1,2}(?:/\d{4})?'), const Color(0xFF9C27B0)),
    // Relative days (green)
    _HighlightPattern(RegExp(r'\b(?:oggi|domani|dopodomani)\b', caseSensitive: false), const Color(0xFF4CAF50)),
    // Weekdays (green)
    _HighlightPattern(RegExp(r'\b(?:(?:prossimo\s+)?(?:lunedì|lunedi|martedì|martedi|mercoledì|mercoledi|giovedì|giovedi|venerdì|venerdi|sabato|domenica))\b', caseSensitive: false), const Color(0xFF4CAF50)),
    // Time ranges: "dalle X alle Y" (blue)
    _HighlightPattern(RegExp(r'dalle\s+\d{1,2}(?:[:.]\d{2})?\s+alle\s+\d{1,2}(?:[:.]\d{2})?', caseSensitive: false), const Color(0xFF2196F3)),
    // Single time: "ore X" / "alle X" (blue)
    _HighlightPattern(RegExp(r'(?:ore|alle)\s+\d{1,2}(?:[:.]\d{2})?', caseSensitive: false), const Color(0xFF2196F3)),
  ];

  @override
  TextSpan buildTextSpan({required BuildContext context, TextStyle? style, required bool withComposing}) {
    final text = this.text;
    if (text.isEmpty) {
      return TextSpan(text: text, style: style);
    }

    // Collect all matches
    final matches = <_TextMatch>[];
    for (final pattern in _patterns) {
      for (final m in pattern.regex.allMatches(text)) {
        matches.add(_TextMatch(m.start, m.end, pattern.color));
      }
    }

    if (matches.isEmpty) {
      return TextSpan(text: text, style: style);
    }

    // Sort by position, first match wins for overlaps
    matches.sort();
    final filtered = <_TextMatch>[];
    int lastEnd = 0;
    for (final m in matches) {
      if (m.start >= lastEnd) {
        filtered.add(m);
        lastEnd = m.end;
      }
    }

    // Build spans
    final spans = <TextSpan>[];
    int pos = 0;
    for (final m in filtered) {
      if (pos < m.start) {
        spans.add(TextSpan(text: text.substring(pos, m.start)));
      }
      spans.add(TextSpan(
        text: text.substring(m.start, m.end),
        style: TextStyle(
          color: m.color,
          fontWeight: FontWeight.w600,
          backgroundColor: m.color.withValues(alpha: 0.1),
        ),
      ));
      pos = m.end;
    }
    if (pos < text.length) {
      spans.add(TextSpan(text: text.substring(pos)));
    }

    return TextSpan(style: style, children: spans);
  }
}

class FlashNote {
  final int? id;
  final String content;
  final DateTime createdAt;
  final String? audioPath;
  final int? audioDurationMs;
  final String? imageBase64;
  final String? imagePath;
  final bool isPinned;

  FlashNote({this.id, required this.content, DateTime? createdAt, this.audioPath, this.audioDurationMs, this.imageBase64, this.imagePath, this.isPinned = false})
    : createdAt = createdAt ?? DateTime.now();

  bool get isAudioNote => audioPath != null && audioPath!.isNotEmpty;
  bool get isPhotoNote => (imagePath != null && imagePath!.isNotEmpty) || (imageBase64 != null && imageBase64!.isNotEmpty);

  FlashNote copyWith({
    int? id,
    String? content,
    DateTime? createdAt,
    String? audioPath,
    int? audioDurationMs,
    String? imageBase64,
    String? imagePath,
    bool? isPinned,
  }) => FlashNote(
    id: id ?? this.id,
    content: content ?? this.content,
    createdAt: createdAt ?? this.createdAt,
    audioPath: audioPath ?? this.audioPath,
    audioDurationMs: audioDurationMs ?? this.audioDurationMs,
    imageBase64: imageBase64 ?? this.imageBase64,
    imagePath: imagePath ?? this.imagePath,
    isPinned: isPinned ?? this.isPinned,
  );

  Map<String, dynamic> toJson() => {
    'content': content,
    'createdAt': createdAt.toIso8601String(),
    if (audioPath != null) 'audioPath': audioPath,
    if (audioDurationMs != null) 'audioDurationMs': audioDurationMs,
    if (imageBase64 != null) 'imageBase64': imageBase64,
    if (imagePath != null) 'imagePath': imagePath,
    'isPinned': isPinned,
  };

  factory FlashNote.fromJson(Map<String, dynamic> json) => FlashNote(
    content: json['content'] ?? '',
    createdAt: DateTime.tryParse(json['createdAt'] ?? '') ?? DateTime.now(),
    audioPath: json['audioPath'],
    audioDurationMs: json['audioDurationMs'],
    imageBase64: json['imageBase64'],
    imagePath: json['imagePath'],
    isPinned: json['isPinned'] == true,
  );

  Map<String, dynamic> toDbMap() => {
    'content': content,
    'created_at': createdAt.millisecondsSinceEpoch,
    'audio_path': audioPath,
    'audio_duration_ms': audioDurationMs,
    'image_base64': imageBase64,
    'image_path': imagePath,
    'is_pinned': isPinned ? 1 : 0,
  };

  factory FlashNote.fromDbMap(Map<String, dynamic> m) => FlashNote(
    id: m['id'] as int?,
    content: (m['content'] as String?) ?? '',
    createdAt: DateTime.fromMillisecondsSinceEpoch((m['created_at'] as int?) ?? 0),
    audioPath: m['audio_path'] as String?,
    audioDurationMs: m['audio_duration_ms'] as int?,
    imageBase64: m['image_base64'] as String?,
    imagePath: m['image_path'] as String?,
    isPinned: (m['is_pinned'] as int?) == 1,
  );
}

class PhotoRecognitionResult {
  final String category; // 'business_card', 'receipt', 'document', 'handwritten', 'normal'
  final String title;
  final String extractedText;
  final Map<String, String> fields;

  const PhotoRecognitionResult({
    required this.category,
    required this.title,
    this.extractedText = '',
    this.fields = const {},
  });

  bool get isActionable => category != 'normal';

  String get folderName {
    switch (category) {
      case 'business_card': return 'Biglietti da Visita';
      case 'receipt': return 'Ricevute';
      case 'document': return 'Documenti';
      case 'handwritten': return 'Appunti';
      default: return 'Generale';
    }
  }

  IconData get folderIcon {
    switch (category) {
      case 'business_card': return Icons.contact_page;
      case 'receipt': return Icons.receipt_long;
      case 'document': return Icons.description;
      case 'handwritten': return Icons.edit_note;
      default: return Icons.folder;
    }
  }

  Color get folderColor {
    switch (category) {
      case 'business_card': return const Color(0xFF1565C0);
      case 'receipt': return const Color(0xFF2E7D32);
      case 'document': return const Color(0xFF7B1FA2);
      case 'handwritten': return const Color(0xFFF57C00);
      default: return const Color(0xFF757575);
    }
  }

  String get categoryLabel {
    switch (category) {
      case 'business_card': return tr('business_card');
      case 'receipt': return tr('receipt');
      case 'document': return tr('document');
      case 'handwritten': return tr('handwritten_note');
      default: return tr('normal_photo');
    }
  }
}

class FlashNotesSettings {
  final bool geminiEnabled;
  final String geminiApiKey;
  final String autoSaveMode; // 'never', 'daily', 'weekly', 'monthly', 'custom'
  final int customAutoSaveDays;
  final String formattingPreset; // 'simple', 'ai', 'custom'
  final String customFormatInstructions;
  final double aiCorrectionLevel; // 0.0 (solo ortografia) - 1.0 (riscrittura completa)
  final String groupingMode; // 'daily', 'weekly', 'monthly', 'yearly'
  final int maxAudioDurationSeconds;
  final bool photoRecognitionEnabled;
  final String noteStyle; // 'modern', 'paper'

  const FlashNotesSettings({
    this.geminiEnabled = false,
    this.geminiApiKey = '',
    this.autoSaveMode = 'monthly',
    this.customAutoSaveDays = 7,
    this.formattingPreset = 'simple',
    this.customFormatInstructions = '',
    this.aiCorrectionLevel = 0.0,
    this.groupingMode = 'weekly',
    this.maxAudioDurationSeconds = 120,
    this.photoRecognitionEnabled = false,
    this.noteStyle = 'modern',
  });

  FlashNotesSettings copyWith({
    bool? geminiEnabled,
    String? geminiApiKey,
    String? autoSaveMode,
    int? customAutoSaveDays,
    String? formattingPreset,
    String? customFormatInstructions,
    double? aiCorrectionLevel,
    String? groupingMode,
    int? maxAudioDurationSeconds,
    bool? photoRecognitionEnabled,
    String? noteStyle,
  }) {
    return FlashNotesSettings(
      geminiEnabled: geminiEnabled ?? this.geminiEnabled,
      geminiApiKey: geminiApiKey ?? this.geminiApiKey,
      autoSaveMode: autoSaveMode ?? this.autoSaveMode,
      customAutoSaveDays: customAutoSaveDays ?? this.customAutoSaveDays,
      formattingPreset: formattingPreset ?? this.formattingPreset,
      customFormatInstructions: customFormatInstructions ?? this.customFormatInstructions,
      aiCorrectionLevel: aiCorrectionLevel ?? this.aiCorrectionLevel,
      groupingMode: groupingMode ?? this.groupingMode,
      maxAudioDurationSeconds: maxAudioDurationSeconds ?? this.maxAudioDurationSeconds,
      photoRecognitionEnabled: photoRecognitionEnabled ?? this.photoRecognitionEnabled,
      noteStyle: noteStyle ?? this.noteStyle,
    );
  }

  Map<String, dynamic> toJson() => {
    'geminiEnabled': geminiEnabled,
    'geminiApiKey': geminiApiKey,
    'autoSaveMode': autoSaveMode,
    'customAutoSaveDays': customAutoSaveDays,
    'formattingPreset': formattingPreset,
    'customFormatInstructions': customFormatInstructions,
    'aiCorrectionLevel': aiCorrectionLevel,
    'groupingMode': groupingMode,
    'maxAudioDurationSeconds': maxAudioDurationSeconds,
    'photoRecognitionEnabled': photoRecognitionEnabled,
    'noteStyle': noteStyle,
  };

  factory FlashNotesSettings.fromJson(Map<String, dynamic> json) =>
      FlashNotesSettings(
        geminiEnabled: json['geminiEnabled'] ?? false,
        geminiApiKey: json['geminiApiKey'] ?? '',
        autoSaveMode: json['autoSaveMode'] ?? 'monthly',
        customAutoSaveDays: json['customAutoSaveDays'] ?? 7,
        formattingPreset: json['formattingPreset'] ?? 'simple',
        customFormatInstructions: json['customFormatInstructions'] ?? '',
        aiCorrectionLevel: (json['aiCorrectionLevel'] ?? 0.0).toDouble(),
        groupingMode: json['groupingMode'] ?? 'weekly',
        maxAudioDurationSeconds: json['maxAudioDurationSeconds'] ?? 120,
        photoRecognitionEnabled: json['photoRecognitionEnabled'] ?? false,
        noteStyle: json['noteStyle'] ?? 'modern',
      );

  static Future<FlashNotesSettings> load() async {
    final jsonStr = await DatabaseHelper().getSetting('flash_notes_settings');
    if (jsonStr != null) {
      return FlashNotesSettings.fromJson(json.decode(jsonStr));
    }
    return const FlashNotesSettings();
  }

  Future<void> save() async {
    await DatabaseHelper().saveSetting('flash_notes_settings', json.encode(toJson()));
  }
}

// ── Photo Recognition with Gemini Vision ──

/// Converts raw Gemini error messages into user-friendly localized strings.
String _friendlyGeminiError(String? error, String fallback) {
  if (error == null) return fallback;
  if (error.contains('503')) return tr('server_busy');
  if (error.contains('quota') || error.contains('429')) return tr('quota_exceeded');
  if (error.contains('API key') || error.contains('401') || error.contains('403')) return tr('photo_recognition_failed');
  return '$fallback\n$error';
}

/// Returns (result, errorMessage). If result is null, errorMessage explains why.
/// Retries up to 2 times on 503 (high demand) errors.
Future<(PhotoRecognitionResult?, String?)> classifyPhotoWithGemini(String base64Image, String apiKey) async {
  final imageBytes = base64Decode(base64Image);

  final prompt = '''Analizza questa immagine e classificala in una delle seguenti categorie:
- "business_card": biglietto da visita (contiene nome, telefono, email, azienda)
- "receipt": ricevuta o scontrino (contiene negozio, importo, data)
- "document": documento formale (contratto, lettera, certificato)
- "handwritten": appunto scritto a mano
- "normal": foto normale (paesaggio, selfie, cibo, ecc.)

Rispondi SOLO con un JSON valido (senza markdown code fences) in questo formato:
{
  "category": "business_card|receipt|document|handwritten|normal",
  "title": "titolo breve descrittivo",
  "extractedText": "testo principale estratto dall'immagine",
  "fields": {
    "campo1": "valore1",
    "campo2": "valore2"
  }
}

Per business_card i fields devono essere (se presenti):
- nome (nome completo della persona)
- telefoni (array JSON di numeri, es. ["+39 02 1234567", "+39 333 1234567"])
- email (array JSON di indirizzi email, es. ["info@azienda.it", "nome@azienda.it"])
- azienda
- ruolo
- via (nome della via con numero civico)
- citta
- cap (codice postale)
- provincia (sigla o nome)
- sito_web
Importante: telefoni e email DEVONO essere array JSON anche se c'è un solo valore.
Per receipt: negozio, importo, data.
Per document: tipo_documento, testo_chiave.
Per handwritten: testo_trascritto.
Per normal: fields vuoto {}.''';

  String? lastError;
  for (int attempt = 0; attempt < 3; attempt++) {
    try {
      final model = gemini.GenerativeModel(model: 'gemini-2.5-flash-lite', apiKey: apiKey);
      final response = await model.generateContent([
        gemini.Content.multi([
          gemini.DataPart('image/jpeg', imageBytes),
          gemini.TextPart(prompt),
        ]),
      ]).timeout(const Duration(seconds: 60));

      final text = response.text ?? '';
      String jsonStr = text.trim();
      if (jsonStr.startsWith('```')) {
        jsonStr = jsonStr.replaceFirst(RegExp(r'^```(?:json)?\s*'), '');
        jsonStr = jsonStr.replaceFirst(RegExp(r'\s*```\s*$'), '');
      }

      final parsed = json.decode(jsonStr) as Map<String, dynamic>;
      final fieldsRaw = parsed['fields'] as Map<String, dynamic>? ?? {};
      final fields = fieldsRaw.map((k, v) => MapEntry(k, v is List ? json.encode(v) : v.toString()));

      return (PhotoRecognitionResult(
        category: parsed['category'] ?? 'normal',
        title: parsed['title'] ?? '',
        extractedText: parsed['extractedText'] ?? '',
        fields: fields,
      ), null);
    } catch (e) {
      lastError = e.toString();
      // Retry on 503 (high demand) — wait before retrying
      if (lastError.contains('503') && attempt < 2) {
        await Future.delayed(Duration(seconds: 3 * (attempt + 1)));
        continue;
      }
      break;
    }
  }
  return (null, lastError);
}

Future<void> ensurePhotoFolder(String folderName, IconData icon, Color color) async {
  final folders = await DatabaseHelper().getAllFolders();
  if (!folders.containsKey(folderName)) {
    await DatabaseHelper().saveFolder(
      folderName,
      FolderStyle(icon, color, isCustom: true),
    );
  }
}

String formatRecognitionAsDeepNote(PhotoRecognitionResult result) {
  final buf = StringBuffer();
  if (result.extractedText.isNotEmpty) {
    buf.writeln(result.extractedText);
    buf.writeln();
  }
  if (result.fields.isNotEmpty) {
    for (final entry in result.fields.entries) {
      final label = entry.key.replaceAll('_', ' ');
      final capitalLabel = label[0].toUpperCase() + label.substring(1);
      buf.writeln('$capitalLabel: ${entry.value}');
    }
  }
  return buf.toString().trim();
}

/// Splits a full name into (firstName, lastName).
(String, String) _splitContactName(String fullName) {
  final parts = fullName.trim().split(RegExp(r'\s+'));
  if (parts.length <= 1) return (fullName.trim(), '');
  return (parts.first, parts.sublist(1).join(' '));
}

/// Saves a contact to the device address book.
Future<void> _saveContactToDevice(
  BuildContext context, {
  required String firstName,
  required String lastName,
  required List<String> phones,
  required List<String> emails,
  required String company,
  required String role,
  required String street,
  required String city,
  required String postalCode,
  required String province,
  required String website,
}) async {
  final granted = await contacts_pkg.FlutterContacts.requestPermission();
  if (!granted) {
    if (!context.mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(tr('contacts_permission_denied')),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );
    return;
  }

  // Use native MethodChannel to open contact editor with full support
  // for multiple emails/phones and structured address fields.
  const channel = MethodChannel('com.ethosnote.app/contacts');
  final fullName = '$firstName $lastName'.trim();
  await channel.invokeMethod('openContactInsert', {
    'name': fullName,
    'phones': phones,
    'emails': emails,
    'company': company,
    'jobTitle': role,
    'street': street,
    'city': city,
    'postalCode': postalCode,
    'province': province,
    'website': website,
  });

  if (!context.mounted) return;
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Row(
        children: [
          const Icon(Icons.check_circle, color: Colors.white, size: 18),
          const SizedBox(width: 8),
          Text(tr('saved_to_contacts')),
        ],
      ),
      behavior: SnackBarBehavior.floating,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    ),
  );
}

/// Parses a JSON array string into a List<String>, falling back to treating
/// the value as a single item.
List<String> _parseJsonArray(String? value) {
  if (value == null || value.isEmpty) return [];
  try {
    final parsed = json.decode(value);
    if (parsed is List) return parsed.map((e) => e.toString()).where((s) => s.isNotEmpty).toList();
  } catch (_) {}
  // Fallback: split by comma/semicolon or treat as single value
  return value.contains(RegExp(r'[,;]'))
      ? value.split(RegExp(r'\s*[,;]\s*')).where((s) => s.isNotEmpty).toList()
      : [value];
}

/// Returns empty string if value is null-like ("null", "N/A", etc.)
String _cleanField(String? value) {
  if (value == null) return '';
  final v = value.trim();
  if (v.isEmpty || v.toLowerCase() == 'null' || v.toLowerCase() == 'n/a') return '';
  return v;
}

/// Shows a contact form bottom sheet pre-filled from photo recognition.
void showContactFormSheet(BuildContext context, PhotoRecognitionResult result) {
  final fields = result.fields;
  final fullName = _cleanField(fields['nome']);
  final (first, last) = _splitContactName(fullName);

  // Parse phone/email arrays (new format) with fallback to old single-value format
  final phones = _parseJsonArray(fields['telefoni'] ?? fields['telefono']);
  final emails = _parseJsonArray(fields['email']);

  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    shape: const RoundedRectangleBorder(
      borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
    ),
    builder: (ctx) => _ContactFormSheetContent(
      firstName: first,
      lastName: last,
      phones: phones,
      emails: emails,
      company: _cleanField(fields['azienda']),
      role: _cleanField(fields['ruolo']),
      street: _cleanField(fields['via'] ?? fields['indirizzo']),
      city: _cleanField(fields['citta']),
      postalCode: _cleanField(fields['cap']),
      province: _cleanField(fields['provincia']),
      website: _cleanField(fields['sito_web']),
    ),
  );
}

class _ContactFormSheetContent extends StatefulWidget {
  final String firstName;
  final String lastName;
  final List<String> phones;
  final List<String> emails;
  final String company;
  final String role;
  final String street;
  final String city;
  final String postalCode;
  final String province;
  final String website;

  const _ContactFormSheetContent({
    required this.firstName,
    required this.lastName,
    required this.phones,
    required this.emails,
    required this.company,
    required this.role,
    required this.street,
    required this.city,
    required this.postalCode,
    required this.province,
    required this.website,
  });

  @override
  State<_ContactFormSheetContent> createState() => _ContactFormSheetContentState();
}

class _ContactFormSheetContentState extends State<_ContactFormSheetContent> {
  late final TextEditingController _firstNameCtrl;
  late final TextEditingController _lastNameCtrl;
  late final List<TextEditingController> _phoneCtrls;
  late final List<TextEditingController> _emailCtrls;
  late final TextEditingController _companyCtrl;
  late final TextEditingController _roleCtrl;
  late final TextEditingController _streetCtrl;
  late final TextEditingController _cityCtrl;
  late final TextEditingController _postalCodeCtrl;
  late final TextEditingController _provinceCtrl;
  late final TextEditingController _websiteCtrl;
  bool _saving = false;

  @override
  void initState() {
    super.initState();
    _firstNameCtrl = TextEditingController(text: widget.firstName);
    _lastNameCtrl = TextEditingController(text: widget.lastName);
    _phoneCtrls = widget.phones.isNotEmpty
        ? widget.phones.map((p) => TextEditingController(text: p)).toList()
        : [TextEditingController()];
    _emailCtrls = widget.emails.isNotEmpty
        ? widget.emails.map((e) => TextEditingController(text: e)).toList()
        : [TextEditingController()];
    _companyCtrl = TextEditingController(text: widget.company);
    _roleCtrl = TextEditingController(text: widget.role);
    _streetCtrl = TextEditingController(text: widget.street);
    _cityCtrl = TextEditingController(text: widget.city);
    _postalCodeCtrl = TextEditingController(text: widget.postalCode);
    _provinceCtrl = TextEditingController(text: widget.province);
    _websiteCtrl = TextEditingController(text: widget.website);
  }

  @override
  void dispose() {
    _firstNameCtrl.dispose();
    _lastNameCtrl.dispose();
    for (final c in _phoneCtrls) c.dispose();
    for (final c in _emailCtrls) c.dispose();
    _companyCtrl.dispose();
    _roleCtrl.dispose();
    _streetCtrl.dispose();
    _cityCtrl.dispose();
    _postalCodeCtrl.dispose();
    _provinceCtrl.dispose();
    _websiteCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final bottomInset = MediaQuery.of(context).viewInsets.bottom;

    return DraggableScrollableSheet(
      initialChildSize: 0.85,
      minChildSize: 0.5,
      maxChildSize: 0.95,
      expand: false,
      builder: (ctx, scrollController) => Padding(
        padding: EdgeInsets.fromLTRB(20, 12, 20, 20 + bottomInset),
        child: ListView(
          controller: scrollController,
          children: [
            // Handle
            Center(
              child: Container(
                width: 40, height: 4,
                decoration: BoxDecoration(
                  color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
            ),
            const SizedBox(height: 16),
            // Title
            Row(
              children: [
                Icon(Icons.person_add, color: const Color(0xFF1565C0)),
                const SizedBox(width: 8),
                Text(tr('contact_form_title'), style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
              ],
            ),
            const SizedBox(height: 20),
            // Name
            _buildField(_firstNameCtrl, tr('name'), Icons.person_outline),
            const SizedBox(height: 12),
            _buildField(_lastNameCtrl, tr('surname'), Icons.person_outline),
            const SizedBox(height: 16),
            // Phones (dynamic list)
            ..._buildMultiFields(
              controllers: _phoneCtrls,
              label: tr('phone'),
              icon: Icons.phone_outlined,
              keyboardType: TextInputType.phone,
              addLabel: tr('add_phone'),
              onAdd: () => setState(() => _phoneCtrls.add(TextEditingController())),
              onRemove: (i) => setState(() { _phoneCtrls[i].dispose(); _phoneCtrls.removeAt(i); }),
            ),
            const SizedBox(height: 16),
            // Emails (dynamic list)
            ..._buildMultiFields(
              controllers: _emailCtrls,
              label: tr('email'),
              icon: Icons.email_outlined,
              keyboardType: TextInputType.emailAddress,
              addLabel: tr('add_email'),
              onAdd: () => setState(() => _emailCtrls.add(TextEditingController())),
              onRemove: (i) => setState(() { _emailCtrls[i].dispose(); _emailCtrls.removeAt(i); }),
            ),
            const SizedBox(height: 16),
            // Company & Role
            _buildField(_companyCtrl, tr('company'), Icons.business_outlined),
            const SizedBox(height: 12),
            _buildField(_roleCtrl, tr('role_title'), Icons.badge_outlined),
            const SizedBox(height: 16),
            // Address (structured)
            _buildField(_streetCtrl, tr('street'), Icons.location_on_outlined),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(flex: 2, child: _buildField(_cityCtrl, tr('city'), Icons.location_city)),
                const SizedBox(width: 8),
                Expanded(flex: 1, child: _buildField(_postalCodeCtrl, tr('postal_code'), Icons.markunread_mailbox_outlined, keyboardType: TextInputType.number)),
              ],
            ),
            const SizedBox(height: 12),
            _buildField(_provinceCtrl, tr('province'), Icons.map_outlined),
            const SizedBox(height: 12),
            _buildField(_websiteCtrl, tr('website'), Icons.language, keyboardType: TextInputType.url),
            const SizedBox(height: 24),
            // Buttons
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.pop(context),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 14),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                    child: Text(tr('cancel')),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton.icon(
                    onPressed: _saving ? null : _onSave,
                    icon: _saving
                        ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                        : const Icon(Icons.save, size: 18),
                    label: Text(tr('save')),
                    style: FilledButton.styleFrom(
                      backgroundColor: const Color(0xFF1565C0),
                      padding: const EdgeInsets.symmetric(vertical: 14),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildMultiFields({
    required List<TextEditingController> controllers,
    required String label,
    required IconData icon,
    required String addLabel,
    required VoidCallback onAdd,
    required void Function(int) onRemove,
    TextInputType? keyboardType,
  }) {
    final widgets = <Widget>[];
    for (var i = 0; i < controllers.length; i++) {
      widgets.add(
        Row(
          children: [
            Expanded(child: _buildField(controllers[i], controllers.length > 1 ? '$label ${i + 1}' : label, icon, keyboardType: keyboardType)),
            if (controllers.length > 1)
              IconButton(
                icon: Icon(Icons.remove_circle_outline, color: Theme.of(context).colorScheme.error, size: 20),
                onPressed: () => onRemove(i),
              ),
          ],
        ),
      );
      if (i < controllers.length - 1) widgets.add(const SizedBox(height: 8));
    }
    widgets.add(const SizedBox(height: 4));
    widgets.add(
      Align(
        alignment: Alignment.centerLeft,
        child: TextButton.icon(
          onPressed: onAdd,
          icon: const Icon(Icons.add, size: 18),
          label: Text(addLabel, style: const TextStyle(fontSize: 13)),
        ),
      ),
    );
    return widgets;
  }

  Widget _buildField(TextEditingController controller, String label, IconData icon, {TextInputType? keyboardType}) {
    return TextField(
      controller: controller,
      keyboardType: keyboardType,
      decoration: InputDecoration(
        labelText: label,
        prefixIcon: Icon(icon),
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.5)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF1565C0), width: 2),
        ),
      ),
    );
  }

  Future<void> _onSave() async {
    setState(() => _saving = true);
    try {
      await _saveContactToDevice(
        context,
        firstName: _firstNameCtrl.text.trim(),
        lastName: _lastNameCtrl.text.trim(),
        phones: _phoneCtrls.map((c) => c.text.trim()).where((s) => s.isNotEmpty).toList(),
        emails: _emailCtrls.map((c) => c.text.trim()).where((s) => s.isNotEmpty).toList(),
        company: _companyCtrl.text.trim(),
        role: _roleCtrl.text.trim(),
        street: _streetCtrl.text.trim(),
        city: _cityCtrl.text.trim(),
        postalCode: _postalCodeCtrl.text.trim(),
        province: _provinceCtrl.text.trim(),
        website: _websiteCtrl.text.trim(),
      );
      if (!mounted) return;
      Navigator.pop(context);
    } catch (e) {
      if (!mounted) return;
      setState(() => _saving = false);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('error')}: $e'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }
}

class FlashNotesSettingsPage extends StatefulWidget {
  final FlashNotesSettings settings;
  final Function(FlashNotesSettings) onSave;

  const FlashNotesSettingsPage({
    super.key,
    required this.settings,
    required this.onSave,
  });

  @override
  State<FlashNotesSettingsPage> createState() => _FlashNotesSettingsPageState();
}

class _FlashNotesSettingsPageState extends State<FlashNotesSettingsPage> {
  late FlashNotesSettings _settings;
  late TextEditingController _apiKeyController;
  EthosAuraSettings _auraSettings = const EthosAuraSettings();

  @override
  void initState() {
    super.initState();
    _settings = widget.settings;
    _apiKeyController = TextEditingController(text: _settings.geminiApiKey);
    _loadAuraSettings();
  }

  Future<void> _loadAuraSettings() async {
    final s = await EthosAuraSettings.load();
    if (!mounted) return;
    setState(() => _auraSettings = s);
  }

  @override
  void dispose() {
    _apiKeyController.dispose();
    super.dispose();
  }

  void _updateSettings(FlashNotesSettings newSettings) {
    setState(() => _settings = newSettings);
  }

  void _saveAndPop() {
    widget.onSave(_settings);
    _settings.save();
    Navigator.pop(context);
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    const sectionColor = Color(0xFF2196F3);

    return Scaffold(
      appBar: AppBar(
        title: Text(tr('flash_notes_settings')),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 12),
            child: FilledButton.icon(
              onPressed: _saveAndPop,
              icon: const Icon(Icons.check, size: 18),
              label: Text(tr('save')),
            ),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // SEZIONE A: Gemini AI (gestito in Integrazioni)
          _buildSectionHeader(tr('gemini_ai'), Icons.auto_awesome, sectionColor),
          const SizedBox(height: 8),
          Card(
            elevation: 0,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            color: colorScheme.surfaceContainerLowest,
            child: ListTile(
              leading: Icon(
                _settings.geminiEnabled && _settings.geminiApiKey.isNotEmpty
                    ? Icons.check_circle
                    : Icons.radio_button_unchecked,
                color: _settings.geminiEnabled && _settings.geminiApiKey.isNotEmpty
                    ? Colors.green
                    : colorScheme.onSurfaceVariant,
              ),
              title: Text(
                _settings.geminiEnabled && _settings.geminiApiKey.isNotEmpty
                    ? tr('connected')
                    : tr('not_connected'),
                style: const TextStyle(fontWeight: FontWeight.w600),
              ),
              subtitle: Text(tr('configure_gemini')),
              trailing: const Icon(Icons.chevron_right),
              onTap: () {
                Navigator.push(context, MaterialPageRoute(builder: (_) => const IntegrationsPage())).then((_) async {
                  final updated = await FlashNotesSettings.load();
                  if (!mounted) return;
                  setState(() {
                    _settings = updated;
                    _apiKeyController.text = updated.geminiApiKey;
                  });
                });
              },
            ),
          ),

          const SizedBox(height: 24),

          // SEZIONE: Riconoscimento Foto AI (stato acquisto Ethos Aura)
          _buildSectionHeader(tr('photo_recognition'), Icons.image_search, sectionColor),
          const SizedBox(height: 8),
          Card(
            elevation: 0,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            color: colorScheme.surfaceContainerLowest,
            child: ListTile(
              leading: Icon(
                _auraSettings.photoRecognitionPurchased ? Icons.check_circle : Icons.lock_outline,
                color: _auraSettings.photoRecognitionPurchased ? Colors.green : colorScheme.onSurfaceVariant,
              ),
              title: Text(tr('photo_recognition'), style: const TextStyle(fontWeight: FontWeight.w600)),
              subtitle: Text(
                _auraSettings.photoRecognitionPurchased
                    ? tr('purchased')
                    : tr('ethos_aura'),
                style: TextStyle(fontSize: 12, color: _auraSettings.photoRecognitionPurchased ? Colors.green : colorScheme.onSurfaceVariant),
              ),
            ),
          ),

          const SizedBox(height: 24),

          // SEZIONE B: Salvataggio flash note su Deep Note
          _buildSectionHeader(tr('save_flash_to_deep'), Icons.save_alt, sectionColor),
          const SizedBox(height: 8),
          Card(
            elevation: 0,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            color: colorScheme.surfaceContainerLowest,
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: SizedBox(
                width: double.infinity,
                child: SegmentedButton<String>(
                  segments: [
                    ButtonSegment(value: 'never', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('auto_save_never'), style: const TextStyle(fontSize: 11)))),
                    ButtonSegment(value: 'daily', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('daily'), style: const TextStyle(fontSize: 11)))),
                    ButtonSegment(value: 'weekly', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('weekly'), style: const TextStyle(fontSize: 11)))),
                    ButtonSegment(value: 'monthly', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('monthly'), style: const TextStyle(fontSize: 11)))),
                  ],
                  selected: {_settings.autoSaveMode == 'custom' ? 'never' : _settings.autoSaveMode},
                  onSelectionChanged: (sel) {
                    _updateSettings(_settings.copyWith(autoSaveMode: sel.first));
                  },
                  showSelectedIcon: false,
                  style: const ButtonStyle(visualDensity: VisualDensity.compact),
                ),
              ),
            ),
          ),
          const SizedBox(height: 8),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 4),
            child: Text(
              '${tr('auto_save_weekly_desc')} → Deep Note',
              style: TextStyle(
                fontSize: 12,
                fontStyle: FontStyle.italic,
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ),

          const SizedBox(height: 24),

          // SEZIONE: Raggruppamento per Data
          _buildSectionHeader(tr('grouping_mode'), Icons.flash_on, sectionColor),
          const SizedBox(height: 8),
          Card(
            elevation: 0,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            color: colorScheme.surfaceContainerLowest,
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: SizedBox(
                width: double.infinity,
                child: SegmentedButton<String>(
                  segments: [
                    ButtonSegment(value: 'daily', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('daily'), style: const TextStyle(fontSize: 11)))),
                    ButtonSegment(value: 'weekly', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('weekly'), style: const TextStyle(fontSize: 11)))),
                    ButtonSegment(value: 'monthly', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('monthly'), style: const TextStyle(fontSize: 11)))),
                    ButtonSegment(value: 'yearly', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('yearly'), style: const TextStyle(fontSize: 11)))),
                  ],
                  selected: {_settings.groupingMode},
                  onSelectionChanged: (sel) {
                    _updateSettings(_settings.copyWith(groupingMode: sel.first));
                  },
                  showSelectedIcon: false,
                  style: const ButtonStyle(visualDensity: VisualDensity.compact),
                ),
              ),
            ),
          ),

          const SizedBox(height: 24),

          // SEZIONE: Stile Note
          _buildSectionHeader(tr('note_style'), Icons.style, sectionColor),
          const SizedBox(height: 8),
          if (_auraSettings.paperStickyPurchased)
            Card(
              elevation: 0,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              color: colorScheme.surfaceContainerLowest,
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    SizedBox(
                      width: double.infinity,
                      child: SegmentedButton<String>(
                        segments: [
                          ButtonSegment(value: 'modern', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('note_style_modern'), style: const TextStyle(fontSize: 11)))),
                          ButtonSegment(value: 'paper', label: FittedBox(fit: BoxFit.scaleDown, child: Text(tr('note_style_paper'), style: const TextStyle(fontSize: 11)))),
                        ],
                        selected: {_settings.noteStyle},
                        onSelectionChanged: (sel) {
                          _updateSettings(_settings.copyWith(noteStyle: sel.first));
                        },
                        showSelectedIcon: false,
                        style: const ButtonStyle(visualDensity: VisualDensity.compact),
                      ),
                    ),
                    if (_settings.noteStyle == 'paper') ...[
                      const SizedBox(height: 8),
                      Text(
                        tr('note_style_paper_desc'),
                        style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic, color: colorScheme.onSurfaceVariant),
                      ),
                    ],
                  ],
                ),
              ),
            )
          else
            Card(
              elevation: 0,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
              color: colorScheme.surfaceContainerLowest,
              child: ListTile(
                leading: Icon(Icons.lock_outline, color: colorScheme.onSurfaceVariant),
                title: Text(tr('note_style_paper'), style: const TextStyle(fontWeight: FontWeight.w600)),
                subtitle: Text(tr('ethos_aura'), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                trailing: const Icon(Icons.chevron_right),
                onTap: () {
                  Navigator.push(context, MaterialPageRoute(builder: (_) => const EthosAuraPage())).then((_) => _loadAuraSettings());
                },
              ),
            ),

          const SizedBox(height: 24),

          // SEZIONE C: Durata nota vocale
          _buildSectionHeader(tr('voice_duration'), Icons.mic, sectionColor),
          const SizedBox(height: 8),
          Card(
            elevation: 0,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            color: colorScheme.surfaceContainerLowest,
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: _auraSettings.unlimitedVoicePurchased
                  ? Row(
                      children: [
                        const Icon(Icons.check_circle, color: Colors.green),
                        const SizedBox(width: 12),
                        Text(
                          '${tr('max_duration')}: ${tr('unlimited')}',
                          style: const TextStyle(fontWeight: FontWeight.w600),
                        ),
                      ],
                    )
                  : Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(tr('max_duration'), style: const TextStyle(fontWeight: FontWeight.w600)),
                        const SizedBox(height: 12),
                        _buildAudioDurationSlider(colorScheme),
                      ],
                    ),
            ),
          ),

          const SizedBox(height: 24),

          // Save button
          SizedBox(
            width: double.infinity,
            child: FilledButton.icon(
              onPressed: _saveAndPop,
              icon: const Icon(Icons.save),
              label: Text(tr('save')),
            ),
          ),
          const SizedBox(height: 32),
        ],
      ),
    );
  }

  Widget _buildAudioDurationSlider(ColorScheme colorScheme) {
    final durations = [30, 60, 120, 180, 300, 600];
    final currentIndex = durations.indexOf(_settings.maxAudioDurationSeconds);
    final sliderIndex = currentIndex >= 0 ? currentIndex.toDouble() : 2.0;

    String durationLabel(int seconds) {
      if (seconds < 60) return '$seconds ${tr('seconds')}';
      final mins = seconds ~/ 60;
      return '$mins min';
    }

    return Column(
      children: [
        Slider(
          value: sliderIndex,
          min: 0,
          max: (durations.length - 1).toDouble(),
          divisions: durations.length - 1,
          label: durationLabel(durations[sliderIndex.round()]),
          onChanged: (value) {
            _updateSettings(_settings.copyWith(maxAudioDurationSeconds: durations[value.round()]));
          },
        ),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text('30s', style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant)),
            Text('10 min', style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant)),
          ],
        ),
      ],
    );
  }

  Widget _buildSectionHeader(String title, IconData icon, Color color) {
    return Row(
      children: [
        Icon(icon, color: color, size: 24),
        const SizedBox(width: 8),
        Text(
          title,
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
      ],
    );
  }

}

// ─── Theme Catalog Page ──────────────────────────────────────────────────────

class _ThemeCatalogPage extends StatefulWidget {
  final String currentTheme;
  final EthosAuraSettings auraSettings;
  final Function(String) onThemeSelected;
  final VoidCallback onAuraSettingsChanged;

  const _ThemeCatalogPage({
    required this.currentTheme,
    required this.auraSettings,
    required this.onThemeSelected,
    required this.onAuraSettingsChanged,
  });

  @override
  State<_ThemeCatalogPage> createState() => _ThemeCatalogPageState();
}

class _ThemeCatalogPageState extends State<_ThemeCatalogPage> {
  late String _currentTheme;
  late EthosAuraSettings _auraSettings;

  @override
  void initState() {
    super.initState();
    _currentTheme = widget.currentTheme;
    _auraSettings = widget.auraSettings;
  }

  Future<void> _refreshAura() async {
    final s = await EthosAuraSettings.load();
    if (!mounted) return;
    setState(() => _auraSettings = s);
    widget.onAuraSettingsChanged();
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    // Build list of purchased themes
    final purchasedThemes = <_PremiumThemeInfo>[];
    if (_auraSettings.ephemeraThemePurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'ephemera', name: 'Ephemera', description: tr('ephemera_theme_desc'), icon: Icons.menu_book,
        color: const Color(0xFF795548), previewColors: const [Color(0xFFF4EBD0), Color(0xFF795548), Color(0xFF3E2723)],
      ));
    }
    if (_auraSettings.nordicZenPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'nordic_zen', name: 'Nordic Zen', description: tr('nordic_zen_desc'), icon: Icons.ac_unit,
        color: const Color(0xFF78909C), previewColors: const [Color(0xFFF0F4F8), Color(0xFF78909C), Color(0xFF2D3748)],
      ));
    }
    if (_auraSettings.greenSalviaPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'green_salvia', name: 'Green Salvia', description: tr('green_salvia_desc'), icon: Icons.eco,
        color: const Color(0xFF6B8F71), previewColors: const [Color(0xFFE2E8E4), Color(0xFF6B8F71), Color(0xFF2A3B32)],
      ));
    }
    if (_auraSettings.sakuraPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'sakura', name: 'Sakura', description: tr('sakura_desc'), icon: Icons.local_florist,
        color: const Color(0xFFB5838D), previewColors: const [Color(0xFFF7E7E6), Color(0xFFB5838D), Color(0xFF2D3748)],
      ));
    }
    // Oltre l'Oceano
    if (_auraSettings.spadaccinoPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'spadaccino', name: tr('spadaccino_theme'), description: tr('spadaccino_desc'), icon: Icons.sports_martial_arts,
        color: const Color(0xFF1B4D3E), previewColors: const [Color(0xFF0D2818), Color(0xFF1B4D3E), Color(0xFF2E7D5B)],
      ));
    }
    if (_auraSettings.sognoRePurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'sogno_re', name: tr('sogno_re_theme'), description: tr('sogno_re_desc'), icon: Icons.wb_sunny,
        color: const Color(0xFFD32F2F), previewColors: const [Color(0xFFFFF9C4), Color(0xFFD32F2F), Color(0xFF1565C0)],
      ));
    }
    if (_auraSettings.mappaTesoroPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'mappa_tesoro', name: tr('mappa_tesoro_theme'), description: tr('mappa_tesoro_desc'), icon: Icons.explore,
        color: const Color(0xFFE6A800), previewColors: const [Color(0xFFFFE0B2), Color(0xFFE6A800), Color(0xFF0D47A1)],
      ));
    }
    // Spirito della Foglia
    if (_auraSettings.fulminePurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'fulmine', name: tr('fulmine_theme'), description: tr('fulmine_desc'), icon: Icons.bolt,
        color: const Color(0xFF7C4DFF), previewColors: const [Color(0xFF1A1A2E), Color(0xFF7C4DFF), Color(0xFFE8EAF6)],
      ));
    }
    if (_auraSettings.eremitaPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'eremita', name: tr('eremita_theme'), description: tr('eremita_desc'), icon: Icons.local_fire_department,
        color: const Color(0xFFE65100), previewColors: const [Color(0xFF0A0A0A), Color(0xFFE65100), Color(0xFF00BCD4)],
      ));
    }
    if (_auraSettings.saggioPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'saggio', name: tr('saggio_theme'), description: tr('saggio_desc'), icon: Icons.auto_stories,
        color: const Color(0xFF691212), previewColors: const [Color(0xFF2A0E0E), Color(0xFF691212), Color(0xFF6B8E23)],
      ));
    }
    // Serie Cult
    if (_auraSettings.cabinaTempoPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'cabina_tempo', name: tr('cabina_theme'), description: tr('cabina_desc'), icon: Icons.access_time,
        color: const Color(0xFF003B6F), previewColors: const [Color(0xFF001F3F), Color(0xFF003B6F), Color(0xFF90CAF9)],
      ));
    }
    if (_auraSettings.sottosopraPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'sottosopra', name: tr('sottosopra_theme'), description: tr('sottosopra_desc'), icon: Icons.flip,
        color: const Color(0xFFB71C1C), previewColors: const [Color(0xFF050510), Color(0xFFB71C1C), Color(0xFFFF1744)],
      ));
    }
    if (_auraSettings.rifugioPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'rifugio', name: tr('rifugio_theme'), description: tr('rifugio_desc'), icon: Icons.shield,
        color: const Color(0xFF32CD32), previewColors: const [Color(0xFF1A1A1A), Color(0xFF32CD32), Color(0xFF005FB8)],
      ));
    }
    if (_auraSettings.yellowNotePurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'yellow_note', name: tr('yellow_note_theme'), description: tr('yellow_note_desc'), icon: Icons.edit_note,
        color: const Color(0xFF1E3A8A), previewColors: const [Color(0xFFFEF9C3), Color(0xFF1E3A8A), Color(0xFFEF4444)],
      ));
    }
    if (_auraSettings.blockNotePurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'block_note', name: tr('block_note_theme'), description: tr('block_note_desc'), icon: Icons.sticky_note_2,
        color: const Color(0xFFE6A100), previewColors: const [Color(0xFFFFF8E1), Color(0xFFFFF176), Color(0xFFE53935)],
      ));
    }
    // Notte Profonda
    if (_auraSettings.deepAbyssPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'deep_abyss', name: tr('deep_abyss_theme'), description: tr('deep_abyss_desc'), icon: Icons.dark_mode,
        color: const Color(0xFF1A237E), previewColors: const [Color(0xFF000000), Color(0xFF1A237E), Color(0xFF7C4DFF)],
      ));
    }
    if (_auraSettings.midnightForestPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'midnight_forest', name: tr('midnight_forest_theme'), description: tr('midnight_forest_desc'), icon: Icons.forest,
        color: const Color(0xFF2E7D32), previewColors: const [Color(0xFF050A05), Color(0xFF2E7D32), Color(0xFF8D6E63)],
      ));
    }
    if (_auraSettings.cyberpunkVoidPurchased) {
      purchasedThemes.add(_PremiumThemeInfo(
        id: 'cyberpunk_void', name: tr('cyberpunk_void_theme'), description: tr('cyberpunk_void_desc'), icon: Icons.electric_bolt,
        color: const Color(0xFF00BCD4), previewColors: const [Color(0xFF0F0F10), Color(0xFF00BCD4), Color(0xFFFF4081)],
      ));
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(tr('theme_catalog')),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // Purchased themes
          if (purchasedThemes.isNotEmpty) ...[
            ...purchasedThemes.map((theme) {
              final isActive = _currentTheme == theme.id;
              return Card(
                elevation: 0,
                margin: const EdgeInsets.only(bottom: 12),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(16),
                  side: isActive
                      ? BorderSide(color: theme.color, width: 2)
                      : BorderSide(color: colorScheme.outlineVariant.withValues(alpha: 0.3)),
                ),
                child: InkWell(
                  borderRadius: BorderRadius.circular(16),
                  onTap: () {
                    if (isActive) {
                      // Deselect — go back to ethos
                      setState(() => _currentTheme = 'ethos');
                      widget.onThemeSelected('ethos');
                    } else {
                      setState(() => _currentTheme = theme.id);
                      widget.onThemeSelected(theme.id);
                    }
                  },
                  child: Padding(
                    padding: const EdgeInsets.all(16),
                    child: Row(
                      children: [
                        // Color preview circles
                        Row(
                          children: theme.previewColors.map((c) => Container(
                            width: 24, height: 24,
                            margin: const EdgeInsets.only(right: 6),
                            decoration: BoxDecoration(
                              color: c,
                              shape: BoxShape.circle,
                              border: Border.all(color: colorScheme.outlineVariant.withValues(alpha: 0.3)),
                            ),
                          )).toList(),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(theme.name, style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 16)),
                              const SizedBox(height: 2),
                              Text(theme.description, style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                            ],
                          ),
                        ),
                        if (isActive)
                          Container(
                            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                            decoration: BoxDecoration(
                              color: theme.color.withValues(alpha: 0.12),
                              borderRadius: BorderRadius.circular(20),
                            ),
                            child: Text(tr('active_theme'), style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600, color: theme.color)),
                          )
                        else
                          Icon(Icons.circle_outlined, color: colorScheme.outlineVariant),
                      ],
                    ),
                  ),
                ),
              );
            }),
          ],

          // Empty state or browse button
          if (purchasedThemes.isEmpty)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 48),
              child: Column(
                children: [
                  Icon(Icons.palette_outlined, size: 64, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3)),
                  const SizedBox(height: 16),
                  Text(tr('no_themes_purchased'), style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500, color: colorScheme.onSurfaceVariant)),
                  const SizedBox(height: 8),
                  Text(tr('browse_themes'), style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7)), textAlign: TextAlign.center),
                ],
              ),
            ),

          const SizedBox(height: 16),
          FilledButton.icon(
            onPressed: () {
              Navigator.push(context, MaterialPageRoute(builder: (_) => const EthosAuraPage())).then((_) => _refreshAura());
            },
            icon: const Icon(Icons.auto_awesome, size: 18),
            label: Text(tr('browse_themes')),
            style: FilledButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 14),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
            ),
          ),
        ],
      ),
    );
  }
}

class _PremiumThemeInfo {
  final String id;
  final String name;
  final String description;
  final IconData icon;
  final Color color;
  final List<Color> previewColors;

  const _PremiumThemeInfo({
    required this.id,
    required this.name,
    required this.description,
    required this.icon,
    required this.color,
    required this.previewColors,
  });
}

// ─── Ethos Aura (Premium Hub) ────────────────────────────────────────────────

class EthosAuraSettings {
  final bool oroscopoPurchased;
  final bool unlimitedVoicePurchased;
  final bool unlimitedProfilesPurchased;
  final bool photoRecognitionPurchased;
  final bool cycleTrackingPurchased;
  final bool ephemeraThemePurchased;
  final bool nordicZenPurchased;
  final bool greenSalviaPurchased;
  final bool sakuraPurchased;
  final bool spadaccinoPurchased;
  final bool sognoRePurchased;
  final bool mappaTesoroPurchased;
  final bool fulminePurchased;
  final bool eremitaPurchased;
  final bool saggioPurchased;
  final bool cabinaTempoPurchased;
  final bool sottosopraPurchased;
  final bool rifugioPurchased;
  final bool yellowNotePurchased;
  final bool deepAbyssPurchased;
  final bool midnightForestPurchased;
  final bool cyberpunkVoidPurchased;
  final bool blockNotePurchased;
  final bool paperStickyPurchased;

  const EthosAuraSettings({
    this.oroscopoPurchased = false,
    this.unlimitedVoicePurchased = false,
    this.unlimitedProfilesPurchased = false,
    this.photoRecognitionPurchased = false,
    this.cycleTrackingPurchased = false,
    this.ephemeraThemePurchased = false,
    this.nordicZenPurchased = false,
    this.greenSalviaPurchased = false,
    this.sakuraPurchased = false,
    this.spadaccinoPurchased = false,
    this.sognoRePurchased = false,
    this.mappaTesoroPurchased = false,
    this.fulminePurchased = false,
    this.eremitaPurchased = false,
    this.saggioPurchased = false,
    this.cabinaTempoPurchased = false,
    this.sottosopraPurchased = false,
    this.rifugioPurchased = false,
    this.yellowNotePurchased = false,
    this.deepAbyssPurchased = false,
    this.midnightForestPurchased = false,
    this.cyberpunkVoidPurchased = false,
    this.blockNotePurchased = false,
    this.paperStickyPurchased = false,
  });

  EthosAuraSettings copyWith({
    bool? oroscopoPurchased,
    bool? unlimitedVoicePurchased,
    bool? unlimitedProfilesPurchased,
    bool? photoRecognitionPurchased,
    bool? cycleTrackingPurchased,
    bool? ephemeraThemePurchased,
    bool? nordicZenPurchased,
    bool? greenSalviaPurchased,
    bool? sakuraPurchased,
    bool? spadaccinoPurchased,
    bool? sognoRePurchased,
    bool? mappaTesoroPurchased,
    bool? fulminePurchased,
    bool? eremitaPurchased,
    bool? saggioPurchased,
    bool? cabinaTempoPurchased,
    bool? sottosopraPurchased,
    bool? rifugioPurchased,
    bool? yellowNotePurchased,
    bool? deepAbyssPurchased,
    bool? midnightForestPurchased,
    bool? cyberpunkVoidPurchased,
    bool? blockNotePurchased,
    bool? paperStickyPurchased,
  }) {
    return EthosAuraSettings(
      oroscopoPurchased: oroscopoPurchased ?? this.oroscopoPurchased,
      unlimitedVoicePurchased: unlimitedVoicePurchased ?? this.unlimitedVoicePurchased,
      unlimitedProfilesPurchased: unlimitedProfilesPurchased ?? this.unlimitedProfilesPurchased,
      photoRecognitionPurchased: photoRecognitionPurchased ?? this.photoRecognitionPurchased,
      cycleTrackingPurchased: cycleTrackingPurchased ?? this.cycleTrackingPurchased,
      ephemeraThemePurchased: ephemeraThemePurchased ?? this.ephemeraThemePurchased,
      nordicZenPurchased: nordicZenPurchased ?? this.nordicZenPurchased,
      greenSalviaPurchased: greenSalviaPurchased ?? this.greenSalviaPurchased,
      sakuraPurchased: sakuraPurchased ?? this.sakuraPurchased,
      spadaccinoPurchased: spadaccinoPurchased ?? this.spadaccinoPurchased,
      sognoRePurchased: sognoRePurchased ?? this.sognoRePurchased,
      mappaTesoroPurchased: mappaTesoroPurchased ?? this.mappaTesoroPurchased,
      fulminePurchased: fulminePurchased ?? this.fulminePurchased,
      eremitaPurchased: eremitaPurchased ?? this.eremitaPurchased,
      saggioPurchased: saggioPurchased ?? this.saggioPurchased,
      cabinaTempoPurchased: cabinaTempoPurchased ?? this.cabinaTempoPurchased,
      sottosopraPurchased: sottosopraPurchased ?? this.sottosopraPurchased,
      rifugioPurchased: rifugioPurchased ?? this.rifugioPurchased,
      yellowNotePurchased: yellowNotePurchased ?? this.yellowNotePurchased,
      deepAbyssPurchased: deepAbyssPurchased ?? this.deepAbyssPurchased,
      midnightForestPurchased: midnightForestPurchased ?? this.midnightForestPurchased,
      cyberpunkVoidPurchased: cyberpunkVoidPurchased ?? this.cyberpunkVoidPurchased,
      blockNotePurchased: blockNotePurchased ?? this.blockNotePurchased,
      paperStickyPurchased: paperStickyPurchased ?? this.paperStickyPurchased,
    );
  }

  Map<String, dynamic> toJson() => {
    'oroscopoPurchased': oroscopoPurchased,
    'unlimitedVoicePurchased': unlimitedVoicePurchased,
    'unlimitedProfilesPurchased': unlimitedProfilesPurchased,
    'photoRecognitionPurchased': photoRecognitionPurchased,
    'cycleTrackingPurchased': cycleTrackingPurchased,
    'ephemeraThemePurchased': ephemeraThemePurchased,
    'nordicZenPurchased': nordicZenPurchased,
    'greenSalviaPurchased': greenSalviaPurchased,
    'sakuraPurchased': sakuraPurchased,
    'spadaccinoPurchased': spadaccinoPurchased,
    'sognoRePurchased': sognoRePurchased,
    'mappaTesoroPurchased': mappaTesoroPurchased,
    'fulminePurchased': fulminePurchased,
    'eremitaPurchased': eremitaPurchased,
    'saggioPurchased': saggioPurchased,
    'cabinaTempoPurchased': cabinaTempoPurchased,
    'sottosopraPurchased': sottosopraPurchased,
    'rifugioPurchased': rifugioPurchased,
    'yellowNotePurchased': yellowNotePurchased,
    'deepAbyssPurchased': deepAbyssPurchased,
    'midnightForestPurchased': midnightForestPurchased,
    'cyberpunkVoidPurchased': cyberpunkVoidPurchased,
    'blockNotePurchased': blockNotePurchased,
    'paperStickyPurchased': paperStickyPurchased,
  };

  factory EthosAuraSettings.fromJson(Map<String, dynamic> json) =>
      EthosAuraSettings(
        oroscopoPurchased: json['oroscopoPurchased'] ?? false,
        unlimitedVoicePurchased: json['unlimitedVoicePurchased'] ?? false,
        unlimitedProfilesPurchased: json['unlimitedProfilesPurchased'] ?? false,
        photoRecognitionPurchased: json['photoRecognitionPurchased'] ?? false,
        cycleTrackingPurchased: json['cycleTrackingPurchased'] ?? false,
        ephemeraThemePurchased: json['ephemeraThemePurchased'] ?? false,
        nordicZenPurchased: json['nordicZenPurchased'] ?? false,
        greenSalviaPurchased: json['greenSalviaPurchased'] ?? false,
        sakuraPurchased: json['sakuraPurchased'] ?? false,
        spadaccinoPurchased: json['spadaccinoPurchased'] ?? false,
        sognoRePurchased: json['sognoRePurchased'] ?? false,
        mappaTesoroPurchased: json['mappaTesoroPurchased'] ?? false,
        fulminePurchased: json['fulminePurchased'] ?? false,
        eremitaPurchased: json['eremitaPurchased'] ?? false,
        saggioPurchased: json['saggioPurchased'] ?? false,
        cabinaTempoPurchased: json['cabinaTempoPurchased'] ?? false,
        sottosopraPurchased: json['sottosopraPurchased'] ?? false,
        rifugioPurchased: json['rifugioPurchased'] ?? false,
        yellowNotePurchased: json['yellowNotePurchased'] ?? false,
        deepAbyssPurchased: json['deepAbyssPurchased'] ?? false,
        midnightForestPurchased: json['midnightForestPurchased'] ?? false,
        cyberpunkVoidPurchased: json['cyberpunkVoidPurchased'] ?? false,
        blockNotePurchased: json['blockNotePurchased'] ?? false,
        paperStickyPurchased: json['paperStickyPurchased'] ?? false,
      );

  static Future<EthosAuraSettings> load() async {
    final jsonStr = await DatabaseHelper().getSetting('ethos_aura_settings');
    if (jsonStr != null) {
      return EthosAuraSettings.fromJson(json.decode(jsonStr));
    }
    return const EthosAuraSettings();
  }

  Future<void> save() async {
    await DatabaseHelper().saveSetting('ethos_aura_settings', json.encode(toJson()));
  }
}

class EthosAuraPage extends StatefulWidget {
  const EthosAuraPage({super.key});

  @override
  State<EthosAuraPage> createState() => _EthosAuraPageState();
}

class _EthosAuraPageState extends State<EthosAuraPage> {
  EthosAuraSettings _auraSettings = const EthosAuraSettings();
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    final s = await EthosAuraSettings.load();
    if (!mounted) return;
    setState(() { _auraSettings = s; _loading = false; });
  }

  Future<void> _simulatePurchase(String feature) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('confirm_purchase')),
        content: Text(tr('purchase_confirm_msg')),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
          FilledButton(onPressed: () => Navigator.pop(ctx, true), child: Text(tr('confirm'))),
        ],
      ),
    );
    if (confirmed != true) return;

    EthosAuraSettings updated;
    switch (feature) {
      case 'horoscope':
        updated = _auraSettings.copyWith(oroscopoPurchased: true);
        break;
      case 'voice':
        updated = _auraSettings.copyWith(unlimitedVoicePurchased: true);
        break;
      case 'profiles':
        updated = _auraSettings.copyWith(unlimitedProfilesPurchased: true);
        break;
      case 'photo_recognition':
        updated = _auraSettings.copyWith(photoRecognitionPurchased: true);
        break;
      case 'cycle_tracking':
        updated = _auraSettings.copyWith(cycleTrackingPurchased: true);
        break;
      case 'ephemera_theme':
        updated = _auraSettings.copyWith(ephemeraThemePurchased: true);
        break;
      case 'nordic_zen_theme':
        updated = _auraSettings.copyWith(nordicZenPurchased: true);
        break;
      case 'green_salvia_theme':
        updated = _auraSettings.copyWith(greenSalviaPurchased: true);
        break;
      case 'sakura_theme':
        updated = _auraSettings.copyWith(sakuraPurchased: true);
        break;
      case 'spadaccino_theme':
        updated = _auraSettings.copyWith(spadaccinoPurchased: true);
        break;
      case 'sogno_re_theme':
        updated = _auraSettings.copyWith(sognoRePurchased: true);
        break;
      case 'mappa_tesoro_theme':
        updated = _auraSettings.copyWith(mappaTesoroPurchased: true);
        break;
      case 'fulmine_theme':
        updated = _auraSettings.copyWith(fulminePurchased: true);
        break;
      case 'eremita_theme':
        updated = _auraSettings.copyWith(eremitaPurchased: true);
        break;
      case 'saggio_theme':
        updated = _auraSettings.copyWith(saggioPurchased: true);
        break;
      case 'cabina_tempo_theme':
        updated = _auraSettings.copyWith(cabinaTempoPurchased: true);
        break;
      case 'sottosopra_theme':
        updated = _auraSettings.copyWith(sottosopraPurchased: true);
        break;
      case 'rifugio_theme':
        updated = _auraSettings.copyWith(rifugioPurchased: true);
        break;
      case 'yellow_note_theme':
        updated = _auraSettings.copyWith(yellowNotePurchased: true);
        break;
      case 'deep_abyss_theme':
        updated = _auraSettings.copyWith(deepAbyssPurchased: true);
        break;
      case 'midnight_forest_theme':
        updated = _auraSettings.copyWith(midnightForestPurchased: true);
        break;
      case 'cyberpunk_void_theme':
        updated = _auraSettings.copyWith(cyberpunkVoidPurchased: true);
        break;
      case 'block_note_theme':
        updated = _auraSettings.copyWith(blockNotePurchased: true, paperStickyPurchased: true);
        break;
      case 'paper_sticky':
        updated = _auraSettings.copyWith(paperStickyPurchased: true);
        break;
      default:
        return;
    }
    await updated.save();
    if (!mounted) return;
    setState(() => _auraSettings = updated);
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('purchase_success')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    const auraColor = Color(0xFFAB47BC);

    return Scaffold(
      appBar: AppBar(
        title: Text(tr('ethos_aura')),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : ListView(
              padding: const EdgeInsets.all(16),
              children: [
                // Header
                Card(
                  elevation: 0,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                  color: auraColor.withValues(alpha: 0.08),
                  child: Padding(
                    padding: const EdgeInsets.all(20),
                    child: Column(
                      children: [
                        Container(
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: auraColor.withValues(alpha: 0.15),
                            shape: BoxShape.circle,
                          ),
                          child: const Icon(Icons.auto_awesome, color: auraColor, size: 40),
                        ),
                        const SizedBox(height: 12),
                        Text(tr('ethos_aura'), style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: auraColor)),
                        const SizedBox(height: 4),
                        Text(tr('ethos_aura_desc'), style: TextStyle(fontSize: 14, color: colorScheme.onSurfaceVariant), textAlign: TextAlign.center),
                      ],
                    ),
                  ),
                ),
                const SizedBox(height: 16),

                // Unlimited voice notes
                _buildPurchaseTile(
                  icon: Icons.mic,
                  title: tr('unlock_unlimited_voice'),
                  price: '€1,00',
                  purchased: _auraSettings.unlimitedVoicePurchased,
                  onTap: () => _simulatePurchase('voice'),
                  colorScheme: colorScheme,
                ),

                // Photo Recognition AI
                _buildPurchaseTile(
                  icon: Icons.image_search,
                  title: tr('unlock_photo_recognition'),
                  price: '€0,99',
                  purchased: _auraSettings.photoRecognitionPurchased,
                  onTap: () => _simulatePurchase('photo_recognition'),
                  colorScheme: colorScheme,
                ),

                // Cycle Tracking
                _buildPurchaseTile(
                  icon: Icons.water_drop,
                  title: tr('unlock_cycle_tracking'),
                  price: '€1,99',
                  purchased: _auraSettings.cycleTrackingPurchased,
                  onTap: () => _simulatePurchase('cycle_tracking'),
                  colorScheme: colorScheme,
                ),

                // Theme Catalog
                Card(
                  elevation: 0,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                  child: ListTile(
                    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                    leading: Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: const Color(0xFF795548).withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: const Icon(Icons.menu_book, color: Color(0xFF795548)),
                    ),
                    title: Text(tr('theme_catalog'), style: const TextStyle(fontWeight: FontWeight.w600)),
                    subtitle: Text(tr('theme_catalog_desc'), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                    trailing: const Icon(Icons.chevron_right),
                    onTap: () {
                      Navigator.push(context, PageRouteBuilder(
                        pageBuilder: (_, __, ___) => _AuraThemeStorePage(
                          auraSettings: _auraSettings,
                          onPurchase: (feature) async {
                            await _simulatePurchase(feature);
                          },
                        ),
                        transitionsBuilder: (_, anim, __, child) =>
                            SlideTransition(
                              position: Tween(begin: const Offset(1, 0), end: Offset.zero).animate(CurvedAnimation(parent: anim, curve: Curves.easeOutCubic)),
                              child: child,
                            ),
                      )).then((_) => _loadSettings());
                    },
                  ),
                ),
              ],
            ),
    );
  }

  Widget _buildPurchaseTile({
    required IconData icon,
    required String title,
    required String price,
    required bool purchased,
    required VoidCallback onTap,
    required ColorScheme colorScheme,
  }) {
    const auraColor = Color(0xFFAB47BC);
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: ListTile(
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        leading: Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: (purchased ? Colors.green : auraColor).withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(10),
          ),
          child: Icon(icon, color: purchased ? Colors.green : auraColor),
        ),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.w600)),
        subtitle: Text(purchased ? tr('purchased') : price, style: TextStyle(color: purchased ? Colors.green : colorScheme.onSurfaceVariant)),
        trailing: purchased
            ? const Icon(Icons.check_circle, color: Colors.green)
            : FilledButton(
                onPressed: onTap,
                style: FilledButton.styleFrom(backgroundColor: auraColor),
                child: Text(tr('unlock')),
              ),
      ),
    );
  }
}

class _AuraThemeStorePage extends StatefulWidget {
  final EthosAuraSettings auraSettings;
  final Future<void> Function(String) onPurchase;

  const _AuraThemeStorePage({required this.auraSettings, required this.onPurchase});

  @override
  State<_AuraThemeStorePage> createState() => _AuraThemeStorePageState();
}

class _AuraThemeStorePageState extends State<_AuraThemeStorePage> {
  late EthosAuraSettings _aura;

  @override
  void initState() {
    super.initState();
    _aura = widget.auraSettings;
  }

  Future<void> _refresh() async {
    final s = await EthosAuraSettings.load();
    if (!mounted) return;
    setState(() => _aura = s);
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    final individual = <Map<String, dynamic>>[
      {'id': 'ephemera_theme', 'name': 'Ephemera', 'desc': tr('ephemera_theme_desc'), 'color': const Color(0xFF795548), 'price': '€0,99', 'purchased': _aura.ephemeraThemePurchased, 'preview': [const Color(0xFFF4EBD0), const Color(0xFF795548), const Color(0xFF3E2723)]},
      {'id': 'nordic_zen_theme', 'name': 'Nordic Zen', 'desc': tr('nordic_zen_desc'), 'color': const Color(0xFF78909C), 'price': '€0,99', 'purchased': _aura.nordicZenPurchased, 'preview': [const Color(0xFFF0F4F8), const Color(0xFF78909C), const Color(0xFF2D3748)]},
      {'id': 'green_salvia_theme', 'name': 'Green Salvia', 'desc': tr('green_salvia_desc'), 'color': const Color(0xFF6B8F71), 'price': '€0,99', 'purchased': _aura.greenSalviaPurchased, 'preview': [const Color(0xFFE2E8E4), const Color(0xFF6B8F71), const Color(0xFF2A3B32)]},
      {'id': 'sakura_theme', 'name': 'Sakura', 'desc': tr('sakura_desc'), 'color': const Color(0xFFB5838D), 'price': '€0,99', 'purchased': _aura.sakuraPurchased, 'preview': [const Color(0xFFF7E7E6), const Color(0xFFB5838D), const Color(0xFF2D3748)]},
      {'id': 'yellow_note_theme', 'name': tr('yellow_note_theme'), 'desc': tr('yellow_note_desc'), 'color': const Color(0xFF1E3A8A), 'price': '€0,99', 'purchased': _aura.yellowNotePurchased, 'preview': [const Color(0xFFFEF9C3), const Color(0xFF1E3A8A), const Color(0xFFEF4444)]},
      {'id': 'block_note_theme', 'name': tr('block_note_theme'), 'desc': tr('block_note_desc'), 'color': const Color(0xFFE6A100), 'price': '€0,99', 'purchased': _aura.blockNotePurchased, 'preview': [const Color(0xFFFFF8E1), const Color(0xFFFFF176), const Color(0xFFE53935)]},
    ];
    final oceano = <Map<String, dynamic>>[
      {'id': 'spadaccino_theme', 'name': tr('spadaccino_theme'), 'desc': tr('spadaccino_desc'), 'color': const Color(0xFF1B4D3E), 'price': '€0,99', 'purchased': _aura.spadaccinoPurchased, 'preview': [const Color(0xFF0D2818), const Color(0xFF1B4D3E), const Color(0xFF2E7D5B)]},
      {'id': 'sogno_re_theme', 'name': tr('sogno_re_theme'), 'desc': tr('sogno_re_desc'), 'color': const Color(0xFFD32F2F), 'price': '€0,99', 'purchased': _aura.sognoRePurchased, 'preview': [const Color(0xFFFFF9C4), const Color(0xFFD32F2F), const Color(0xFF1565C0)]},
      {'id': 'mappa_tesoro_theme', 'name': tr('mappa_tesoro_theme'), 'desc': tr('mappa_tesoro_desc'), 'color': const Color(0xFFE6A800), 'price': '€0,99', 'purchased': _aura.mappaTesoroPurchased, 'preview': [const Color(0xFFFFE0B2), const Color(0xFFE6A800), const Color(0xFF0D47A1)]},
    ];
    final foglia = <Map<String, dynamic>>[
      {'id': 'fulmine_theme', 'name': tr('fulmine_theme'), 'desc': tr('fulmine_desc'), 'color': const Color(0xFF7C4DFF), 'price': '€0,99', 'purchased': _aura.fulminePurchased, 'preview': [const Color(0xFF1A1A2E), const Color(0xFF7C4DFF), const Color(0xFFE8EAF6)]},
      {'id': 'eremita_theme', 'name': tr('eremita_theme'), 'desc': tr('eremita_desc'), 'color': const Color(0xFFE65100), 'price': '€0,99', 'purchased': _aura.eremitaPurchased, 'preview': [const Color(0xFF0A0A0A), const Color(0xFFE65100), const Color(0xFF00BCD4)]},
      {'id': 'saggio_theme', 'name': tr('saggio_theme'), 'desc': tr('saggio_desc'), 'color': const Color(0xFF691212), 'price': '€0,99', 'purchased': _aura.saggioPurchased, 'preview': [const Color(0xFF2A0E0E), const Color(0xFF691212), const Color(0xFF6B8E23)]},
    ];
    final cult = <Map<String, dynamic>>[
      {'id': 'cabina_tempo_theme', 'name': tr('cabina_theme'), 'desc': tr('cabina_desc'), 'color': const Color(0xFF003B6F), 'price': '€0,99', 'purchased': _aura.cabinaTempoPurchased, 'preview': [const Color(0xFF001F3F), const Color(0xFF003B6F), const Color(0xFF90CAF9)]},
      {'id': 'sottosopra_theme', 'name': tr('sottosopra_theme'), 'desc': tr('sottosopra_desc'), 'color': const Color(0xFFB71C1C), 'price': '€0,99', 'purchased': _aura.sottosopraPurchased, 'preview': [const Color(0xFF050510), const Color(0xFFB71C1C), const Color(0xFFFF1744)]},
      {'id': 'rifugio_theme', 'name': tr('rifugio_theme'), 'desc': tr('rifugio_desc'), 'color': const Color(0xFF32CD32), 'price': '€0,99', 'purchased': _aura.rifugioPurchased, 'preview': [const Color(0xFF1A1A1A), const Color(0xFF32CD32), const Color(0xFF005FB8)]},
    ];
    final notte = <Map<String, dynamic>>[
      {'id': 'deep_abyss_theme', 'name': tr('deep_abyss_theme'), 'desc': tr('deep_abyss_desc'), 'color': const Color(0xFF1A237E), 'price': '€0,99', 'purchased': _aura.deepAbyssPurchased, 'preview': [const Color(0xFF000000), const Color(0xFF1A237E), const Color(0xFF7C4DFF)]},
      {'id': 'midnight_forest_theme', 'name': tr('midnight_forest_theme'), 'desc': tr('midnight_forest_desc'), 'color': const Color(0xFF2E7D32), 'price': '€0,99', 'purchased': _aura.midnightForestPurchased, 'preview': [const Color(0xFF050A05), const Color(0xFF2E7D32), const Color(0xFF8D6E63)]},
      {'id': 'cyberpunk_void_theme', 'name': tr('cyberpunk_void_theme'), 'desc': tr('cyberpunk_void_desc'), 'color': const Color(0xFF00BCD4), 'price': '€0,99', 'purchased': _aura.cyberpunkVoidPurchased, 'preview': [const Color(0xFF0F0F10), const Color(0xFF00BCD4), const Color(0xFFFF4081)]},
    ];

    Widget buildThemeTile(Map<String, dynamic> t) {
      final purchased = t['purchased'] as bool;
      final color = t['color'] as Color;
      final preview = t['preview'] as List<Color>;
      return Card(
        elevation: 0,
        margin: const EdgeInsets.only(bottom: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: purchased ? Colors.green.withValues(alpha: 0.4) : colorScheme.outlineVariant.withValues(alpha: 0.3)),
        ),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  ...preview.map((c) => Container(
                    width: 28, height: 28, margin: const EdgeInsets.only(right: 8),
                    decoration: BoxDecoration(color: c, shape: BoxShape.circle, border: Border.all(color: colorScheme.outlineVariant.withValues(alpha: 0.3))),
                  )),
                  const Spacer(),
                  if (purchased)
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(color: Colors.green.withValues(alpha: 0.1), borderRadius: BorderRadius.circular(20)),
                      child: Row(mainAxisSize: MainAxisSize.min, children: [
                        const Icon(Icons.check_circle, color: Colors.green, size: 16),
                        const SizedBox(width: 4),
                        Text(tr('purchased'), style: const TextStyle(fontSize: 12, fontWeight: FontWeight.w600, color: Colors.green)),
                      ]),
                    )
                  else
                    FilledButton(
                      onPressed: () async { await widget.onPurchase(t['id'] as String); await _refresh(); },
                      style: FilledButton.styleFrom(backgroundColor: color, padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10)),
                      child: Text('${tr('unlock')}  ${t['price']}'),
                    ),
                ],
              ),
              const SizedBox(height: 12),
              Text(t['name'] as String, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              const SizedBox(height: 4),
              Text(t['desc'] as String, style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant)),
            ],
          ),
        ),
      );
    }

    Widget sectionHeader(String title) => Padding(
      padding: const EdgeInsets.fromLTRB(0, 20, 0, 8),
      child: Text(title, style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: colorScheme.primary)),
    );

    return Scaffold(
      appBar: AppBar(
        title: Text(tr('theme_catalog')),
        elevation: 0, scrolledUnderElevation: 2, backgroundColor: Colors.transparent,
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          ...individual.map(buildThemeTile),
          sectionHeader(tr('collection_oceano')),
          ...oceano.map(buildThemeTile),
          sectionHeader(tr('collection_foglia')),
          ...foglia.map(buildThemeTile),
          sectionHeader(tr('collection_cult')),
          ...cult.map(buildThemeTile),
          sectionHeader(tr('collection_notte')),
          ...notte.map(buildThemeTile),
          const SizedBox(height: 16),
        ],
      ),
    );
  }
}

class NoteProSettingsPage extends StatefulWidget {
  final NoteProSettings settings;
  final Function(NoteProSettings) onSave;

  const NoteProSettingsPage({
    super.key,
    required this.settings,
    required this.onSave,
  });

  @override
  State<NoteProSettingsPage> createState() => _NoteProSettingsPageState();
}

class _NoteProSettingsPageState extends State<NoteProSettingsPage> {
  late NoteProSettings _settings;

  @override
  void initState() {
    super.initState();
    _settings = widget.settings;
  }

  void _updateSettings(NoteProSettings newSettings) {
    setState(() => _settings = newSettings);
  }

  void _saveAndPop() {
    widget.onSave(_settings);
    _settings.save();
    Navigator.pop(context);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('${tr('deep_note_settings')} - ${tr('save')}'),
        behavior: SnackBarBehavior.floating,
      ),
    );
  }


  Future<void> _importTemplate() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['txt', 'md'],
      );
      if (result == null || result.files.isEmpty) return;
      final file = result.files.first;
      String text = '';
      if (file.bytes != null) {
        text = utf8.decode(file.bytes!, allowMalformed: true);
      } else if (file.path != null) {
        text = await File(file.path!).readAsString();
      }
      if (text.isEmpty) return;

      final nameController = TextEditingController(text: file.name.replaceAll(RegExp(r'\.(txt|md)$'), ''));
      if (!mounted) return;
      final name = await showDialog<String>(
        context: context,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('template_name')),
          content: TextField(
            controller: nameController,
            autofocus: true,
            decoration: InputDecoration(
              hintText: tr('template_name'),
              prefixIcon: const Icon(Icons.title),
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
            FilledButton(
              onPressed: () => Navigator.pop(ctx, nameController.text),
              child: Text(tr('confirm')),
            ),
          ],
        ),
      );
      if (name == null || name.isEmpty || !mounted) return;

      final delta = [{'insert': '$text\n'}];
      final updated = List<Map<String, dynamic>>.from(_settings.customTemplates)
        ..add({'name': name, 'delta': json.encode(delta)});
      _updateSettings(_settings.copyWith(customTemplates: updated));
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e'), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
        );
      }
    }
  }

  Future<void> _createTemplate() async {
    final nameController = TextEditingController();
    if (!mounted) return;
    final name = await showDialog<String>(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('template_name')),
        content: TextField(
          controller: nameController,
          autofocus: true,
          decoration: InputDecoration(
            hintText: tr('template_name'),
            prefixIcon: const Icon(Icons.title),
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () => Navigator.pop(ctx, nameController.text),
            child: Text(tr('confirm')),
          ),
        ],
      ),
    );
    if (name == null || name.isEmpty) return;

    if (!mounted) return;
    await Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => NoteEditorPage(
          folders: const {},
          onSave: (note) {
            final updated = List<Map<String, dynamic>>.from(_settings.customTemplates)
              ..add({'name': name, 'delta': note.contentDelta});
            _updateSettings(_settings.copyWith(customTemplates: updated));
          },
          existingNote: ProNote(
            title: name,
            content: '',
            contentDelta: json.encode([{'insert': '\n'}]),
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    const sectionColor = Color(0xFF2196F3);

    return Scaffold(
      appBar: AppBar(
        title: Text(tr('deep_note_settings')),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 12),
            child: FilledButton.icon(
              onPressed: _saveAndPop,
              icon: const Icon(Icons.check, size: 18),
              label: Text(tr('save')),
            ),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // SEZIONE: Esportazione PDF
          _buildSectionHeader(tr('export_pdf'), Icons.picture_as_pdf, sectionColor),
          const SizedBox(height: 8),
          Card(
            elevation: 0,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            color: colorScheme.surfaceContainerLowest,
            child: SwitchListTile(
              title: Text(tr('pdf_show_logo')),
              subtitle: Text(tr('pdf_show_logo_desc')),
              value: _settings.pdfShowLogo,
              onChanged: (value) {
                _updateSettings(_settings.copyWith(pdfShowLogo: value));
              },
            ),
          ),

          const SizedBox(height: 24),

          // SEZIONE: Template Personalizzati
          _buildSectionHeader(tr('custom_templates'), Icons.description, sectionColor),
          const SizedBox(height: 8),
          Card(
            elevation: 0,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            color: colorScheme.surfaceContainerLowest,
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  if (_settings.customTemplates.isEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 8),
                      child: Text(
                        tr('no_custom_templates'),
                        style: TextStyle(
                          color: colorScheme.onSurfaceVariant,
                          fontStyle: FontStyle.italic,
                        ),
                      ),
                    )
                  else
                    ..._settings.customTemplates.asMap().entries.map((entry) {
                      final template = entry.value;
                      return ListTile(
                        contentPadding: EdgeInsets.zero,
                        leading: const Icon(Icons.article),
                        title: Text(template['name'] ?? 'Template'),
                        trailing: IconButton(
                          icon: Icon(Icons.delete_outline, color: colorScheme.error),
                          onPressed: () {
                            final updated = List<Map<String, dynamic>>.from(
                                _settings.customTemplates)
                              ..removeAt(entry.key);
                            _updateSettings(
                                _settings.copyWith(customTemplates: updated));
                          },
                        ),
                      );
                    }),
                  const SizedBox(height: 12),
                  Row(
                    children: [
                      Expanded(
                        child: OutlinedButton.icon(
                          onPressed: _importTemplate,
                          icon: const Icon(Icons.file_upload, size: 18),
                          label: Text(tr('import_template'), style: const TextStyle(fontSize: 12)),
                        ),
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: FilledButton.icon(
                          onPressed: _createTemplate,
                          icon: const Icon(Icons.add, size: 18),
                          label: Text(tr('create_template'), style: const TextStyle(fontSize: 12)),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),

          const SizedBox(height: 24),

          // SEZIONE: Cestino
          _buildSectionHeader(tr('trash'), Icons.delete_outline, sectionColor),
          const SizedBox(height: 8),
          Card(
            elevation: 0,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            color: colorScheme.surfaceContainerLowest,
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SwitchListTile(
                    contentPadding: EdgeInsets.zero,
                    title: Text(tr('enable_trash'),
                        style: TextStyle(fontWeight: FontWeight.w600)),
                    subtitle: Text(tr('keep_notes_for')),
                    value: _settings.trashEnabled,
                    onChanged: (value) {
                      _updateSettings(_settings.copyWith(trashEnabled: value));
                    },
                  ),
                  if (_settings.trashEnabled) ...[
                    const SizedBox(height: 12),
                    SizedBox(
                      width: double.infinity,
                      child: SegmentedButton<int>(
                        segments: const [
                          ButtonSegment(value: 7, label: Text('7', style: TextStyle(fontSize: 12))),
                          ButtonSegment(value: 14, label: Text('14', style: TextStyle(fontSize: 12))),
                          ButtonSegment(value: 30, label: Text('30', style: TextStyle(fontSize: 12))),
                          ButtonSegment(value: 60, label: Text('60', style: TextStyle(fontSize: 12))),
                          ButtonSegment(value: 90, label: Text('90', style: TextStyle(fontSize: 12))),
                        ],
                        selected: {_settings.trashRetentionDays},
                        onSelectionChanged: (sel) {
                          _updateSettings(_settings.copyWith(trashRetentionDays: sel.first));
                        },
                        showSelectedIcon: false,
                        style: const ButtonStyle(visualDensity: VisualDensity.compact),
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      tr('trash_auto_delete').replaceAll('{n}', '${_settings.trashRetentionDays}'),
                      style: TextStyle(
                        fontSize: 12,
                        fontStyle: FontStyle.italic,
                        color: colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ],
              ),
            ),
          ),

          const SizedBox(height: 24),

          // Save button
          SizedBox(
            width: double.infinity,
            child: FilledButton.icon(
              onPressed: _saveAndPop,
              icon: const Icon(Icons.save),
              label: Text(tr('save')),
            ),
          ),
          const SizedBox(height: 32),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(String title, IconData icon, Color color) {
    return Row(
      children: [
        Icon(icon, color: color, size: 24),
        const SizedBox(width: 8),
        Text(
          title,
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
      ],
    );
  }
}

class TrashPage extends StatefulWidget {
  const TrashPage({super.key});

  @override
  State<TrashPage> createState() => _TrashPageState();
}

class _TrashPageState extends State<TrashPage> with SingleTickerProviderStateMixin {
  List<TrashedNote> _trashedNotes = [];
  int _retentionDays = 30;
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    _loadTrash();
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  Future<void> _loadTrash() async {
    final settings = await NoteProSettings.load();
    _retentionDays = settings.trashRetentionDays;
    await TrashedNote.cleanExpired(_retentionDays);
    final notes = await TrashedNote.load();
    if (!mounted) return;
    setState(() => _trashedNotes = notes);
  }

  Future<void> _restoreNote(int index) async {
    final trashed = _trashedNotes[index];
    final db = DatabaseHelper();
    if (trashed.type == 'pro') {
      await db.insertProNote(ProNote.fromJson(trashed.noteJson));
    } else if (trashed.type == 'event') {
      final event = CalendarEventFull.fromJson(trashed.noteJson);
      final allEvents = await db.getAllEvents();
      final key = event.dateKey;
      allEvents.putIfAbsent(key, () => []).add(event);
      await db.saveAllEvents(allEvents);
    } else {
      await db.insertFlashNote(FlashNote.fromJson(trashed.noteJson));
    }
    if (trashed.id != null) {
      await db.deleteTrashedNote(trashed.id!);
    }
    if (!mounted) return;
    setState(() => _trashedNotes.removeAt(index));
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(trashed.type == 'event' ? tr('event_restored') : tr('note_restored')),
          behavior: SnackBarBehavior.floating,
        ),
      );
    }
  }

  Future<void> _deletePermanently(int index) async {
    final trashed = _trashedNotes[index];
    // Delete associated image file
    final imgHelper = ImageStorageHelper();
    try {
      final noteData = trashed.noteJson;
      if (trashed.type == 'flash') {
        await imgHelper.deleteImageFile(noteData['imagePath'] as String?);
      } else if (trashed.type == 'pro') {
        await imgHelper.deleteImageFile(noteData['imagePath'] as String?);
      } else if (trashed.type == 'event') {
        await imgHelper.deleteImageFile(noteData['attachmentPath'] as String?);
      }
    } catch (_) {}
    final db = DatabaseHelper();
    if (trashed.id != null) {
      await db.deleteTrashedNote(trashed.id!);
    }
    if (!mounted) return;
    setState(() => _trashedNotes.removeAt(index));
    ScaffoldMessenger.of(context).clearSnackBars();
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text(tr('permanently_deleted')),
      action: SnackBarAction(
        label: tr('undo'),
        onPressed: () async {
          final newId = await db.insertTrashedNote(trashed);
          final restored = TrashedNote(
            id: newId,
            type: trashed.type,
            noteJson: trashed.noteJson,
            deletedAt: trashed.deletedAt,
          );
          setState(() => _trashedNotes.insert(index.clamp(0, _trashedNotes.length), restored));
        },
      ),
      behavior: SnackBarBehavior.floating,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    ));
  }

  Future<void> _emptyTrash() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(tr('empty_trash')),
        content: Text(tr('empty_trash_confirm')),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
          FilledButton(onPressed: () => Navigator.pop(ctx, true), child: Text(tr('empty_action'))),
        ],
      ),
    );
    if (confirmed == true) {
      // Delete all associated image files
      final imgHelper = ImageStorageHelper();
      for (final trashed in _trashedNotes) {
        try {
          final noteData = trashed.noteJson;
          if (trashed.type == 'flash' || trashed.type == 'pro') {
            await imgHelper.deleteImageFile(noteData['imagePath'] as String?);
          } else if (trashed.type == 'event') {
            await imgHelper.deleteImageFile(noteData['attachmentPath'] as String?);
          }
        } catch (_) {}
      }
      if (!mounted) return;
      setState(() => _trashedNotes.clear());
      await TrashedNote.saveAll([]);
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final proNotes = _trashedNotes.where((n) => n.type == 'pro').toList();
    final flashNotes = _trashedNotes.where((n) => n.type == 'flash').toList();
    final eventNotes = _trashedNotes.where((n) => n.type == 'event').toList();

    return Scaffold(
      appBar: AppBar(
        title: Text(tr('trash')),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
        actions: [
          if (_trashedNotes.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(right: 12),
              child: FilledButton.icon(
                onPressed: _emptyTrash,
                icon: const Icon(Icons.delete_forever, size: 18),
                label: Text(tr('empty_action')),
                style: FilledButton.styleFrom(
                  backgroundColor: colorScheme.error,
                  foregroundColor: colorScheme.onError,
                ),
              ),
            ),
        ],
        bottom: TabBar(
          controller: _tabController,
          isScrollable: true,
          tabAlignment: TabAlignment.center,
          tabs: [
            Tab(text: 'Deep Note (${proNotes.length})'),
            Tab(text: 'Flash (${flashNotes.length})'),
            Tab(text: '${tr('calendar')} (${eventNotes.length})'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildTrashList(proNotes, colorScheme, _sectionAccent(context, 0)),
          _buildTrashList(flashNotes, colorScheme, _sectionAccent(context, 2)),
          _buildTrashList(eventNotes, colorScheme, _sectionAccent(context, 1)),
        ],
      ),
    );
  }

  Widget _buildTrashList(List<TrashedNote> notes, ColorScheme colorScheme, Color accentColor) {
    if (notes.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.delete_outline, size: 64, color: colorScheme.outlineVariant),
            const SizedBox(height: 12),
            Text(
              tr('trash_empty'),
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: notes.length,
      itemBuilder: (context, index) {
        final trashed = notes[index];
        final globalIndex = _trashedNotes.indexOf(trashed);
        final daysLeft = trashed.daysRemaining(_retentionDays);
        final String title;
        final String subtitle;
        if (trashed.type == 'pro') {
          title = (trashed.noteJson['title'] ?? tr('untitled')).toString();
          subtitle = (trashed.noteJson['content'] ?? '').toString();
        } else if (trashed.type == 'event') {
          title = (trashed.noteJson['title'] ?? tr('untitled')).toString();
          final startStr = trashed.noteJson['startTime'];
          if (startStr != null) {
            final dt = DateTime.tryParse(startStr.toString());
            subtitle = dt != null ? '${dt.day.toString().padLeft(2, '0')}/${dt.month.toString().padLeft(2, '0')}/${dt.year} ${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}' : '';
          } else {
            subtitle = '';
          }
        } else {
          title = (trashed.noteJson['content'] ?? '').toString();
          subtitle = '';
        }

        return Card(
          margin: const EdgeInsets.only(bottom: 12),
          child: Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(16),
              border: Border(left: BorderSide(color: accentColor, width: 4)),
            ),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                children: [
                  CircleAvatar(
                    radius: 20,
                    backgroundColor: accentColor.withValues(alpha: 0.12),
                    child: Icon(
                      trashed.type == 'pro' ? Icons.description : trashed.type == 'event' ? Icons.event : Icons.flash_on,
                      color: accentColor,
                      size: 20,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          title,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 14),
                        ),
                        if (subtitle.isNotEmpty) ...[
                          const SizedBox(height: 2),
                          Text(
                            subtitle,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant),
                          ),
                        ],
                        const SizedBox(height: 4),
                        Text(
                          daysLeft > 0
                              ? tr('deletion_in_days').replaceAll('{n}', '$daysLeft')
                              : tr('expiring_today'),
                          style: TextStyle(
                            fontSize: 11,
                            color: daysLeft <= 3 ? colorScheme.error : colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.restore),
                    color: colorScheme.primary,
                    tooltip: tr('restore'),
                    onPressed: () => _restoreNote(globalIndex),
                  ),
                  IconButton(
                    icon: const Icon(Icons.delete_forever),
                    color: colorScheme.error,
                    tooltip: tr('delete_permanently'),
                    onPressed: () => _deletePermanently(globalIndex),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}

class FlashNoteEditorPage extends StatefulWidget {
  final FlashNote? existingNote;
  final Function(FlashNote) onSave;
  final String? heroTag;

  const FlashNoteEditorPage({
    super.key,
    this.existingNote,
    required this.onSave,
    this.heroTag,
  });

  @override
  State<FlashNoteEditorPage> createState() => _FlashNoteEditorPageState();
}

class _FlashNoteEditorPageState extends State<FlashNoteEditorPage> {
  late TextEditingController _bodyController;
  late FocusNode _bodyFocusNode;
  bool _hasChanges = false;
  String? _attachedImageBase64;
  String? _attachedImagePath;
  String _prevText = '';
  // Audio playback (for audio notes opened as text)
  ap.AudioPlayer? _editorAudioPlayer;
  bool _isPlayingAudio = false;
  Duration _editorAudioPosition = Duration.zero;
  Duration _editorAudioDuration = Duration.zero;
  bool _imageExpanded = false;
  bool _isEditing = false;
  bool _checkboxJustTapped = false;
  final List<TapGestureRecognizer> _recognizers = [];

  static final _tokenRegex = RegExp(
    r'https?://[^\s<>\[\](){}\"]+|[☐☑]',
    caseSensitive: false,
  );

  @override
  void initState() {
    super.initState();
    _bodyFocusNode = FocusNode();
    _bodyFocusNode.addListener(_onFocusChanged);
    _bodyController = TextEditingController(text: widget.existingNote?.content ?? '');
    _bodyController.addListener(_onChanged);
    _attachedImageBase64 = widget.existingNote?.imageBase64;
    _attachedImagePath = widget.existingNote?.imagePath;
    _prevText = _bodyController.text;
    _bodyController.addListener(_handleListContinuation);
    // New notes start in edit mode
    _isEditing = widget.existingNote == null;
  }

  void _onFocusChanged() {
    if (!_bodyFocusNode.hasFocus && _isEditing) {
      setState(() => _isEditing = false);
    }
  }

  void _onChanged() {
    if (!_hasChanges) setState(() => _hasChanges = true);
  }

  @override
  void dispose() {
    for (final r in _recognizers) { r.dispose(); }
    _recognizers.clear();
    _editorAudioPlayer?.dispose();
    _bodyController.removeListener(_handleListContinuation);
    _bodyController.dispose();
    _bodyFocusNode.removeListener(_onFocusChanged);
    _bodyFocusNode.dispose();
    super.dispose();
  }

  void _confirmClose() async {
    final content = _bodyController.text.trim();
    if (!_hasChanges || content.isEmpty) {
      Navigator.pop(context);
      return;
    }
    final action = await showDialog<String>(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('unsaved_changes')),
        content: Text(tr('save_changes_question')),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, 'discard'), child: Text(tr('discard'))),
          FilledButton(onPressed: () => Navigator.pop(ctx, 'save'), child: Text(tr('save'))),
        ],
      ),
    );
    if (!mounted) return;
    if (action == 'save') {
      _save();
    } else if (action == 'discard') {
      Navigator.pop(context);
    }
  }

  void _save() {
    final content = _bodyController.text.trim();
    if (content.isEmpty) return;
    final note = FlashNote(
      content: content,
      createdAt: widget.existingNote?.createdAt ?? DateTime.now(),
      imageBase64: _attachedImageBase64 ?? widget.existingNote?.imageBase64,
      imagePath: _attachedImagePath ?? widget.existingNote?.imagePath,
    );
    widget.onSave(note);
    Navigator.pop(context);
  }

  void _handleListContinuation() {
    final text = _bodyController.text;
    final sel = _bodyController.selection;
    if (!sel.isValid || !sel.isCollapsed) { _prevText = text; return; }
    final pos = sel.baseOffset;
    if (text.length != _prevText.length + 1 || pos < 1 || text[pos - 1] != '\n') {
      _prevText = text;
      return;
    }
    final beforeNewline = text.substring(0, pos - 1);
    final lastNewline = beforeNewline.lastIndexOf('\n');
    final prevLine = beforeNewline.substring(lastNewline + 1);
    final stripped = prevLine.trim();
    if (stripped == '•' || stripped == '☐' || RegExp(r'^\d+\.\s*$').hasMatch(stripped)) {
      final removeFrom = lastNewline + 1;
      final newText = text.substring(0, removeFrom) + text.substring(pos);
      _bodyController.text = newText;
      _bodyController.selection = TextSelection.collapsed(offset: removeFrom);
      _prevText = _bodyController.text;
      return;
    }
    if (prevLine.startsWith('• ')) {
      final insert = '• ';
      final newText = text.substring(0, pos) + insert + text.substring(pos);
      _bodyController.text = newText;
      _bodyController.selection = TextSelection.collapsed(offset: pos + insert.length);
      _prevText = _bodyController.text;
      return;
    }
    if (prevLine.startsWith('☐ ') || prevLine.startsWith('☑ ')) {
      final insert = '☐ ';
      final newText = text.substring(0, pos) + insert + text.substring(pos);
      _bodyController.text = newText;
      _bodyController.selection = TextSelection.collapsed(offset: pos + insert.length);
      _prevText = _bodyController.text;
      return;
    }
    final numMatch = RegExp(r'^(\d+)\.\s').firstMatch(prevLine);
    if (numMatch != null) {
      final lines = beforeNewline.substring(0, lastNewline < 0 ? 0 : lastNewline).split('\n');
      int count = 1;
      for (final l in lines.reversed) {
        if (RegExp(r'^\d+\.\s').hasMatch(l)) { count++; } else { break; }
      }
      final nextNum = count + 1;
      final insert = '$nextNum. ';
      final newText = text.substring(0, pos) + insert + text.substring(pos);
      _bodyController.text = newText;
      _bodyController.selection = TextSelection.collapsed(offset: pos + insert.length);
      _prevText = _bodyController.text;
      return;
    }
    _prevText = text;
  }

  Widget _flashFormatBtn({required IconData icon, required String label, required Color accentColor, required VoidCallback onTap}) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(8),
          color: accentColor.withValues(alpha: 0.08),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 16, color: accentColor),
            const SizedBox(width: 4),
            Text(label, style: TextStyle(fontSize: 11, color: accentColor, fontWeight: FontWeight.w500)),
          ],
        ),
      ),
    );
  }

  Future<void> _pickImage() async {
    try {
      final picker = ImagePicker();
      final XFile? image = await picker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1200,
        maxHeight: 1200,
        imageQuality: 80,
      );
      if (image != null) {
        final bytes = await image.readAsBytes();
        if (!mounted) return;
        final imgHelper = ImageStorageHelper();
        final fileName = imgHelper.generateFileName('flash');
        final filePath = await imgHelper.saveBytesToFile(bytes, fileName);
        if (!mounted) return;
        setState(() {
          _attachedImagePath = filePath;
          _attachedImageBase64 = null;
        });
        _tryPhotoRecognition(filePath);
      }
    } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
  }

  Future<void> _tryPhotoRecognition(String imagePath) async {
    final auraSettings = await EthosAuraSettings.load();
    final settings = await FlashNotesSettings.load();
    if (!auraSettings.photoRecognitionPurchased) return; // non acquistato — silenzioso
    if (!settings.geminiEnabled || settings.geminiApiKey.isEmpty) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('gemini_not_configured')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
      return;
    }
    if (!mounted) return;

    // Read file for Gemini
    final file = File(imagePath);
    if (!await file.exists()) return;
    final bytes = await file.readAsBytes();
    final base64Image = base64Encode(bytes);

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white)),
            const SizedBox(width: 12),
            Text(tr('analyzing_photo')),
          ],
        ),
        duration: const Duration(seconds: 60),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );

    final (result, error) = await classifyPhotoWithGemini(base64Image, settings.geminiApiKey);
    if (!mounted) return;
    ScaffoldMessenger.of(context).hideCurrentSnackBar();

    if (result == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(_friendlyGeminiError(error, tr('photo_recognition_failed'))),
          duration: const Duration(seconds: 5),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
      return;
    }
    if (!result.isActionable) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('photo_normal')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
      return;
    }
    if (!mounted) return;

    final action = await showDialog<String>(
      context: context,
      builder: (ctx) {
        final colorScheme = Theme.of(ctx).colorScheme;
        return AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          actionsOverflowButtonSpacing: 8,
          title: Row(
            children: [
              Icon(result.folderIcon, color: result.folderColor),
              const SizedBox(width: 8),
              Expanded(child: Text(tr('photo_recognized'), style: const TextStyle(fontSize: 18))),
            ],
          ),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Chip(
                  avatar: Icon(result.folderIcon, size: 16, color: result.folderColor),
                  label: Text(result.categoryLabel, style: const TextStyle(fontSize: 12)),
                  backgroundColor: result.folderColor.withValues(alpha: 0.1),
                  side: BorderSide.none,
                ),
                if (result.title.isNotEmpty) ...[
                  const SizedBox(height: 8),
                  Text(result.title, style: const TextStyle(fontWeight: FontWeight.w600)),
                ],
                if (result.fields.isNotEmpty) ...[
                  const SizedBox(height: 12),
                  ...result.fields.entries.map((e) {
                    final label = e.key.replaceAll('_', ' ');
                    final capitalLabel = label[0].toUpperCase() + label.substring(1);
                    return Padding(
                      padding: const EdgeInsets.symmetric(vertical: 2),
                      child: Text('$capitalLabel: ${e.value}', style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant)),
                    );
                  }),
                ],
                if (result.extractedText.isNotEmpty && result.fields.isEmpty) ...[
                  const SizedBox(height: 8),
                  Text(result.extractedText, style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant)),
                ],
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(ctx),
              child: Text(tr('keep_as_flash')),
            ),
            if (result.category == 'business_card')
              OutlinedButton.icon(
                onPressed: () => Navigator.pop(ctx, 'contact'),
                icon: const Icon(Icons.person_add, size: 18),
                label: Text(tr('save_to_contacts')),
              ),
            FilledButton.icon(
              onPressed: () => Navigator.pop(ctx, 'deep_note'),
              icon: const Icon(Icons.note_add, size: 18),
              label: Text(tr('save_to_deep_note')),
              style: FilledButton.styleFrom(backgroundColor: result.folderColor),
            ),
          ],
        );
      },
    );

    if (action == 'contact' && mounted) {
      showContactFormSheet(context, result);
    } else if (action == 'deep_note' && mounted) {
      try {
        await ensurePhotoFolder(result.folderName, result.folderIcon, result.folderColor);
        final content = formatRecognitionAsDeepNote(result);
        // Copy image file for Deep Note
        final imgHelper = ImageStorageHelper();
        final proBytes = await File(imagePath).readAsBytes();
        final proFileName = imgHelper.generateFileName('pro');
        final proImagePath = await imgHelper.saveBytesToFile(proBytes, proFileName);
        final proNote = ProNote(
          title: result.title.isNotEmpty ? result.title : result.categoryLabel,
          content: content,
          folder: result.folderName,
          imagePath: proImagePath,
        );
        await DatabaseHelper().insertProNote(proNote);
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Row(
              children: [
                Icon(result.folderIcon, color: Colors.white, size: 18),
                const SizedBox(width: 8),
                Expanded(child: Text('${tr('saved_to_deep_note')} → ${result.folderName}')),
              ],
            ),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('${tr('error')}: $e'),
              behavior: SnackBarBehavior.floating,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
            ),
          );
        }
      }
    }
  }

  String _formatDurationMs(int ms) {
    final s = ms ~/ 1000;
    final m = s ~/ 60;
    final sec = s % 60;
    return '${m.toString().padLeft(2, '0')}:${sec.toString().padLeft(2, '0')}';
  }

  TextSpan _buildLinkifiedSpan(String text, TextStyle baseStyle, Color linkColor) {
    // Dispose old recognizers before creating new ones
    for (final r in _recognizers) { r.dispose(); }
    _recognizers.clear();

    final colorScheme = Theme.of(context).colorScheme;
    final matches = _tokenRegex.allMatches(text).toList();
    if (matches.isEmpty) return TextSpan(text: text, style: baseStyle);
    final spans = <InlineSpan>[];
    int lastEnd = 0;
    for (final match in matches) {
      if (match.start > lastEnd) {
        spans.add(TextSpan(text: text.substring(lastEnd, match.start), style: baseStyle));
      }
      final token = match.group(0)!;
      if (token == '☐' || token == '☑') {
        final isChecked = token == '☑';
        final checkboxSize = (baseStyle.fontSize ?? 16) * 1.4;
        final recognizer = TapGestureRecognizer()..onTap = () {
            _checkboxJustTapped = true;
            final newChar = isChecked ? '☐' : '☑';
            final newText = text.substring(0, match.start) + newChar + text.substring(match.end);
            _bodyController.text = newText;
            _hasChanges = true;
            setState(() {});
            // Auto-save toggled checkbox
            final content = _bodyController.text.trim();
            if (content.isNotEmpty) {
              final note = FlashNote(
                content: content,
                createdAt: widget.existingNote?.createdAt ?? DateTime.now(),
                imageBase64: _attachedImageBase64 ?? widget.existingNote?.imageBase64,
              );
              widget.onSave(note);
            }
          };
        _recognizers.add(recognizer);
        spans.add(TextSpan(
          text: token,
          style: baseStyle.copyWith(
            fontSize: checkboxSize,
            color: isChecked ? linkColor : colorScheme.onSurfaceVariant,
          ),
          recognizer: recognizer,
        ));
      } else {
        final recognizer = TapGestureRecognizer()..onTap = () => launchUrl(Uri.parse(token), mode: LaunchMode.externalApplication);
        _recognizers.add(recognizer);
        spans.add(TextSpan(
          text: token,
          style: baseStyle.copyWith(color: linkColor, decoration: TextDecoration.underline, decorationColor: linkColor),
          recognizer: recognizer,
        ));
      }
      lastEnd = match.end;
    }
    if (lastEnd < text.length) {
      spans.add(TextSpan(text: text.substring(lastEnd), style: baseStyle));
    }
    return TextSpan(children: spans);
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final accentColor = _sectionAccent(context, 2);

    return PopScope(
      canPop: true,
      child: Scaffold(
        resizeToAvoidBottomInset: true,
        backgroundColor: colorScheme.surface,
        appBar: AppBar(
          elevation: 0,
          scrolledUnderElevation: 2,
          backgroundColor: Colors.transparent,
          leading: IconButton(
            icon: Icon(Icons.arrow_back, color: colorScheme.onSurface),
            onPressed: () => _confirmClose(),
          ),
          title: Text(
            widget.existingNote != null ? 'Flash Note' : tr('new_flash_note'),
            style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500, color: colorScheme.onSurface),
          ),
          actions: [
            if (_hasChanges)
              TextButton.icon(
                onPressed: _save,
                icon: Icon(Icons.check, size: 18, color: accentColor),
                label: Text(tr('save'), style: TextStyle(color: accentColor)),
              ),
            PopupMenuButton<String>(
              icon: Icon(Icons.more_vert, color: colorScheme.onSurfaceVariant),
              onSelected: (value) {
                if (value == 'share') {
                  final content = _bodyController.text.trim();
                  if (content.isNotEmpty) {
                    SharePlus.instance.share(ShareParams(text: content, subject: 'Flash Note'));
                  }
                } else if (value == 'evolvi') {
                  // Save first, then open in Deep Note
                  if (_hasChanges) _save();
                }
              },
              itemBuilder: (context) => [
                PopupMenuItem(
                  value: 'share',
                  child: Row(
                    children: [
                      Icon(Icons.share, size: 18, color: colorScheme.onSurfaceVariant),
                      const SizedBox(width: 12),
                      Text(tr('share')),
                    ],
                  ),
                ),
                PopupMenuItem(
                  value: 'evolvi',
                  child: Row(
                    children: [
                      Icon(Icons.auto_awesome, size: 18, color: colorScheme.primary),
                      const SizedBox(width: 12),
                      Text(tr('open_in_deep_note')),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
        body: Stack(
          children: [
            if (_themeOverlayColor(context) != null)
              Positioned.fill(
                child: Container(color: _themeOverlayColor(context)),
              ),
            GestureDetector(
          onTap: () {
            if (_checkboxJustTapped) {
              _checkboxJustTapped = false;
              return;
            }
            if (!_isEditing) {
              setState(() => _isEditing = true);
              _bodyFocusNode.requestFocus();
            }
          },
          behavior: HitTestBehavior.translucent,
          child: SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(24, 16, 24, 72),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Date display
                if (widget.existingNote != null)
                  Padding(
                    padding: const EdgeInsets.only(bottom: 16),
                    child: Text(
                      _formatDate(widget.existingNote!.createdAt),
                      style: TextStyle(
                        fontSize: 13,
                        color: colorScheme.onSurfaceVariant.withValues(alpha: 0.6),
                      ),
                    ),
                  ),
                // Audio player (for audio notes opened as text editor)
                if (widget.existingNote?.audioPath != null && widget.existingNote!.audioPath!.isNotEmpty) ...[
                  Container(
                    padding: const EdgeInsets.fromLTRB(12, 10, 16, 6),
                    decoration: BoxDecoration(
                      color: accentColor.withValues(alpha: 0.08),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(color: accentColor.withValues(alpha: 0.2)),
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Row(
                          children: [
                            GestureDetector(
                              onTap: () async {
                                if (_isPlayingAudio) {
                                  await _editorAudioPlayer?.pause();
                                  if (mounted) setState(() => _isPlayingAudio = false);
                                } else {
                                  if (_editorAudioPlayer == null) {
                                    _editorAudioPlayer = ap.AudioPlayer();
                                    _editorAudioPlayer!.onPlayerComplete.listen((_) {
                                      if (mounted) setState(() { _isPlayingAudio = false; _editorAudioPosition = Duration.zero; });
                                    });
                                    _editorAudioPlayer!.onPositionChanged.listen((p) {
                                      if (mounted) setState(() => _editorAudioPosition = p);
                                    });
                                    _editorAudioPlayer!.onDurationChanged.listen((d) {
                                      if (mounted) setState(() => _editorAudioDuration = d);
                                    });
                                  }
                                  if (_editorAudioPosition > Duration.zero) {
                                    await _editorAudioPlayer!.resume();
                                  } else {
                                    await _editorAudioPlayer!.play(ap.DeviceFileSource(widget.existingNote!.audioPath!));
                                  }
                                  if (mounted) setState(() => _isPlayingAudio = true);
                                }
                              },
                              child: SizedBox(
                                width: 44,
                                height: 44,
                                child: Stack(
                                  alignment: Alignment.center,
                                  children: [
                                    SizedBox(
                                      width: 44,
                                      height: 44,
                                      child: CircularProgressIndicator(
                                        value: _editorAudioDuration.inMilliseconds > 0
                                            ? (_editorAudioPosition.inMilliseconds / _editorAudioDuration.inMilliseconds).clamp(0.0, 1.0)
                                            : 0.0,
                                        strokeWidth: 2.5,
                                        color: accentColor,
                                        backgroundColor: accentColor.withValues(alpha: 0.15),
                                      ),
                                    ),
                                    Container(
                                      width: 36,
                                      height: 36,
                                      decoration: BoxDecoration(
                                        color: _isPlayingAudio ? accentColor : accentColor.withValues(alpha: 0.15),
                                        shape: BoxShape.circle,
                                      ),
                                      child: Icon(
                                        _isPlayingAudio ? Icons.pause_rounded : Icons.play_arrow_rounded,
                                        color: _isPlayingAudio ? Colors.white : accentColor,
                                        size: 22,
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    '${_formatDurationMs(_editorAudioPosition.inMilliseconds)} / ${_formatDurationMs(_editorAudioDuration.inMilliseconds > 0 ? _editorAudioDuration.inMilliseconds : (widget.existingNote!.audioDurationMs ?? 0))}',
                                    style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600, color: accentColor),
                                  ),
                                  const SizedBox(height: 4),
                                  SizedBox(
                                    height: 16,
                                    child: SliderTheme(
                                      data: SliderThemeData(
                                        trackHeight: 3,
                                        thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 5),
                                        activeTrackColor: accentColor,
                                        inactiveTrackColor: accentColor.withValues(alpha: 0.2),
                                        thumbColor: accentColor,
                                        overlayShape: SliderComponentShape.noOverlay,
                                      ),
                                      child: Slider(
                                        value: _editorAudioDuration.inMilliseconds > 0
                                            ? (_editorAudioPosition.inMilliseconds / _editorAudioDuration.inMilliseconds).clamp(0.0, 1.0)
                                            : 0.0,
                                        onChanged: (v) async {
                                          if (_editorAudioDuration.inMilliseconds > 0) {
                                            final newPos = Duration(milliseconds: (v * _editorAudioDuration.inMilliseconds).toInt());
                                            await _editorAudioPlayer?.seek(newPos);
                                            if (mounted) setState(() => _editorAudioPosition = newPos);
                                          }
                                        },
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],
                // Attached image preview
                if (_attachedImagePath != null || _attachedImageBase64 != null) ...[
                  Stack(
                    alignment: Alignment.topRight,
                    children: [
                      StoredImage(
                        imagePath: _attachedImagePath,
                        imageBase64: _attachedImageBase64,
                        height: _imageExpanded ? null : 160,
                        width: double.infinity,
                        fit: _imageExpanded ? BoxFit.contain : BoxFit.cover,
                        borderRadius: BorderRadius.circular(12),
                      ),
                      Padding(
                        padding: const EdgeInsets.all(4),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            CircleAvatar(
                              radius: 14,
                              backgroundColor: Colors.black54,
                              child: IconButton(
                                icon: Icon(
                                  _imageExpanded ? Icons.close_fullscreen : Icons.open_in_full,
                                  size: 14, color: Colors.white,
                                ),
                                padding: EdgeInsets.zero,
                                onPressed: () => setState(() => _imageExpanded = !_imageExpanded),
                              ),
                            ),
                            const SizedBox(width: 4),
                            CircleAvatar(
                              radius: 14,
                              backgroundColor: Colors.black54,
                              child: IconButton(
                                icon: const Icon(Icons.close, size: 14, color: Colors.white),
                                padding: EdgeInsets.zero,
                                onPressed: () => setState(() { _attachedImageBase64 = null; _attachedImagePath = null; }),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 16),
                ],
                // Body field — infinite page
                ConstrainedBox(
                  constraints: BoxConstraints(
                    minHeight: MediaQuery.of(context).size.height * 0.6,
                  ),
                  child: _isEditing
                      ? TextField(
                          controller: _bodyController,
                          focusNode: _bodyFocusNode,
                          autofocus: widget.existingNote == null,
                          style: TextStyle(
                            fontSize: 16,
                            color: colorScheme.onSurface,
                            height: 1.6,
                          ),
                          decoration: InputDecoration(
                            hintText: tr('type_message'),
                            hintStyle: TextStyle(
                              fontSize: 16,
                              color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                            ),
                            border: InputBorder.none,
                            enabledBorder: InputBorder.none,
                            focusedBorder: InputBorder.none,
                            contentPadding: EdgeInsets.zero,
                            isDense: true,
                            filled: false,
                          ),
                          maxLines: null,
                          textCapitalization: TextCapitalization.sentences,
                          keyboardType: TextInputType.multiline,
                          contextMenuBuilder: (context, editableTextState) {
                            return AdaptiveTextSelectionToolbar.buttonItems(
                              anchors: editableTextState.contextMenuAnchors,
                              buttonItems: <ContextMenuButtonItem>[
                                ContextMenuButtonItem(label: tr('cut'), onPressed: () => editableTextState.cutSelection(SelectionChangedCause.toolbar)),
                                ContextMenuButtonItem(label: tr('copy'), onPressed: () => editableTextState.copySelection(SelectionChangedCause.toolbar)),
                                ContextMenuButtonItem(label: tr('paste'), onPressed: () => editableTextState.pasteText(SelectionChangedCause.toolbar)),
                                ContextMenuButtonItem(label: tr('select_all'), onPressed: () => editableTextState.selectAll(SelectionChangedCause.toolbar)),
                              ],
                            );
                          },
                        )
                      : Text.rich(
                          _buildLinkifiedSpan(
                            _bodyController.text,
                            TextStyle(fontSize: 16, color: colorScheme.onSurface, height: 1.6),
                            colorScheme.primary,
                          ),
                        ),
                ),
              ],
            ),
          ),
        ),
          // Toolbar pinned above keyboard
          Positioned(
            left: 0,
            right: 0,
            bottom: 0,
            child: Container(
              padding: EdgeInsets.fromLTRB(16, 8, 16, 8 + (MediaQuery.of(context).viewInsets.bottom > 0 ? 0 : MediaQuery.of(context).viewPadding.bottom)),
              decoration: BoxDecoration(
                color: colorScheme.surface,
                border: Border(top: BorderSide(color: colorScheme.outlineVariant.withValues(alpha: 0.3))),
              ),
              child: Row(
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        children: [
                          _flashFormatBtn(
                            icon: Icons.format_list_bulleted,
                            label: tr('bullet_list'),
                            accentColor: accentColor,
                            onTap: () {
                              final sel = _bodyController.selection;
                              final pos = sel.isValid ? sel.baseOffset : _bodyController.text.length;
                              final before = _bodyController.text.substring(0, pos);
                              final after = _bodyController.text.substring(pos);
                              final needsNewline = before.isNotEmpty && !before.endsWith('\n');
                              final prefix = '${needsNewline ? '\n' : ''}• ';
                              _bodyController.text = '$before$prefix$after';
                              _bodyController.selection = TextSelection.collapsed(offset: pos + prefix.length);
                            },
                          ),
                          const SizedBox(width: 8),
                          _flashFormatBtn(
                        icon: Icons.format_list_numbered,
                        label: tr('numbered_list'),
                        accentColor: accentColor,
                        onTap: () {
                          final text = _bodyController.text;
                          final sel = _bodyController.selection;
                          final pos = sel.isValid ? sel.baseOffset : text.length;
                          final before = text.substring(0, pos);
                          final lines = before.split('\n');
                          int num = 1;
                          for (final l in lines.reversed) {
                            if (l.trim().isEmpty) break;
                            if (RegExp(r'^\d+\.\s').hasMatch(l)) { num++; } else { break; }
                          }
                          final after = text.substring(pos);
                          final needsNewline = before.isNotEmpty && !before.endsWith('\n');
                          final prefix = '${needsNewline ? '\n' : ''}$num. ';
                          _bodyController.text = '$before$prefix$after';
                          _bodyController.selection = TextSelection.collapsed(offset: pos + prefix.length);
                        },
                      ),
                      const SizedBox(width: 8),
                      _flashFormatBtn(
                        icon: Icons.checklist,
                        label: tr('checklist'),
                        accentColor: accentColor,
                        onTap: () {
                          final sel = _bodyController.selection;
                          final pos = sel.isValid ? sel.baseOffset : _bodyController.text.length;
                          final before = _bodyController.text.substring(0, pos);
                          final after = _bodyController.text.substring(pos);
                          final needsNewline = before.isNotEmpty && !before.endsWith('\n');
                          final prefix = '${needsNewline ? '\n' : ''}☐ ';
                          _bodyController.text = '$before$prefix$after';
                          _bodyController.selection = TextSelection.collapsed(offset: pos + prefix.length);
                        },
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(width: 8),
              IconButton(
                onPressed: _pickImage,
                icon: Icon(Icons.camera_alt, size: 20, color: accentColor),
                tooltip: tr('attach_photo'),
                style: IconButton.styleFrom(
                  backgroundColor: accentColor.withValues(alpha: 0.1),
                ),
              ),
                ],
              ),
            ),
          ),
          ],
        ),
      ),
    );
  }

  String _formatDate(DateTime dt) {
    const months = ['', 'gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
      'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
    final hour = dt.hour.toString().padLeft(2, '0');
    final minute = dt.minute.toString().padLeft(2, '0');
    return '${dt.day} ${months[dt.month]} ${dt.year}, $hour:$minute';
  }
}

class FlashNotesPage extends StatefulWidget {
  final String? initialMode; // 'text', 'photo', 'voice'
  const FlashNotesPage({super.key, this.initialMode});

  @override
  State<FlashNotesPage> createState() => _FlashNotesPageState();
}

class _FlashNotesPageState extends State<FlashNotesPage> {
  final _HighlightingTextEditingController _controller = _HighlightingTextEditingController();
  final TextEditingController _searchController = TextEditingController();
  List<FlashNote> _notes = [];
  String _searchQuery = '';
  bool _isGridView = false;
  String _groupingMode = 'monthly';
  String? _selectedGroup; // null = "Tutte"
  bool _showGroupSidebar = false;
  // Sort mode
  String _sortMode = 'newest';
  // Selection mode
  bool _selectionMode = false;
  Set<int> _selectedNoteIds = {};
  // Audio playback
  ap.AudioPlayer? _audioPlayer;
  StreamSubscription? _playerSubscription;
  StreamSubscription? _positionSub;
  StreamSubscription? _durationSub;
  int? _playingNoteIndex;
  Duration _audioPosition = Duration.zero;
  Duration _audioDuration = Duration.zero;
  // AI availability
  bool _isAiAvailable = false;
  // Guard: prevents double-opening audio sheet
  bool _isAudioSheetOpen = false;
  // Photo recognition pulse animation
  bool _isAnalyzingPhoto = false;
  // Direct camera launch from widget — shows black screen while camera opens
  bool _launchingCamera = false;
  // Note style: 'modern' or 'paper' (gated by Ethos Aura)
  String _noteStyle = 'modern';
  bool _paperStickyPurchased = false;

  @override
  void initState() {
    super.initState();
    _loadNotes();
    _loadViewMode();
    _loadSortMode();
    _loadGroupingMode();
    _loadAiAvailability();
    // Handle deep link initial mode from widget
    if (widget.initialMode != null) {
      if (widget.initialMode == 'photo') _launchingCamera = true;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        switch (widget.initialMode) {
          case 'photo':
            _addPhotoNote(directCamera: true);
            break;
          case 'voice':
            _showAudioSheet();
            break;
          case 'text':
            _showWriteSheet();
            break;
        }
      });
    }
  }

  @override
  void dispose() {
    _playerSubscription?.cancel();
    _positionSub?.cancel();
    _durationSub?.cancel();
    _audioPlayer?.dispose();
    _controller.dispose();
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadViewMode() async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() => _isGridView = prefs.getBool('flash_view_mode_grid') ?? false);
  }

  Future<void> _toggleViewMode() async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() => _isGridView = !_isGridView);
    await prefs.setBool('flash_view_mode_grid', _isGridView);
  }

  Future<void> _loadSortMode() async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() => _sortMode = prefs.getString('flash_sort_mode') ?? 'newest');
  }

  Future<void> _saveSortMode(String mode) async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() => _sortMode = mode);
    await prefs.setString('flash_sort_mode', mode);
  }

  Future<void> _loadGroupingMode() async {
    final settings = await FlashNotesSettings.load();
    final aura = await EthosAuraSettings.load();
    if (!mounted) return;
    setState(() {
      _groupingMode = settings.groupingMode;
      _noteStyle = settings.noteStyle;
      _paperStickyPurchased = aura.paperStickyPurchased;
    });
  }

  Future<void> _loadAiAvailability() async {
    final settings = await FlashNotesSettings.load();
    if (mounted) {
      setState(() => _isAiAvailable = settings.geminiEnabled && settings.geminiApiKey.isNotEmpty);
    }
  }

  static const _months = ['', 'Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu',
    'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];

  String _getGroupKey(DateTime dt) {
    switch (_groupingMode) {
      case 'daily':
        return '${dt.day}/${dt.month}/${dt.year}';
      case 'weekly':
        // Start of week (Monday)
        final monday = dt.subtract(Duration(days: dt.weekday - 1));
        return '${monday.day}/${monday.month}/${monday.year}';
      case 'yearly':
        return '${dt.year}';
      case 'monthly':
      default:
        return '${_months[dt.month]} ${dt.year}';
    }
  }

  String _getGroupLabel(String key) {
    switch (_groupingMode) {
      case 'daily':
        // Extract just dd/mm from dd/mm/yyyy
        final parts = key.split('/');
        return parts.length >= 2 ? '${parts[0]}/${parts[1]}' : key;
      case 'weekly':
        return 'Sett. $key';
      case 'yearly':
        return key;
      case 'monthly':
      default:
        return key;
    }
  }

  IconData _getGroupIcon() {
    return Icons.flash_on;
  }

  Map<String, List<FlashNote>> _getGroupedNotes(List<FlashNote> notes) {
    final groups = <String, List<FlashNote>>{};
    for (final note in notes) {
      final key = _getGroupKey(note.createdAt);
      groups.putIfAbsent(key, () => []).add(note);
    }
    return groups;
  }

  Future<void> _loadNotes() async {
    final notes = await DatabaseHelper().getAllFlashNotes();
    if (!mounted) return;
    setState(() {
      _notes = notes;
    });
  }

  Future<void> _saveNotes() async {
    await DatabaseHelper().replaceAllFlashNotes(_notes);
  }

  Future<void> _toggleFlashNotePin(FlashNote note) async {
    if (note.id == null) return;
    final updated = note.copyWith(isPinned: !note.isPinned);
    await DatabaseHelper().updateFlashNote(note.id!, updated);
    _loadNotes();
  }

  Future<void> _addPhotoNote({bool directCamera = false}) async {
    final accentColor = _sectionAccent(context, 2);
    ImageSource? source;
    if (directCamera) {
      source = ImageSource.camera;
    } else {
      source = await showModalBottomSheet<ImageSource>(
        context: context,
        shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
        builder: (ctx) => SafeArea(
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(width: 40, height: 4, decoration: BoxDecoration(color: Theme.of(ctx).colorScheme.onSurfaceVariant.withValues(alpha: 0.3), borderRadius: BorderRadius.circular(2))),
                const SizedBox(height: 20),
                Text(tr('photo'), style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                const SizedBox(height: 16),
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: () => Navigator.pop(ctx, ImageSource.gallery),
                        icon: const Icon(Icons.photo_library),
                        label: Text(tr('gallery')),
                        style: OutlinedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: FilledButton.icon(
                        onPressed: () => Navigator.pop(ctx, ImageSource.camera),
                        icon: const Icon(Icons.camera_alt),
                        label: Text(tr('camera')),
                        style: FilledButton.styleFrom(
                          backgroundColor: accentColor,
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      );
      if (source == null) return;
    }

    try {
      final picker = ImagePicker();
      final XFile? image = await picker.pickImage(
        source: source,
        preferredCameraDevice: CameraDevice.rear,
        maxWidth: 1200,
        maxHeight: 1200,
        imageQuality: 80,
      );
      if (_launchingCamera && mounted) {
        setState(() => _launchingCamera = false);
      }
      if (image == null) return;
      final bytes = await image.readAsBytes();

      // Save to file
      final imgHelper = ImageStorageHelper();
      final fileName = imgHelper.generateFileName('flash');
      final filePath = await imgHelper.saveBytesToFile(bytes, fileName);

      // Show caption sheet
      if (!mounted) return;
      final captionCtrl = TextEditingController();
      final saved = await showModalBottomSheet<bool>(
        context: context,
        isScrollControlled: true,
        shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
        builder: (ctx) => Padding(
          padding: EdgeInsets.only(
            left: 20, right: 20, top: 20,
            bottom: MediaQuery.of(ctx).viewInsets.bottom + 20,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(width: 40, height: 4, decoration: BoxDecoration(color: Theme.of(ctx).colorScheme.onSurfaceVariant.withValues(alpha: 0.3), borderRadius: BorderRadius.circular(2))),
              const SizedBox(height: 16),
              ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: Image.memory(bytes, height: 180, width: double.infinity, fit: BoxFit.cover),
              ),
              const SizedBox(height: 12),
              TextField(
                controller: captionCtrl,
                maxLines: 2,
                autofocus: true,
                decoration: InputDecoration(
                  hintText: tr('add_caption'),
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                ),
              ),
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: FilledButton.icon(
                  onPressed: () => Navigator.pop(ctx, true),
                  icon: const Icon(Icons.check, size: 18),
                  label: Text(tr('save')),
                  style: FilledButton.styleFrom(
                    backgroundColor: accentColor,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  ),
                ),
              ),
            ],
          ),
        ),
      );

      if (saved == true && mounted) {
        final caption = captionCtrl.text.isNotEmpty ? captionCtrl.text : '📷 ${tr('photo')}';
        final note = FlashNote(content: caption, imagePath: filePath);
        await DatabaseHelper().insertFlashNote(note);
        if (mounted) await _loadNotes();
        // Run photo recognition in background if enabled
        if (mounted) _runPhotoRecognition(filePath);
      } else {
        // User cancelled, delete the file
        await imgHelper.deleteImageFile(filePath);
      }
      captionCtrl.dispose();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${tr('error')}: $e'),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  Future<void> _runPhotoRecognition(String imagePath) async {
    final auraSettings = await EthosAuraSettings.load();
    final settings = await FlashNotesSettings.load();
    if (!auraSettings.photoRecognitionPurchased) return;
    if (!settings.geminiEnabled || settings.geminiApiKey.isEmpty) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('gemini_not_configured')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
      return;
    }
    if (!mounted) return;

    // Read file for Gemini
    final file = File(imagePath);
    if (!await file.exists()) return;
    final bytes = await file.readAsBytes();
    if (!mounted) return;
    final base64Image = base64Encode(bytes);

    setState(() => _isAnalyzingPhoto = true);

    final (result, error) = await classifyPhotoWithGemini(base64Image, settings.geminiApiKey);
    if (!mounted) return;
    setState(() => _isAnalyzingPhoto = false);

    if (result == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(_friendlyGeminiError(error, tr('photo_recognition_failed'))),
          duration: const Duration(seconds: 5),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
      return;
    }
    if (!result.isActionable) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('photo_normal')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
      return;
    }
    if (!mounted) return;
    _showPhotoRecognitionDialog(result, imagePath);
  }

  void _showPhotoRecognitionDialog(PhotoRecognitionResult result, String imagePath) {
    final colorScheme = Theme.of(context).colorScheme;

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (ctx) => DraggableScrollableSheet(
        initialChildSize: 0.65,
        minChildSize: 0.4,
        maxChildSize: 0.9,
        expand: false,
        builder: (ctx, scrollController) => Padding(
          padding: const EdgeInsets.all(20),
          child: ListView(
            controller: scrollController,
            children: [
              // Handle
              Center(child: Container(width: 40, height: 4, decoration: BoxDecoration(color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3), borderRadius: BorderRadius.circular(2)))),
              const SizedBox(height: 16),
              // Title
              Text(tr('photo_recognized'), style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
              const SizedBox(height: 16),
              // Image preview
              StoredImage(
                imagePath: imagePath,
                height: 180,
                width: double.infinity,
                fit: BoxFit.cover,
                borderRadius: BorderRadius.circular(12),
              ),
              const SizedBox(height: 16),
              // Category chip
              Row(
                children: [
                  Text('${tr('category_detected')}: ', style: TextStyle(color: colorScheme.onSurfaceVariant)),
                  Chip(
                    avatar: Icon(result.folderIcon, size: 18, color: result.folderColor),
                    label: Text(result.categoryLabel),
                    backgroundColor: result.folderColor.withValues(alpha: 0.1),
                    side: BorderSide.none,
                  ),
                ],
              ),
              const SizedBox(height: 12),
              // Title
              if (result.title.isNotEmpty) ...[
                Text(result.title, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600)),
                const SizedBox(height: 8),
              ],
              // Extracted data
              if (result.fields.isNotEmpty) ...[
                Text(tr('extracted_data'), style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600, color: colorScheme.onSurfaceVariant)),
                const SizedBox(height: 8),
                Card(
                  elevation: 0,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  color: colorScheme.surfaceContainerLowest,
                  child: Padding(
                    padding: const EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: result.fields.entries.map((e) {
                        final label = e.key.replaceAll('_', ' ');
                        final capitalLabel = label[0].toUpperCase() + label.substring(1);
                        return Padding(
                          padding: const EdgeInsets.symmetric(vertical: 3),
                          child: Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              SizedBox(width: 110, child: Text('$capitalLabel:', style: TextStyle(fontWeight: FontWeight.w600, fontSize: 13, color: colorScheme.onSurfaceVariant))),
                              Expanded(child: Text(e.value, style: const TextStyle(fontSize: 13))),
                            ],
                          ),
                        );
                      }).toList(),
                    ),
                  ),
                ),
                const SizedBox(height: 8),
              ],
              // Extracted text
              if (result.extractedText.isNotEmpty && result.fields.isEmpty) ...[
                Card(
                  elevation: 0,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  color: colorScheme.surfaceContainerLowest,
                  child: Padding(
                    padding: const EdgeInsets.all(12),
                    child: Text(result.extractedText, style: const TextStyle(fontSize: 13)),
                  ),
                ),
                const SizedBox(height: 8),
              ],
              const SizedBox(height: 16),
              // Buttons
              if (result.category == 'business_card') ...[
                SizedBox(
                  width: double.infinity,
                  child: FilledButton.icon(
                    onPressed: () {
                      Navigator.pop(ctx);
                      showContactFormSheet(context, result);
                    },
                    icon: const Icon(Icons.person_add, size: 18),
                    label: Text(tr('save_to_contacts')),
                    style: FilledButton.styleFrom(
                      backgroundColor: const Color(0xFF1565C0),
                      padding: const EdgeInsets.symmetric(vertical: 14),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                  ),
                ),
                const SizedBox(height: 10),
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: () => Navigator.pop(ctx),
                        icon: const Icon(Icons.flash_on, size: 18),
                        label: Text(tr('keep_as_flash'), style: const TextStyle(fontSize: 12)),
                        style: OutlinedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 14),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: () async {
                          Navigator.pop(ctx);
                          await _saveAsDeepNote(result, imagePath);
                        },
                        icon: const Icon(Icons.note_add, size: 18),
                        label: Text(tr('save_to_deep_note'), style: const TextStyle(fontSize: 12)),
                        style: OutlinedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 14),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        ),
                      ),
                    ),
                  ],
                ),
              ] else
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: () => Navigator.pop(ctx),
                        icon: const Icon(Icons.flash_on, size: 18),
                        label: Text(tr('keep_as_flash'), style: const TextStyle(fontSize: 12)),
                        style: OutlinedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 14),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: FilledButton.icon(
                        onPressed: () async {
                          Navigator.pop(ctx);
                          await _saveAsDeepNote(result, imagePath);
                        },
                        icon: const Icon(Icons.note_add, size: 18),
                        label: Text(tr('save_to_deep_note'), style: const TextStyle(fontSize: 12)),
                        style: FilledButton.styleFrom(
                          backgroundColor: result.folderColor,
                          padding: const EdgeInsets.symmetric(vertical: 14),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        ),
                      ),
                    ),
                  ],
                ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _saveAsDeepNote(PhotoRecognitionResult result, String imagePath) async {
    try {
      await ensurePhotoFolder(result.folderName, result.folderIcon, result.folderColor);
      final content = formatRecognitionAsDeepNote(result);
      // Copy image file for Deep Note (separate from flash note's copy)
      final imgHelper = ImageStorageHelper();
      final bytes = await File(imagePath).readAsBytes();
      final fileName = imgHelper.generateFileName('pro');
      final proImagePath = await imgHelper.saveBytesToFile(bytes, fileName);
      final proNote = ProNote(
        title: result.title.isNotEmpty ? result.title : result.categoryLabel,
        content: content,
        folder: result.folderName,
        imagePath: proImagePath,
      );
      await DatabaseHelper().insertProNote(proNote);
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              Icon(result.folderIcon, color: Colors.white, size: 18),
              const SizedBox(width: 8),
              Expanded(child: Text('${tr('saved_to_deep_note')} → ${result.folderName}')),
            ],
          ),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${tr('error')}: $e'),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  Future<void> _createEventFromFlashNote(FlashNote note) async {
    final parsed = parseFlashNote(note.content);
    final titleCtrl = TextEditingController(text: parsed.title);
    DateTime startDate = parsed.startDate;
    DateTime endDate = parsed.endDate;
    bool isAllDay = parsed.isAllDay;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) {
        return StatefulBuilder(builder: (ctx, setDialogState) {
          return AlertDialog(
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
            title: Text(tr('create_event')),
            content: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextField(
                    controller: titleCtrl,
                    decoration: InputDecoration(labelText: tr('title')),
                  ),
                  const SizedBox(height: 16),
                  ListTile(
                    contentPadding: EdgeInsets.zero,
                    title: Text(tr('start_time')),
                    subtitle: Text('${startDate.day}/${startDate.month}/${startDate.year}'),
                    trailing: const Icon(Icons.calendar_today),
                    onTap: () async {
                      final picked = await showDatePicker(
                        context: ctx,
                        initialDate: startDate,
                        firstDate: DateTime(2020),
                        lastDate: DateTime(2100),
                      );
                      if (picked != null) {
                        setDialogState(() {
                          startDate = DateTime(picked.year, picked.month, picked.day, startDate.hour, startDate.minute);
                          if (endDate.isBefore(startDate)) {
                            endDate = DateTime(picked.year, picked.month, picked.day, endDate.hour, endDate.minute);
                          }
                        });
                      }
                    },
                  ),
                  ListTile(
                    contentPadding: EdgeInsets.zero,
                    title: Text(tr('end_time')),
                    subtitle: Text('${endDate.day}/${endDate.month}/${endDate.year}'),
                    trailing: const Icon(Icons.calendar_today),
                    onTap: () async {
                      final picked = await showDatePicker(
                        context: ctx,
                        initialDate: endDate.isBefore(startDate) ? startDate : endDate,
                        firstDate: startDate,
                        lastDate: DateTime(2100),
                      );
                      if (picked != null) {
                        setDialogState(() {
                          endDate = DateTime(picked.year, picked.month, picked.day, endDate.hour, endDate.minute);
                        });
                      }
                    },
                  ),
                  SwitchListTile(
                    contentPadding: EdgeInsets.zero,
                    title: Text(tr('today')),
                    value: isAllDay,
                    onChanged: (v) => setDialogState(() {
                      isAllDay = v;
                      if (v) {
                        startDate = DateTime(startDate.year, startDate.month, startDate.day, 0, 0);
                        endDate = DateTime(endDate.year, endDate.month, endDate.day, 23, 59);
                      }
                    }),
                  ),
                  if (!isAllDay) ...[
                    ListTile(
                      contentPadding: EdgeInsets.zero,
                      title: Text(tr('start_time')),
                      subtitle: Text('${startDate.hour.toString().padLeft(2, '0')}:${startDate.minute.toString().padLeft(2, '0')}'),
                      trailing: const Icon(Icons.access_time),
                      onTap: () async {
                        final picked = await showTimePicker(
                          context: ctx,
                          initialTime: TimeOfDay.fromDateTime(startDate),
                        );
                        if (picked != null) {
                          setDialogState(() {
                            startDate = DateTime(startDate.year, startDate.month, startDate.day, picked.hour, picked.minute);
                          });
                        }
                      },
                    ),
                    ListTile(
                      contentPadding: EdgeInsets.zero,
                      title: Text(tr('end_time')),
                      subtitle: Text('${endDate.hour.toString().padLeft(2, '0')}:${endDate.minute.toString().padLeft(2, '0')}'),
                      trailing: const Icon(Icons.access_time),
                      onTap: () async {
                        final picked = await showTimePicker(
                          context: ctx,
                          initialTime: TimeOfDay.fromDateTime(endDate),
                        );
                        if (picked != null) {
                          setDialogState(() {
                            endDate = DateTime(endDate.year, endDate.month, endDate.day, picked.hour, picked.minute);
                          });
                        }
                      },
                    ),
                  ],
                ],
              ),
            ),
            actions: [
              TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
              FilledButton(onPressed: () => Navigator.pop(ctx, true), child: Text(tr('create'))),
            ],
          );
        });
      },
    );

    if (confirmed == true && mounted) {
      final eventTitle = titleCtrl.text.trim().isEmpty ? note.content : titleCtrl.text.trim();
      final event = CalendarEventFull(
        title: eventTitle,
        startTime: startDate,
        endTime: endDate,
        calendar: tr('personal'),
      );
      try {
        await DatabaseHelper().insertEvent(event);

        // Sync to Google Calendar if connected
        if (GoogleCalendarService.isSignedIn) {
          GoogleCalendarService.pushEvent(event);
        }

        if (mounted) {
          final dateStr = '${startDate.day}/${startDate.month}/${startDate.year}';
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('"$eventTitle" ${tr('event_added_on')} $dateStr'),
              behavior: SnackBarBehavior.floating,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              action: SnackBarAction(
                label: tr('view'),
                onPressed: () {
                  final homeState = context.findAncestorStateOfType<_HomePageState>();
                  if (homeState != null) {
                    homeState.setState(() {
                      homeState._selectedIndex = 1;
                      homeState._refreshKey++;
                    });
                  }
                },
              ),
            ),
          );
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(tr('error')),
              behavior: SnackBarBehavior.floating,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
            ),
          );
        }
      }
    }
    titleCtrl.dispose();
  }

  Future<void> _deleteNote(int index) async {
    final note = _notes[index];
    final db = DatabaseHelper();
    // Move to trash if enabled
    final settings = await NoteProSettings.load();
    int? trashedId;
    if (settings.trashEnabled) {
      final trashed = TrashedNote(
        type: 'flash',
        noteJson: note.toJson(),
        deletedAt: DateTime.now(),
      );
      trashedId = await db.insertTrashedNote(trashed);
    } else {
      // No trash — delete image file immediately
      await ImageStorageHelper().deleteImageFile(note.imagePath);
    }
    if (note.id != null) {
      await db.deleteFlashNote(note.id!);
    }
    await _loadNotes();
    if (!mounted) return;
    ScaffoldMessenger.of(context).clearSnackBars();
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text(tr('note_deleted')),
      action: SnackBarAction(
        label: tr('undo'),
        onPressed: () async {
          await db.insertFlashNote(note);
          if (trashedId != null) {
            await db.deleteTrashedNote(trashedId);
          }
          _loadNotes();
        },
      ),
      behavior: SnackBarBehavior.floating,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    ));
  }

  void _shareSelectedNotes() {
    final selectedContents = _notes
        .where((n) => n.id != null && _selectedNoteIds.contains(n.id))
        .map((n) => n.content)
        .toList();
    if (selectedContents.isEmpty) return;
    final text = selectedContents.join('\n\n---\n\n');
    SharePlus.instance.share(ShareParams(text: text, subject: 'Flash Notes'));
  }

  void _deleteSelectedNotes() {
    final count = _selectedNoteIds.length;
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('confirm_delete')),
        content: Text('${tr('delete_selected_confirm')} ($count ${tr('notes')})?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () async {
              Navigator.pop(ctx);
              final db = DatabaseHelper();
              final settings = await NoteProSettings.load();
              final deletedNotes = <FlashNote>[];
              final trashedIds = <int>[];
              for (final noteId in _selectedNoteIds) {
                final idx = _notes.indexWhere((n) => n.id == noteId);
                if (idx == -1) continue;
                final note = _notes[idx];
                deletedNotes.add(note);
                if (settings.trashEnabled) {
                  final trashed = TrashedNote(type: 'flash', noteJson: note.toJson(), deletedAt: DateTime.now());
                  final tid = await db.insertTrashedNote(trashed);
                  trashedIds.add(tid);
                } else {
                  await ImageStorageHelper().deleteImageFile(note.imagePath);
                }
                await db.deleteFlashNote(noteId);
              }
              final deletedCount = deletedNotes.length;
              if (!mounted) return;
              setState(() {
                _selectionMode = false;
                _selectedNoteIds.clear();
              });
              await _loadNotes();
              if (!mounted) return;
              ScaffoldMessenger.of(context).clearSnackBars();
              ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                content: Text('${tr('notes_deleted')} ($deletedCount)'),
                action: SnackBarAction(
                  label: tr('undo'),
                  onPressed: () async {
                    for (final note in deletedNotes) {
                      await db.insertFlashNote(note);
                    }
                    for (final tid in trashedIds) {
                      await db.deleteTrashedNote(tid);
                    }
                    _loadNotes();
                  },
                ),
                behavior: SnackBarBehavior.floating,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              ));
            },
            style: FilledButton.styleFrom(backgroundColor: Theme.of(context).colorScheme.error),
            child: Text(tr('delete')),
          ),
        ],
      ),
    );
  }

  Future<void> _moveSelectedToDeepNote() async {
    // Load folders
    Map<String, FolderStyle> folders = {
      'Generale': const FolderStyle(Icons.folder, Colors.blue),
      tr('work'): const FolderStyle(Icons.work, Colors.orange),
      tr('personal'): const FolderStyle(Icons.person, Colors.green),
      'Flash Notes': const FolderStyle(Icons.flash_on, Color(0xFFFFA726)),
      tr('private_folder'): const FolderStyle(Icons.lock, Color(0xFF7B1FA2)),
    };
    final customFolders = await DatabaseHelper().getAllFolders();
    folders.addAll(customFolders);
    if (!mounted) return;

    String selectedFolder = 'Generale';
    final chosen = await showDialog<String>(
      context: context,
      builder: (ctx) => StatefulBuilder(
        builder: (ctx, setDialogState) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('move_to_deep_note')),
          content: SizedBox(
            width: double.maxFinite,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: folders.length,
              itemBuilder: (ctx, i) {
                final name = folders.keys.elementAt(i);
                final style = folders[name]!;
                return RadioListTile<String>(
                  value: name,
                  groupValue: selectedFolder,
                  onChanged: (v) => setDialogState(() => selectedFolder = v!),
                  title: Text(name),
                  secondary: style.buildIcon(size: 22),
                  dense: true,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                );
              },
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
            FilledButton(
              onPressed: () => Navigator.pop(ctx, selectedFolder),
              child: Text(tr('move')),
            ),
          ],
        ),
      ),
    );
    if (chosen == null || !mounted) return;

    int count = 0;
    for (final noteId in _selectedNoteIds) {
      final idx = _notes.indexWhere((n) => n.id == noteId);
      if (idx == -1) continue;
      final note = _notes[idx];
      final title = note.content.length > 40 ? note.content.substring(0, 40) : note.content;
      final proNote = ProNote(
        title: title,
        content: note.content,
        createdAt: note.createdAt,
        folder: chosen,
        imageBase64: note.imageBase64,
        imagePath: note.imagePath,
      );
      await DatabaseHelper().insertProNote(proNote);
      await DatabaseHelper().deleteFlashNote(noteId);
      count++;
    }
    if (!mounted) return;
    setState(() {
      _selectionMode = false;
      _selectedNoteIds.clear();
    });
    await _loadNotes();
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('$count ${tr('notes')} spostate in "$chosen"'),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );
  }

  void _showDeleteConfirmation(int index) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('confirm_delete')),
        content: Text(tr('delete_flash_confirm')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(tr('cancel')),
          ),
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              _deleteNote(index);
            },
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
            child: Text(tr('delete')),
          ),
        ],
      ),
    );
  }

  void _showDeleteGroupDialog(String label, List<FlashNote> groupNotes) {
    final colorScheme = Theme.of(context).colorScheme;
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('confirm_delete')),
        content: Text('${tr('delete_group_confirm')} "$label"? (${groupNotes.length} ${tr('notes')})'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () async {
              Navigator.pop(ctx);
              final db = DatabaseHelper();
              final settings = await NoteProSettings.load();
              final deletedNotes = <FlashNote>[];
              final trashedIds = <int>[];
              for (final note in groupNotes) {
                deletedNotes.add(note);
                if (settings.trashEnabled) {
                  final trashed = TrashedNote(type: 'flash', noteJson: note.toJson(), deletedAt: DateTime.now());
                  final tid = await db.insertTrashedNote(trashed);
                  trashedIds.add(tid);
                }
                if (note.id != null) {
                  await db.deleteFlashNote(note.id!);
                }
              }
              final deletedCount = deletedNotes.length;
              if (!mounted) return;
              setState(() {
                _selectedGroup = null;
                _showGroupSidebar = false;
              });
              await _loadNotes();
              if (!mounted) return;
              ScaffoldMessenger.of(context).clearSnackBars();
              ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                content: Text('${tr('notes_deleted')} ($deletedCount)'),
                action: SnackBarAction(
                  label: tr('undo'),
                  onPressed: () async {
                    for (final note in deletedNotes) {
                      await db.insertFlashNote(note);
                    }
                    for (final tid in trashedIds) {
                      await db.deleteTrashedNote(tid);
                    }
                    _loadNotes();
                  },
                ),
                behavior: SnackBarBehavior.floating,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              ));
            },
            style: FilledButton.styleFrom(backgroundColor: colorScheme.error),
            child: Text(tr('delete')),
          ),
        ],
      ),
    );
  }

  void _showAIOptions(FlashNote note, int index) {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (ctx) {
        final colorScheme = Theme.of(ctx).colorScheme;
        return Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 40, height: 4,
                decoration: BoxDecoration(
                  color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(height: 16),
              Text('Gemini AI', style: Theme.of(ctx).textTheme.titleLarge),
              const SizedBox(height: 16),
              if (note.isAudioNote) ...[
                ListTile(
                  leading: const Icon(Icons.record_voice_over, color: Colors.purple),
                  title: Text(tr('transcribe_voice_note')),
                  subtitle: Text(tr('convert_audio_to_text')),
                  onTap: () {
                    Navigator.pop(ctx);
                    _transcribeAudioNote(note, index);
                  },
                ),
                ListTile(
                  leading: const Icon(Icons.summarize, color: Colors.purple),
                  title: Text(tr('summarize')),
                  subtitle: Text(tr('create_brief_content_summary')),
                  onTap: () {
                    Navigator.pop(ctx);
                    _callFlashGeminiAI(note, index, 'riassumi');
                  },
                ),
              ] else ...[
                ListTile(
                  leading: const Icon(Icons.auto_awesome, color: Colors.purple),
                  title: Text(tr('smart_summary')),
                  subtitle: Text(tr('create_brief_summary')),
                  onTap: () {
                    Navigator.pop(ctx);
                    _callFlashGeminiAI(note, index, 'riassumi');
                  },
                ),
              ],
              const SizedBox(height: 8),
            ],
          ),
        );
      },
    );
  }

  Future<void> _callFlashGeminiAI(FlashNote note, int index, String action) async {
    final settings = await FlashNotesSettings.load();
    final apiKey = settings.geminiApiKey;
    if (apiKey.isEmpty) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('api_key')),
          behavior: SnackBarBehavior.floating,
        ),
      );
      return;
    }

    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2)),
            const SizedBox(width: 12),
            Text(tr('loading')),
          ],
        ),
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 10),
      ),
    );

    try {
      final text = note.content;
      if (text.isEmpty) return;

      final String prompt;
      final String title;
      switch (action) {
        case 'riassumi':
          prompt = 'Crea un breve riassunto in italiano del seguente testo:\n\n$text';
          title = tr('ai_summary');
          break;
        case 'correggi':
          // Use custom instructions if formattingPreset is 'custom'
          if (settings.formattingPreset == 'custom' && settings.customFormatInstructions.isNotEmpty) {
            prompt = 'Applica le seguenti istruzioni al testo: ${settings.customFormatInstructions}\n\nTesto:\n$text';
          } else {
            // Dynamic prompt based on aiCorrectionLevel
            final level = settings.aiCorrectionLevel;
            final String correctionInstruction;
            if (level <= 0.0) {
              correctionInstruction = 'Correggi solo gli errori ortografici nel seguente testo, senza modificare nient\'altro';
            } else if (level <= 0.25) {
              correctionInstruction = 'Correggi errori ortografici e di punteggiatura nel seguente testo';
            } else if (level <= 0.5) {
              correctionInstruction = 'Correggi errori e migliora leggermente la leggibilità del seguente testo';
            } else if (level <= 0.75) {
              correctionInstruction = 'Riformula il seguente testo migliorando stile e chiarezza, mantenendo il significato';
            } else {
              correctionInstruction = 'Riscrivi completamente il seguente testo in modo professionale e chiaro';
            }
            prompt = '$correctionInstruction:\n\n$text';
          }
          title = tr('ai_correction');
          break;
        default:
          return;
      }

      final model = gemini.GenerativeModel(model: 'gemini-2.5-flash-lite', apiKey: apiKey);
      final response = await model.generateContent([gemini.Content.text(prompt)]);
      final result = response.text ?? tr('no_results');

      if (!mounted) return;
      ScaffoldMessenger.of(context).hideCurrentSnackBar();

      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
        ),
        builder: (ctx) {
          final colorScheme = Theme.of(ctx).colorScheme;
          return DraggableScrollableSheet(
            initialChildSize: 0.5,
            minChildSize: 0.3,
            maxChildSize: 0.85,
            expand: false,
            builder: (_, scrollController) => Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Center(
                    child: Container(
                      width: 40, height: 4,
                      decoration: BoxDecoration(
                        color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                        borderRadius: BorderRadius.circular(2),
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Icon(Icons.psychology, color: Colors.purple),
                      const SizedBox(width: 8),
                      Text(title, style: Theme.of(ctx).textTheme.titleLarge),
                    ],
                  ),
                  const SizedBox(height: 16),
                  Expanded(
                    child: SingleChildScrollView(
                      controller: scrollController,
                      child: Card(
                        elevation: 0,
                        color: colorScheme.surfaceContainerLowest,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        child: Padding(
                          padding: const EdgeInsets.all(16),
                          child: SelectableText(result, style: const TextStyle(height: 1.6)),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  SizedBox(
                    width: double.infinity,
                    child: FilledButton.icon(
                      onPressed: () {
                        setState(() {
                          _notes[index] = FlashNote(
                            content: result,
                            createdAt: note.createdAt,
                          );
                        });
                        _saveNotes();
                        Navigator.pop(ctx);
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text(tr('success')),
                            behavior: SnackBarBehavior.floating,
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          ),
                        );
                      },
                      icon: const Icon(Icons.check),
                      label: Text(tr('apply')),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).hideCurrentSnackBar();
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('error')}: $e'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  Future<void> _transcribeAudioNote(FlashNote note, int index) async {
    final settings = await FlashNotesSettings.load();
    final apiKey = settings.geminiApiKey;
    if (apiKey.isEmpty) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(tr('api_key')), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      );
      return;
    }
    if (note.audioPath == null || note.audioPath!.isEmpty) return;

    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(children: [
          const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2)),
          const SizedBox(width: 12),
          Text(tr('transcription_in_progress')),
        ]),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        duration: const Duration(seconds: 30),
      ),
    );

    try {
      final audioBytes = await File(note.audioPath!).readAsBytes();
      if (audioBytes.length > 20 * 1024 * 1024) {
        if (mounted) {
          ScaffoldMessenger.of(context).hideCurrentSnackBar();
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(tr('file_too_large')), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
          );
        }
        return;
      }
      final mimeType = note.audioPath!.endsWith('.m4a') ? 'audio/mp4' : 'audio/mpeg';
      String result = '';
      for (int attempt = 0; attempt < 3; attempt++) {
        try {
          final model = gemini.GenerativeModel(model: 'gemini-2.5-flash-lite', apiKey: apiKey);
          final response = await model.generateContent([
            gemini.Content.multi([
              gemini.DataPart(mimeType, audioBytes),
              gemini.TextPart('Trascrivi questo audio in italiano. Restituisci solo il testo trascritto, senza commenti.'),
            ]),
          ]).timeout(const Duration(seconds: 60));
          result = response.text ?? '';
          break;
        } catch (e) {
          if (e.toString().contains('503') && attempt < 2) {
            await Future.delayed(Duration(seconds: 3 * (attempt + 1)));
            continue;
          }
          rethrow;
        }
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context).hideCurrentSnackBar();

      if (result.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(tr('no_text_recognized')), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
        );
        return;
      }

      final titleController = TextEditingController();
      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
        builder: (ctx) {
          final colorScheme = Theme.of(ctx).colorScheme;
          return DraggableScrollableSheet(
            initialChildSize: 0.5,
            minChildSize: 0.3,
            maxChildSize: 0.85,
            expand: false,
            builder: (_, scrollController) => Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Center(child: Container(width: 40, height: 4, decoration: BoxDecoration(color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3), borderRadius: BorderRadius.circular(2)))),
                  const SizedBox(height: 16),
                  Row(children: [
                    const Icon(Icons.record_voice_over, color: Colors.purple),
                    const SizedBox(width: 8),
                    Text('Trascrizione audio', style: Theme.of(ctx).textTheme.titleLarge),
                  ]),
                  const SizedBox(height: 12),
                  TextField(
                    controller: titleController,
                    decoration: InputDecoration(
                      hintText: tr('optional_title'),
                      border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                      contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                      isDense: true,
                    ),
                    textCapitalization: TextCapitalization.sentences,
                  ),
                  const SizedBox(height: 12),
                  Expanded(
                    child: SingleChildScrollView(
                      controller: scrollController,
                      child: Card(
                        elevation: 0,
                        color: colorScheme.surfaceContainerLowest,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        child: Padding(
                          padding: const EdgeInsets.all(16),
                          child: SelectableText(result, style: const TextStyle(height: 1.6)),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  SizedBox(
                    width: double.infinity,
                    child: FilledButton.icon(
                      onPressed: () {
                        final title = titleController.text.trim();
                        final finalContent = title.isNotEmpty ? '$title\n\n$result' : result;
                        setState(() {
                          _notes[index] = FlashNote(
                            content: finalContent,
                            createdAt: note.createdAt,
                            audioPath: note.audioPath,
                            audioDurationMs: note.audioDurationMs,
                          );
                        });
                        _saveNotes();
                        Navigator.pop(ctx);
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(content: Text(tr('success')), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
                        );
                      },
                      icon: const Icon(Icons.check),
                      label: Text(tr('apply_transcription')),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).hideCurrentSnackBar();
      final errMsg = e.toString();
      final userMsg = errMsg.contains('503')
          ? tr('server_busy')
          : errMsg.contains('quota') || errMsg.contains('429')
              ? tr('quota_exceeded')
              : '${tr('error')}: $errMsg';
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(userMsg), duration: const Duration(seconds: 5), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      );
    }
  }

  void _openFlashNote(FlashNote note, int originalIndex) {
    if (note.isAudioNote) {
      _showAudioNoteViewer(note, originalIndex);
      return;
    }
    final heroTag = 'flash_note_${note.createdAt.millisecondsSinceEpoch}';
    Navigator.push(
      context,
      _buildExpandRoute(
        FlashNoteEditorPage(
          existingNote: note,
          heroTag: heroTag,
          onSave: (updatedNote) {
            setState(() {
              _notes[originalIndex] = updatedNote;
            });
            _saveNotes();
          },
        ),
      ),
    );
  }

  void _showAudioNoteViewer(FlashNote note, int originalIndex) {
    final colorScheme = Theme.of(context).colorScheme;
    final accentColor = _sectionAccent(context, 2);
    ap.AudioPlayer? viewerPlayer;
    bool isPlaying = false;
    Duration position = Duration.zero;
    Duration duration = Duration(milliseconds: note.audioDurationMs ?? 0);
    String transcription = note.content.startsWith('🎤') ? '' : note.content;
    bool isTranscribing = false;

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (ctx) => StatefulBuilder(
        builder: (ctx, setSheetState) {
          return Padding(
            padding: EdgeInsets.only(left: 24, right: 24, top: 16, bottom: MediaQuery.of(ctx).viewInsets.bottom + 24),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Center(child: Container(width: 40, height: 4, decoration: BoxDecoration(color: colorScheme.outlineVariant, borderRadius: BorderRadius.circular(2)))),
                const SizedBox(height: 20),
                // Title
                Row(
                  children: [
                    Icon(Icons.mic, color: accentColor),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        note.content.startsWith('🎤') ? tr('voice_note') : note.content,
                        style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: colorScheme.onSurface),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    const Spacer(),
                    Text(
                      _formatDateTime(note.createdAt),
                      style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                // Player
                GestureDetector(
                  onTap: () async {
                    if (isPlaying) {
                      await viewerPlayer?.pause();
                      setSheetState(() => isPlaying = false);
                    } else {
                      if (viewerPlayer == null) {
                        viewerPlayer = ap.AudioPlayer();
                        viewerPlayer!.onPositionChanged.listen((p) {
                          setSheetState(() => position = p);
                        });
                        viewerPlayer!.onDurationChanged.listen((d) {
                          setSheetState(() => duration = d);
                        });
                        viewerPlayer!.onPlayerComplete.listen((_) {
                          setSheetState(() { isPlaying = false; position = Duration.zero; });
                        });
                      }
                      try {
                        if (position > Duration.zero) {
                          await viewerPlayer!.resume();
                        } else {
                          if (kIsWeb) {
                            await viewerPlayer!.play(ap.UrlSource(note.audioPath!));
                          } else {
                            await viewerPlayer!.play(ap.DeviceFileSource(note.audioPath!));
                          }
                        }
                        setSheetState(() => isPlaying = true);
                      } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
                    }
                  },
                  child: Container(
                    width: 72, height: 72,
                    decoration: BoxDecoration(
                      color: isPlaying ? accentColor : accentColor.withValues(alpha: 0.12),
                      shape: BoxShape.circle,
                      boxShadow: isPlaying
                          ? [BoxShadow(color: accentColor.withValues(alpha: 0.3), blurRadius: 16, offset: const Offset(0, 4))]
                          : null,
                    ),
                    child: Icon(
                      isPlaying ? Icons.pause_rounded : Icons.play_arrow_rounded,
                      color: isPlaying ? Colors.white : accentColor,
                      size: 36,
                    ),
                  ),
                ),
                const SizedBox(height: 12),
                // Progress bar
                SliderTheme(
                  data: SliderThemeData(
                    trackHeight: 4,
                    thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 6),
                    activeTrackColor: accentColor,
                    inactiveTrackColor: colorScheme.outlineVariant.withValues(alpha: 0.3),
                    thumbColor: accentColor,
                    overlayShape: SliderComponentShape.noOverlay,
                  ),
                  child: Slider(
                    value: duration.inMilliseconds > 0
                        ? (position.inMilliseconds / duration.inMilliseconds).clamp(0.0, 1.0)
                        : 0.0,
                    onChanged: (v) async {
                      final newPos = Duration(milliseconds: (v * duration.inMilliseconds).toInt());
                      await viewerPlayer?.seek(newPos);
                      setSheetState(() => position = newPos);
                    },
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 4),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(_formatAudioDuration(position.inSeconds), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                      Text(_formatAudioDuration(duration.inSeconds), style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
                // Transcription section
                if (transcription.isNotEmpty) ...[
                  ConstrainedBox(
                    constraints: const BoxConstraints(maxHeight: 160),
                    child: Container(
                      width: double.infinity,
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(tr('transcription'), style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600, color: colorScheme.onSurfaceVariant)),
                          const SizedBox(height: 4),
                          Flexible(
                            child: SingleChildScrollView(
                              child: SelectableText(transcription, style: TextStyle(fontSize: 14, color: colorScheme.onSurface)),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 8),
                  SizedBox(
                    width: double.infinity,
                    child: OutlinedButton.icon(
                      onPressed: () {
                        // Save transcription to note first
                        setState(() {
                          _notes[originalIndex] = FlashNote(
                            content: transcription,
                            createdAt: note.createdAt,
                            audioPath: note.audioPath,
                            audioDurationMs: note.audioDurationMs,
                          );
                        });
                        _saveNotes();
                        viewerPlayer?.stop();
                        viewerPlayer?.dispose();
                        Navigator.pop(ctx);
                        // Open as text editor
                        final updatedNote = _notes[originalIndex];
                        Navigator.push(context, MaterialPageRoute(
                          builder: (_) => FlashNoteEditorPage(
                            existingNote: updatedNote,
                            onSave: (edited) {
                              setState(() {
                                _notes[originalIndex] = FlashNote(
                                  content: edited.content,
                                  createdAt: edited.createdAt,
                                  audioPath: note.audioPath,
                                  audioDurationMs: note.audioDurationMs,
                                );
                              });
                              _saveNotes();
                            },
                          ),
                        ));
                      },
                      icon: const Icon(Icons.edit_note, size: 18),
                      label: Text(tr('open_as_text_note')),
                      style: OutlinedButton.styleFrom(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
                    ),
                  ),
                ],
                const SizedBox(height: 16),
                // Action buttons
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: isTranscribing ? null : () async {
                          final settings = await FlashNotesSettings.load();
                          if (settings.geminiApiKey.isEmpty) {
                            ScaffoldMessenger.of(ctx).showSnackBar(
                              SnackBar(
                                content: Text(tr('configure_gemini_first')),
                                behavior: SnackBarBehavior.floating,
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                              ),
                            );
                            return;
                          }
                          setSheetState(() => isTranscribing = true);
                          try {
                            final model = gemini.GenerativeModel(model: 'gemini-2.5-flash-lite', apiKey: settings.geminiApiKey);
                            final audioBytes = await File(note.audioPath!).readAsBytes();
                            final mimeType = note.audioPath!.endsWith('.m4a') ? 'audio/mp4' : 'audio/mpeg';
                            final response = await model.generateContent([
                              gemini.Content.multi([
                                gemini.DataPart(mimeType, audioBytes),
                                gemini.TextPart('Trascrivi questo audio in italiano. Restituisci solo il testo trascritto, senza commenti.'),
                              ]),
                            ]).timeout(const Duration(seconds: 60));
                            setSheetState(() {
                              transcription = response.text ?? '';
                              isTranscribing = false;
                            });
                          } catch (e) {
                            setSheetState(() => isTranscribing = false);
                            if (ctx.mounted) {
                              ScaffoldMessenger.of(ctx).showSnackBar(
                                SnackBar(content: Text('${tr('error')}: $e'), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
                              );
                            }
                          }
                        },
                        icon: isTranscribing ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)) : const Icon(Icons.text_fields, size: 18),
                        label: Text(tr('transcribe')),
                        style: OutlinedButton.styleFrom(shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
                      ),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      onPressed: () {
                        viewerPlayer?.stop();
                        viewerPlayer?.dispose();
                        Navigator.pop(ctx);
                        _showDeleteConfirmation(originalIndex);
                      },
                      icon: Icon(Icons.delete_outline, color: colorScheme.error),
                    ),
                  ],
                ),
              ],
            ),
          );
        },
      ),
    ).then((_) {
      viewerPlayer?.stop();
      viewerPlayer?.dispose();
    });
  }

  Route _buildExpandRoute(Widget page) {
    return PageRouteBuilder(
      transitionDuration: const Duration(milliseconds: 400),
      reverseTransitionDuration: const Duration(milliseconds: 300),
      pageBuilder: (context, animation, secondaryAnimation) => page,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        final curved = CurvedAnimation(parent: animation, curve: Curves.easeOutCubic);
        return FadeTransition(
          opacity: curved,
          child: SlideTransition(
            position: Tween<Offset>(begin: const Offset(0, 0.08), end: Offset.zero).animate(curved),
            child: ScaleTransition(
              scale: Tween<double>(begin: 0.92, end: 1.0).animate(curved),
              child: child,
            ),
          ),
        );
      },
    );
  }

  Future<void> _openInNotePro(FlashNote flashNote) async {
    // Load folders
    Map<String, FolderStyle> folders = {
      'Generale': const FolderStyle(Icons.folder, Colors.blue),
      tr('work'): const FolderStyle(Icons.work, Colors.orange),
      tr('personal'): const FolderStyle(Icons.person, Colors.green),
      'Flash Notes': const FolderStyle(Icons.flash_on, Color(0xFFFFA726)),
      tr('private_folder'): const FolderStyle(Icons.lock, Color(0xFF7B1FA2)),
    };
    final customFolders = await DatabaseHelper().getAllFolders();
    folders.addAll(customFolders);
    // Create a ProNote from the flash note
    final title = flashNote.content.length > 40
        ? flashNote.content.substring(0, 40)
        : flashNote.content;
    final proNote = ProNote(
      title: title,
      content: flashNote.content,
      createdAt: flashNote.createdAt,
      folder: 'Flash Notes',
    );
    if (!mounted) return;
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => NoteReadPage(
          note: proNote,
          folders: folders,
          onSave: (savedNote) async {
            await DatabaseHelper().insertProNote(savedNote);
          },
        ),
      ),
    );
  }

  String _formatDateTime(DateTime dt) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final noteDay = DateTime(dt.year, dt.month, dt.day);
    final daysDiff = today.difference(noteDay).inDays;
    if (daysDiff == 0) {
      return '${tr('today')} ${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    }
    if (daysDiff == 1) {
      return '${tr('yesterday')} ${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    }
    if (daysDiff < 7) return '$daysDiff ${tr('days_ago')}';
    return '${dt.day}/${dt.month}/${dt.year}';
  }

  bool _isSameDay(DateTime a, DateTime b) => a.year == b.year && a.month == b.month && a.day == b.day;

  String _formatDayLabel(DateTime dt) {
    const months = ['', 'gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
      'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final noteDay = DateTime(dt.year, dt.month, dt.day);
    final daysDiff = today.difference(noteDay).inDays;
    if (daysDiff == 0) return tr('today');
    if (daysDiff == 1) return tr('yesterday');
    return '${dt.day} ${months[dt.month]} ${dt.year}';
  }

  @override
  Widget build(BuildContext context) {
    if (_launchingCamera) {
      return const Scaffold(backgroundColor: Colors.black);
    }
    var sortedNotes = List<FlashNote>.from(_notes);
    switch (_sortMode) {
      case 'oldest':
        sortedNotes.sort((a, b) => a.createdAt.compareTo(b.createdAt));
        break;
      case 'az':
        sortedNotes.sort((a, b) => a.content.toLowerCase().compareTo(b.content.toLowerCase()));
        break;
      case 'za':
        sortedNotes.sort((a, b) => b.content.toLowerCase().compareTo(a.content.toLowerCase()));
        break;
      case 'newest':
      default:
        sortedNotes.sort((a, b) => b.createdAt.compareTo(a.createdAt));
        break;
    }
    if (_searchQuery.isNotEmpty) {
      final q = _searchQuery.toLowerCase();
      sortedNotes = sortedNotes.where((n) => n.content.toLowerCase().contains(q)).toList();
    }
    // Filter by selected group
    if (_selectedGroup != null) {
      sortedNotes = sortedNotes.where((n) => _getGroupKey(n.createdAt) == _selectedGroup).toList();
    }
    // Stable sort: pinned notes first
    final pinned = sortedNotes.where((n) => n.isPinned).toList();
    final unpinned = sortedNotes.where((n) => !n.isPinned).toList();
    sortedNotes = [...pinned, ...unpinned];
    final colorScheme = Theme.of(context).colorScheme;
    final accentColor = _sectionAccent(context, 2);

    // Build group list for sidebar (from all notes, not filtered)
    final allSorted = List<FlashNote>.from(_notes)
      ..sort((a, b) => b.createdAt.compareTo(a.createdAt)); // newest first
    final groupedNotes = _getGroupedNotes(allSorted);
    final groupKeys = groupedNotes.keys.toList();

    return Stack(
      children: [
        // MAIN CONTENT (full width)
        Column(
          children: [
        // SELECTION MODE BAR
        if (_selectionMode)
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            color: accentColor.withValues(alpha: 0.08),
            child: Row(
              children: [
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => setState(() { _selectionMode = false; _selectedNoteIds.clear(); }),
                ),
                Text(
                  '${_selectedNoteIds.length} ${tr('selected')}',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600, color: accentColor),
                ),
                const Spacer(),
                TextButton(
                  onPressed: () {
                    setState(() {
                      if (_selectedNoteIds.length == sortedNotes.length) {
                        _selectedNoteIds.clear();
                      } else {
                        _selectedNoteIds = sortedNotes.where((n) => n.id != null).map((n) => n.id!).toSet();
                      }
                    });
                  },
                  child: Text(_selectedNoteIds.length == sortedNotes.length ? tr('deselect_all') : tr('select_all')),
                ),
                IconButton(
                  onPressed: _selectedNoteIds.isEmpty ? null : () => _deleteSelectedNotes(),
                  icon: Icon(Icons.delete_outline, color: _selectedNoteIds.isEmpty ? null : colorScheme.error),
                  tooltip: tr('delete'),
                ),
                PopupMenuButton<String>(
                  icon: const Icon(Icons.more_vert),
                  enabled: _selectedNoteIds.isNotEmpty,
                  onSelected: (v) {
                    if (v == 'share') _shareSelectedNotes();
                    if (v == 'move') _moveSelectedToDeepNote();
                  },
                  itemBuilder: (_) => [
                    PopupMenuItem(value: 'share', child: Row(children: [const Icon(Icons.share, size: 20), const SizedBox(width: 12), Text(tr('share'))])),
                    PopupMenuItem(value: 'move', child: Row(children: [const Icon(Icons.drive_file_move_rtl_outlined, size: 20), const SizedBox(width: 12), Text(tr('move_to_deep_note'))])),
                  ],
                ),
              ],
            ),
          ),
        // SEARCH BAR + VIEW TOGGLE
        if (!_selectionMode)
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 8, 16, 4),
          child: Row(
            children: [
              // Sidebar toggle button
              Padding(
                padding: const EdgeInsets.only(right: 8),
                child: FloatingActionButton.small(
                  heroTag: 'flash_group_fab',
                  elevation: _selectedGroup != null ? 2 : 1,
                  backgroundColor: _selectedGroup != null ? accentColor.withValues(alpha: 0.12) : colorScheme.surfaceContainerLowest,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  onPressed: () => setState(() => _showGroupSidebar = !_showGroupSidebar),
                  tooltip: tr('grouping_mode'),
                  child: Icon(
                    _selectedGroup != null ? _getGroupIcon() : Icons.apps,
                    size: 20,
                    color: _selectedGroup != null ? accentColor : colorScheme.onSurfaceVariant,
                  ),
                ),
              ),
              Expanded(
                child: TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: tr('search_flash_notes'),
                    prefixIcon: const Icon(Icons.search, size: 20),
                    suffixIcon: _searchQuery.isNotEmpty
                        ? IconButton(
                            icon: const Icon(Icons.clear, size: 18),
                            onPressed: () {
                              _searchController.clear();
                              setState(() => _searchQuery = '');
                            },
                          )
                        : null,
                    isDense: true,
                    contentPadding: const EdgeInsets.symmetric(vertical: 10),
                  ),
                  onChanged: (value) => setState(() => _searchQuery = value),
                ),
              ),
              PopupMenuButton<String>(
                icon: const Icon(Icons.sort, size: 22),
                tooltip: tr('sort'),
                onSelected: (mode) => _saveSortMode(mode),
                itemBuilder: (context) => [
                  PopupMenuItem(value: 'newest', child: Text(tr('newest_first'))),
                  PopupMenuItem(value: 'oldest', child: Text(tr('oldest_first'))),
                  PopupMenuItem(value: 'az', child: Text(tr('alphabetical_az'))),
                  PopupMenuItem(value: 'za', child: Text(tr('alphabetical_za'))),
                ],
              ),
              const SizedBox(width: 4),
              IconButton(
                icon: Icon(_isGridView ? Icons.view_list : Icons.grid_view, size: 22),
                tooltip: _isGridView ? tr('list_view_tooltip') : tr('grid_view_tooltip'),
                onPressed: _toggleViewMode,
              ),
            ],
          ),
        ),
        Expanded(
          child: sortedNotes.isEmpty
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.flash_on_outlined,
                        size: 64,
                        color: colorScheme.outlineVariant,
                      ),
                      const SizedBox(height: 12),
                      Text(
                        _searchQuery.isNotEmpty
                            ? '${tr('no_results_for')} "$_searchQuery"'
                            : tr('no_flash_notes'),
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                          color: colorScheme.onSurfaceVariant,
                        ),
                      ),
                      if (_searchQuery.isEmpty) ...[
                        const SizedBox(height: 4),
                        Text(
                          tr('write_first_quick_note'),
                          style: TextStyle(
                            fontSize: 13,
                            color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7),
                          ),
                        ),
                      ],
                    ],
                  ),
                )
              : _isGridView
                  ? GridView.builder(
                      padding: const EdgeInsets.all(12),
                      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                        crossAxisCount: MediaQuery.of(context).size.width > 840 ? 4 : MediaQuery.of(context).size.width > 600 ? 3 : 2,
                        crossAxisSpacing: 6,
                        mainAxisSpacing: 6,
                        childAspectRatio: 1.0,
                      ),
                      itemCount: sortedNotes.length,
                      itemBuilder: (context, index) {
                        final note = sortedNotes[index];
                        final originalIndex = _notes.indexOf(note);
                        final isSelected = note.id != null && _selectedNoteIds.contains(note.id);
                        return GestureDetector(
                          onTap: () {
                            if (_selectionMode) {
                              setState(() {
                                if (note.id != null) {
                                  if (_selectedNoteIds.contains(note.id)) {
                                    _selectedNoteIds.remove(note.id);
                                    if (_selectedNoteIds.isEmpty) _selectionMode = false;
                                  } else {
                                    _selectedNoteIds.add(note.id!);
                                  }
                                }
                              });
                            } else {
                              _openFlashNote(note, originalIndex);
                            }
                          },
                          onLongPress: () {
                            if (!_selectionMode) {
                              setState(() {
                                _selectionMode = true;
                                if (note.id != null) _selectedNoteIds.add(note.id!);
                              });
                            }
                          },
                          child: AnimatedContainer(
                            duration: const Duration(milliseconds: 200),
                            margin: const EdgeInsets.all(2),
                            decoration: isSelected
                              ? BoxDecoration(
                                  color: accentColor.withValues(alpha: 0.08),
                                  borderRadius: BorderRadius.circular(16),
                                  border: Border.all(color: accentColor, width: 2),
                                )
                              : ((_noteStyle == 'paper' && _paperStickyPurchased) || ((_isYellowNoteTheme(context) || _isBlockNoteTheme(context)) && _noteStyle == 'modern'))
                                ? _paperStickyDecoration(index)
                                : BoxDecoration(
                                    color: colorScheme.surfaceContainerLowest,
                                    borderRadius: BorderRadius.circular(16),
                                    border: Border.all(
                                      color: colorScheme.outlineVariant.withValues(alpha: 0.3),
                                      width: 1,
                                    ),
                                  ),
                            child: Stack(
                              children: [
                                if (!isSelected && ((_noteStyle == 'paper' && _paperStickyPurchased) || ((_isYellowNoteTheme(context) || _isBlockNoteTheme(context)) && _noteStyle == 'modern'))) ...[
                                  Positioned.fill(child: ClipRRect(
                                    borderRadius: const BorderRadius.only(topLeft: Radius.circular(2), topRight: Radius.circular(4), bottomLeft: Radius.circular(3), bottomRight: Radius.circular(1)),
                                    child: CustomPaint(painter: _PaperTexturePainter(seed: index)),
                                  )),
                                  Positioned.fill(child: ClipRRect(
                                    borderRadius: const BorderRadius.only(topLeft: Radius.circular(2), topRight: Radius.circular(4), bottomLeft: Radius.circular(3), bottomRight: Radius.circular(1)),
                                    child: CustomPaint(painter: _PaperMarginPainter(seed: index)),
                                  )),
                                  Positioned.fill(child: CustomPaint(painter: _CornerCurlPainter(baseColor: _paperStickyColors[index % _paperStickyColors.length]))),
                                ],
                                Padding(
                              padding: EdgeInsets.only(left: !isSelected && ((_noteStyle == 'paper' && _paperStickyPurchased) || ((_isYellowNoteTheme(context) || _isBlockNoteTheme(context)) && _noteStyle == 'modern')) ? 50 : 10, top: 10, right: 10, bottom: 10),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    children: [
                                      Icon(Icons.flash_on, color: accentColor, size: 14),
                                      const SizedBox(width: 4),
                                      Expanded(
                                        child: Text(
                                          _formatDateTime(note.createdAt),
                                          style: TextStyle(
                                            fontSize: 10,
                                            fontWeight: FontWeight.w500,
                                            color: colorScheme.onSurfaceVariant,
                                          ),
                                        ),
                                      ),
                                      if (note.isPinned)
                                        Icon(Icons.push_pin, size: 14, color: accentColor),
                                    ],
                                  ),
                                  const SizedBox(height: 6),
                                  Expanded(
                                    child: note.isAudioNote
                                      ? Center(
                                          child: Column(
                                            mainAxisAlignment: MainAxisAlignment.center,
                                            mainAxisSize: MainAxisSize.min,
                                            children: [
                                              GestureDetector(
                                                onTap: () => _playAudioNote(originalIndex, note.audioPath!),
                                                child: SizedBox(
                                                  width: 60,
                                                  height: 60,
                                                  child: Stack(
                                                    alignment: Alignment.center,
                                                    children: [
                                                      if (_playingNoteIndex == originalIndex)
                                                        SizedBox(
                                                          width: 60,
                                                          height: 60,
                                                          child: CircularProgressIndicator(
                                                            value: _audioDuration.inMilliseconds > 0
                                                                ? (_audioPosition.inMilliseconds / _audioDuration.inMilliseconds).clamp(0.0, 1.0)
                                                                : 0.0,
                                                            strokeWidth: 3,
                                                            color: accentColor,
                                                            backgroundColor: accentColor.withValues(alpha: 0.15),
                                                          ),
                                                        ),
                                                      Container(
                                                        width: 52,
                                                        height: 52,
                                                        decoration: BoxDecoration(
                                                          color: _playingNoteIndex == originalIndex
                                                              ? accentColor
                                                              : accentColor.withValues(alpha: 0.12),
                                                          shape: BoxShape.circle,
                                                        ),
                                                        child: Icon(
                                                          _playingNoteIndex == originalIndex ? Icons.stop_rounded : Icons.play_arrow_rounded,
                                                          color: _playingNoteIndex == originalIndex ? Colors.white : accentColor,
                                                          size: 28,
                                                        ),
                                                      ),
                                                    ],
                                                  ),
                                                ),
                                              ),
                                              const SizedBox(height: 4),
                                              Text(
                                                _playingNoteIndex == originalIndex
                                                    ? _formatAudioDuration(_audioPosition.inSeconds)
                                                    : _formatAudioDuration((note.audioDurationMs ?? 0) ~/ 1000),
                                                style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600, color: accentColor),
                                              ),
                                              if (_playingNoteIndex == originalIndex) ...[
                                                const SizedBox(height: 2),
                                                SizedBox(
                                                  width: 80,
                                                  height: 16,
                                                  child: SliderTheme(
                                                    data: SliderThemeData(
                                                      trackHeight: 2,
                                                      thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 4),
                                                      activeTrackColor: accentColor,
                                                      inactiveTrackColor: accentColor.withValues(alpha: 0.2),
                                                      thumbColor: accentColor,
                                                      overlayShape: SliderComponentShape.noOverlay,
                                                    ),
                                                    child: Slider(
                                                      value: _audioDuration.inMilliseconds > 0
                                                          ? (_audioPosition.inMilliseconds / _audioDuration.inMilliseconds).clamp(0.0, 1.0)
                                                          : 0.0,
                                                      onChanged: _seekAudio,
                                                    ),
                                                  ),
                                                ),
                                              ],
                                              if (note.content.isNotEmpty) ...[
                                                const SizedBox(height: 4),
                                                Padding(
                                                  padding: const EdgeInsets.symmetric(horizontal: 8),
                                                  child: Text(
                                                    note.content,
                                                    maxLines: 2,
                                                    overflow: TextOverflow.ellipsis,
                                                    textAlign: TextAlign.center,
                                                    style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant),
                                                  ),
                                                ),
                                              ],
                                            ],
                                          ),
                                        )
                                      : note.isPhotoNote
                                        ? StoredImage(
                                            imagePath: note.imagePath,
                                            imageBase64: note.imageBase64,
                                            fit: BoxFit.cover,
                                            width: double.infinity,
                                            height: double.infinity,
                                            borderRadius: BorderRadius.circular(8),
                                          )
                                        : Text(
                                            note.content,
                                            maxLines: 5,
                                            overflow: TextOverflow.ellipsis,
                                            style: TextStyle(
                                              fontSize: 12,
                                              height: 1.4,
                                              color: colorScheme.onSurface,
                                            ),
                                          ),
                                  ),
                                  const SizedBox(height: 4),
                                  Row(
                                    mainAxisAlignment: MainAxisAlignment.end,
                                    children: [
                                      _buildCellAction(
                                        note.isPinned ? Icons.push_pin : Icons.push_pin_outlined,
                                        accentColor,
                                        () => _toggleFlashNotePin(note),
                                      ),
                                      const SizedBox(width: 6),
                                      if (!note.isAudioNote) ...[
                                        _buildCellAction(Icons.edit_note, colorScheme.primary, () => _openInNotePro(note)),
                                        const SizedBox(width: 6),
                                      ],
                                      if (!note.isAudioNote) ...[
                                        _buildCellAction(Icons.event, _sectionAccent(context, 1), () => _createEventFromFlashNote(note)),
                                        const SizedBox(width: 6),
                                      ],
                                      if (_isAiAvailable)
                                        _buildCellAction(Icons.psychology, Colors.purple, () => _showAIOptions(note, originalIndex)),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                              ],
                            ),
                          ),
                        );
                      },
                    )
                  : ListView.builder(
                      padding: const EdgeInsets.all(16),
                      itemCount: sortedNotes.length,
                      itemBuilder: (context, index) {
                        final note = sortedNotes[index];
                        final originalIndex = _notes.indexOf(note);
                        final heroTag = 'flash_to_deep_${note.createdAt.millisecondsSinceEpoch}';
                        final isSelected = note.id != null && _selectedNoteIds.contains(note.id);
                        // Day divider
                        final showDayDivider = index == 0 || !_isSameDay(note.createdAt, sortedNotes[index - 1].createdAt);
                        return _SlideInItem(index: index, child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                          if (showDayDivider)
                            Padding(
                              padding: const EdgeInsets.only(top: 8, bottom: 8),
                              child: Row(
                                children: [
                                  Expanded(child: Divider(color: colorScheme.outlineVariant.withValues(alpha: 0.3))),
                                  Padding(
                                    padding: const EdgeInsets.symmetric(horizontal: 12),
                                    child: Text(
                                      _formatDayLabel(note.createdAt),
                                      style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.6)),
                                    ),
                                  ),
                                  Expanded(child: Divider(color: colorScheme.outlineVariant.withValues(alpha: 0.3))),
                                ],
                              ),
                            ),
                          Hero(
                          tag: heroTag,
                          child: Material(
                            type: MaterialType.transparency,
                            child: GestureDetector(
                              onTap: () {
                                if (_selectionMode) {
                                  setState(() {
                                    if (note.id != null) {
                                      if (_selectedNoteIds.contains(note.id)) {
                                        _selectedNoteIds.remove(note.id);
                                        if (_selectedNoteIds.isEmpty) _selectionMode = false;
                                      } else {
                                        _selectedNoteIds.add(note.id!);
                                      }
                                    }
                                  });
                                } else {
                                  _openFlashNote(note, originalIndex);
                                }
                              },
                              onLongPress: () {
                                if (!_selectionMode) {
                                  setState(() {
                                    _selectionMode = true;
                                    if (note.id != null) _selectedNoteIds.add(note.id!);
                                  });
                                }
                              },
                              child: AnimatedContainer(
                                duration: const Duration(milliseconds: 200),
                                margin: const EdgeInsets.only(bottom: 8),
                                decoration: isSelected
                                  ? BoxDecoration(
                                      color: accentColor.withValues(alpha: 0.08),
                                      borderRadius: BorderRadius.circular(16),
                                      border: Border.all(color: accentColor, width: 2),
                                    )
                                  : ((_noteStyle == 'paper' && _paperStickyPurchased) || ((_isYellowNoteTheme(context) || _isBlockNoteTheme(context)) && _noteStyle == 'modern'))
                                    ? _paperStickyDecoration(index)
                                    : BoxDecoration(
                                        color: colorScheme.surfaceContainerLowest,
                                        borderRadius: BorderRadius.circular(16),
                                        border: Border.all(
                                          color: colorScheme.outlineVariant.withValues(alpha: 0.3),
                                          width: 1,
                                        ),
                                      ),
                                child: Stack(
                                  children: [
                                    if (!isSelected && ((_noteStyle == 'paper' && _paperStickyPurchased) || ((_isYellowNoteTheme(context) || _isBlockNoteTheme(context)) && _noteStyle == 'modern'))) ...[
                                      Positioned.fill(child: ClipRRect(
                                        borderRadius: const BorderRadius.only(topLeft: Radius.circular(2), topRight: Radius.circular(4), bottomLeft: Radius.circular(3), bottomRight: Radius.circular(1)),
                                        child: CustomPaint(painter: _PaperTexturePainter(seed: index)),
                                      )),
                                      Positioned.fill(child: ClipRRect(
                                        borderRadius: const BorderRadius.only(topLeft: Radius.circular(2), topRight: Radius.circular(4), bottomLeft: Radius.circular(3), bottomRight: Radius.circular(1)),
                                        child: CustomPaint(painter: _PaperMarginPainter(seed: index)),
                                      )),
                                      Positioned.fill(child: CustomPaint(painter: _CornerCurlPainter(baseColor: _paperStickyColors[index % _paperStickyColors.length]))),
                                    ],
                                    Padding(
                                      padding: EdgeInsets.only(
                                        left: !isSelected && ((_noteStyle == 'paper' && _paperStickyPurchased) || ((_isYellowNoteTheme(context) || _isBlockNoteTheme(context)) && _noteStyle == 'modern')) ? 50 : 16,
                                        top: 16, right: 16, bottom: 16,
                                      ),
                                      child: Row(
                                  children: [
                                    if (_selectionMode)
                                      Padding(
                                        padding: const EdgeInsets.only(right: 12),
                                        child: Container(
                                          width: 24, height: 24,
                                          decoration: BoxDecoration(
                                            color: isSelected ? accentColor : Colors.transparent,
                                            shape: BoxShape.circle,
                                            border: Border.all(color: isSelected ? accentColor : colorScheme.outlineVariant, width: 2),
                                          ),
                                          child: isSelected ? const Icon(Icons.check, size: 14, color: Colors.white) : null,
                                        ),
                                      ),
                                    if (note.isAudioNote)
                                      GestureDetector(
                                        onTap: () => _playAudioNote(originalIndex, note.audioPath!),
                                        child: SizedBox(
                                          width: 48,
                                          height: 48,
                                          child: Stack(
                                            alignment: Alignment.center,
                                            children: [
                                              if (_playingNoteIndex == originalIndex)
                                                SizedBox(
                                                  width: 48,
                                                  height: 48,
                                                  child: CircularProgressIndicator(
                                                    value: _audioDuration.inMilliseconds > 0
                                                        ? (_audioPosition.inMilliseconds / _audioDuration.inMilliseconds).clamp(0.0, 1.0)
                                                        : 0.0,
                                                    strokeWidth: 2.5,
                                                    color: accentColor,
                                                    backgroundColor: accentColor.withValues(alpha: 0.15),
                                                  ),
                                                ),
                                              Container(
                                                width: 40,
                                                height: 40,
                                                decoration: BoxDecoration(
                                                  color: _playingNoteIndex == originalIndex
                                                      ? accentColor
                                                      : accentColor.withValues(alpha: 0.12),
                                                  shape: BoxShape.circle,
                                                ),
                                                child: Icon(
                                                  _playingNoteIndex == originalIndex ? Icons.stop_rounded : Icons.play_arrow_rounded,
                                                  color: _playingNoteIndex == originalIndex ? Colors.white : accentColor,
                                                  size: 24,
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                      )
                                    else if (note.isPhotoNote)
                                      StoredImage(
                                        imagePath: note.imagePath,
                                        imageBase64: note.imageBase64,
                                        width: 44,
                                        height: 44,
                                        fit: BoxFit.cover,
                                        borderRadius: BorderRadius.circular(8),
                                      )
                                    else
                                      CircleAvatar(
                                        backgroundColor: accentColor.withValues(alpha: 0.12),
                                        child: Icon(Icons.flash_on, color: accentColor),
                                      ),
                                    const SizedBox(width: 16),
                                    Expanded(
                                      child: Column(
                                        crossAxisAlignment: CrossAxisAlignment.start,
                                        children: [
                                          if (note.isAudioNote) ...[
                                            Row(
                                              children: [
                                                Flexible(
                                                  child: Text(
                                                    note.content.startsWith('🎤') ? tr('voice_note') : note.content,
                                                    style: TextStyle(fontSize: 14, fontWeight: FontWeight.w600, color: colorScheme.onSurface),
                                                    maxLines: 1,
                                                    overflow: TextOverflow.ellipsis,
                                                  ),
                                                ),
                                                const SizedBox(width: 8),
                                                Text(
                                                  _playingNoteIndex == originalIndex
                                                      ? '${_formatAudioDuration(_audioPosition.inSeconds)} / ${_formatAudioDuration(_audioDuration.inSeconds > 0 ? _audioDuration.inSeconds : (note.audioDurationMs ?? 0) ~/ 1000)}'
                                                      : _formatAudioDuration((note.audioDurationMs ?? 0) ~/ 1000),
                                                  style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant),
                                                ),
                                              ],
                                            ),
                                            if (_playingNoteIndex == originalIndex)
                                              SizedBox(
                                                height: 20,
                                                child: SliderTheme(
                                                  data: SliderThemeData(
                                                    trackHeight: 2,
                                                    thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 5),
                                                    activeTrackColor: accentColor,
                                                    inactiveTrackColor: accentColor.withValues(alpha: 0.2),
                                                    thumbColor: accentColor,
                                                    overlayShape: SliderComponentShape.noOverlay,
                                                  ),
                                                  child: Slider(
                                                    value: _audioDuration.inMilliseconds > 0
                                                        ? (_audioPosition.inMilliseconds / _audioDuration.inMilliseconds).clamp(0.0, 1.0)
                                                        : 0.0,
                                                    onChanged: _seekAudio,
                                                  ),
                                                ),
                                              ),
                                          ]
                                          else
                                            Text(
                                              note.content,
                                              style: const TextStyle(fontSize: 14),
                                              maxLines: 2,
                                              overflow: TextOverflow.ellipsis,
                                            ),
                                          const SizedBox(height: 8),
                                          Row(
                                            children: [
                                              Icon(Icons.access_time, size: 14, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7)),
                                              const SizedBox(width: 4),
                                              Text(
                                                _formatDateTime(note.createdAt),
                                                style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7)),
                                              ),
                                              if (note.isPinned) ...[
                                                const SizedBox(width: 8),
                                                Icon(Icons.push_pin, size: 13, color: accentColor),
                                                const SizedBox(width: 2),
                                                Text(tr('pinned'), style: TextStyle(fontSize: 11, color: accentColor, fontWeight: FontWeight.w600)),
                                              ],
                                            ],
                                          ),
                                        ],
                                      ),
                                    ),
                                    IconButton(
                                        icon: Icon(note.isPinned ? Icons.push_pin : Icons.push_pin_outlined, size: 20),
                                        color: accentColor,
                                        tooltip: note.isPinned ? tr('unpin') : tr('pin'),
                                        onPressed: () => _toggleFlashNotePin(note),
                                      ),
                                    if (!note.isAudioNote)
                                      IconButton(
                                        icon: const Icon(Icons.edit_note),
                                        color: colorScheme.primary,
                                        tooltip: tr('open_in_deep_note'),
                                        onPressed: () => _openInNotePro(note),
                                      ),
                                    if (!note.isAudioNote)
                                      IconButton(
                                        icon: const Icon(Icons.event),
                                        color: _sectionAccent(context, 1),
                                        tooltip: tr('create_event'),
                                        onPressed: () => _createEventFromFlashNote(note),
                                      ),
                                    if (_isAiAvailable)
                                      IconButton(
                                        icon: const Icon(Icons.psychology),
                                        color: Colors.purple,
                                        tooltip: 'AI',
                                        onPressed: () => _showAIOptions(note, originalIndex),
                                      ),
                                  ],
                                ),
                              ),
                                  ],
                                ),
                              ),
                            ),
                          ),
                        ),
                        ],
                        ));
                      },
                    ),
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Container(
            padding: const EdgeInsets.symmetric(vertical: 12),
            decoration: BoxDecoration(
              color: colorScheme.surfaceContainerLowest,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(color: colorScheme.outlineVariant.withValues(alpha: 0.3)),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    _PulsingWidget(
                      pulsing: _isAnalyzingPhoto,
                      child: IconButton.filled(
                        onPressed: _addPhotoNote,
                        icon: const Icon(Icons.camera_alt, size: 22),
                        style: IconButton.styleFrom(backgroundColor: accentColor.withValues(alpha: _isAnalyzingPhoto ? 0.3 : 0.12), foregroundColor: accentColor),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(tr('photo'), style: TextStyle(fontSize: 10, color: colorScheme.onSurfaceVariant)),
                  ],
                ),
                Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    IconButton.filled(
                      onPressed: _showWriteSheet,
                      icon: const Icon(Icons.flash_on, size: 22),
                      style: IconButton.styleFrom(backgroundColor: accentColor.withValues(alpha: 0.12), foregroundColor: accentColor),
                    ),
                    const SizedBox(height: 4),
                    Text(tr('write_action'), style: TextStyle(fontSize: 10, color: colorScheme.onSurfaceVariant)),
                  ],
                ),
                Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    IconButton.filled(
                      onPressed: _showAudioSheet,
                      icon: const Icon(Icons.mic, size: 22),
                      style: IconButton.styleFrom(backgroundColor: accentColor.withValues(alpha: 0.12), foregroundColor: accentColor),
                    ),
                    const SizedBox(height: 4),
                    Text(tr('audio'), style: TextStyle(fontSize: 10, color: colorScheme.onSurfaceVariant)),
                  ],
                ),
              ],
            ),
          ),
        ),
      ],
        ),
        // OVERLAY SIDEBAR
        if (_showGroupSidebar) ...[
          // Dark barrier
          Positioned.fill(
            child: GestureDetector(
              onTap: () => setState(() => _showGroupSidebar = false),
              child: AnimatedOpacity(
                opacity: _showGroupSidebar ? 1.0 : 0.0,
                duration: const Duration(milliseconds: 200),
                child: Container(color: Colors.black26),
              ),
            ),
          ),
          // Dropdown panel (vertical drop from top)
          Positioned(
            left: 12, top: 56, right: 12,
            child: AnimatedSlide(
              offset: _showGroupSidebar ? Offset.zero : const Offset(0, -0.3),
              duration: const Duration(milliseconds: 350),
              curve: Curves.easeOutCubic,
              child: AnimatedOpacity(
                opacity: _showGroupSidebar ? 1.0 : 0.0,
                duration: const Duration(milliseconds: 250),
                child: Container(
                  width: 220,
                  constraints: BoxConstraints(maxHeight: MediaQuery.of(context).size.height * 0.6),
                  decoration: BoxDecoration(
                    color: colorScheme.surfaceContainerLowest,
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(color: colorScheme.outlineVariant.withValues(alpha: 0.3)),
                    boxShadow: [BoxShadow(color: Colors.black.withValues(alpha: 0.15), blurRadius: 20, offset: const Offset(0, 4))],
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 8, 8),
                        child: Row(
                          children: [
                            Icon(_getGroupIcon(), size: 20, color: accentColor),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                _groupingMode == 'daily' ? tr('by_day') : _groupingMode == 'weekly' ? tr('by_week') : _groupingMode == 'yearly' ? tr('by_year') : tr('by_month'),
                                style: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold),
                              ),
                            ),
                            IconButton(
                              icon: const Icon(Icons.close, size: 20),
                              onPressed: () => setState(() => _showGroupSidebar = false),
                              visualDensity: VisualDensity.compact,
                            ),
                          ],
                        ),
                      ),
                      const Divider(height: 1),
                      // "Tutte" item
                      ListTile(
                        dense: true,
                        leading: Icon(Icons.flash_on, size: 20, color: _selectedGroup == null ? accentColor : colorScheme.onSurfaceVariant),
                        title: Text(tr('all_items'), style: TextStyle(fontWeight: _selectedGroup == null ? FontWeight.w700 : FontWeight.normal, color: _selectedGroup == null ? accentColor : null)),
                        trailing: Text('${_notes.length}', style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                        selected: _selectedGroup == null,
                        selectedTileColor: accentColor.withValues(alpha: 0.08),
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                        onTap: () => setState(() { _selectedGroup = null; _showGroupSidebar = false; }),
                      ),
                      const Divider(height: 1, indent: 16, endIndent: 16),
                      // Group items
                      Flexible(
                        child: ListView(
                          shrinkWrap: true,
                          padding: const EdgeInsets.symmetric(vertical: 4),
                          children: groupKeys.map((key) {
                            final isSelected = _selectedGroup == key;
                            final label = _getGroupLabel(key);
                            final groupNotes = groupedNotes[key] ?? [];
                            return ListTile(
                              dense: true,
                              leading: Icon(_getGroupIcon(), size: 20, color: isSelected ? accentColor : colorScheme.onSurfaceVariant),
                              title: Text(label, style: TextStyle(fontWeight: isSelected ? FontWeight.w700 : FontWeight.normal, color: isSelected ? accentColor : null)),
                              trailing: Text('${groupNotes.length}', style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                              selected: isSelected,
                              selectedTileColor: accentColor.withValues(alpha: 0.08),
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                              onTap: () => setState(() { _selectedGroup = key; _showGroupSidebar = false; }),
                              onLongPress: () => _showDeleteGroupDialog(label, groupNotes),
                            );
                          }).toList(),
                        ),
                      ),
                      const SizedBox(height: 8),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ],
      ],
    );
  }

  void _showWriteSheet() {
    Navigator.push(context, MaterialPageRoute(
      builder: (_) => FlashNoteEditorPage(
        onSave: (note) async {
          await DatabaseHelper().insertFlashNote(note);
          if (mounted) await _loadNotes();
        },
      ),
    ));
  }

  String _formatAudioDuration(int totalSeconds) {
    final m = (totalSeconds ~/ 60).toString().padLeft(2, '0');
    final s = (totalSeconds % 60).toString().padLeft(2, '0');
    return '$m:$s';
  }

  Future<void> _playAudioNote(int noteIndex, String audioPath) async {
    // If same note is playing, stop it
    if (_playingNoteIndex == noteIndex) {
      await _audioPlayer?.stop();
      if (!mounted) return;
      setState(() { _playingNoteIndex = null; _audioPosition = Duration.zero; });
      return;
    }
    // Stop any current playback
    await _audioPlayer?.stop();
    _playerSubscription?.cancel();
    _positionSub?.cancel();
    _durationSub?.cancel();
    _audioPlayer?.dispose();
    _audioPlayer = ap.AudioPlayer();
    _playerSubscription = _audioPlayer!.onPlayerComplete.listen((_) {
      if (mounted) setState(() { _playingNoteIndex = null; _audioPosition = Duration.zero; });
    });
    _positionSub = _audioPlayer!.onPositionChanged.listen((p) {
      if (mounted) setState(() => _audioPosition = p);
    });
    _durationSub = _audioPlayer!.onDurationChanged.listen((d) {
      if (mounted) setState(() => _audioDuration = d);
    });
    try {
      if (kIsWeb) {
        await _audioPlayer!.play(ap.UrlSource(audioPath));
      } else {
        await _audioPlayer!.play(ap.DeviceFileSource(audioPath));
      }
      if (!mounted) return;
      setState(() { _playingNoteIndex = noteIndex; _audioPosition = Duration.zero; });
    } catch (_) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(tr('error')),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  Future<void> _seekAudio(double value) async {
    if (_audioDuration.inMilliseconds > 0) {
      final newPos = Duration(milliseconds: (value * _audioDuration.inMilliseconds).toInt());
      await _audioPlayer?.seek(newPos);
      if (!mounted) return;
      setState(() => _audioPosition = newPos);
    }
  }

  void _showAudioSheet() async {
    // Prevent double-opening (e.g. deep link re-delivery while recording)
    if (_isAudioSheetOpen) return;
    _isAudioSheetOpen = true;

    final accentColor = _sectionAccent(context, 2);
    final colorScheme = Theme.of(context).colorScheme;
    final recorder = AudioRecorder();
    final flashSettings = await FlashNotesSettings.load();
    final auraSettings = await EthosAuraSettings.load();
    final maxDuration = auraSettings.unlimitedVoicePurchased ? 0 : flashSettings.maxAudioDurationSeconds;

    if (!await recorder.hasPermission()) {
      recorder.dispose();
      _isAudioSheetOpen = false;
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(tr('error')),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
      return;
    }

    bool isRecording = false;
    String? recordedPath;
    int elapsedSeconds = 0;
    Timer? timer;
    bool isPlayingPreview = false;
    ap.AudioPlayer? previewPlayer;
    final voiceTitleController = TextEditingController();
    StreamSubscription? recorderStateSub;

    if (!mounted) { _isAudioSheetOpen = false; return; }
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      isDismissible: false,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (ctx) => StatefulBuilder(
        builder: (ctx, setSheetState) {
          return Padding(
            padding: EdgeInsets.only(
              left: 24, right: 24, top: 20,
              bottom: MediaQuery.of(ctx).viewInsets.bottom + 24,
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Handle bar
                Container(width: 40, height: 4, decoration: BoxDecoration(color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3), borderRadius: BorderRadius.circular(2))),
                const SizedBox(height: 20),
                // Title
                Text(
                  recordedPath != null ? tr('preview') : (isRecording ? tr('recording') : tr('voice_note')),
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: colorScheme.onSurface),
                ),
                const SizedBox(height: 20),
                // Timer
                Text(
                  _formatAudioDuration(elapsedSeconds),
                  style: TextStyle(
                    fontSize: 48,
                    fontWeight: FontWeight.w200,
                    color: isRecording ? Colors.red : colorScheme.onSurface,
                    fontFeatures: const [FontFeature.tabularFigures()],
                  ),
                ),
                const SizedBox(height: 24),

                if (recordedPath == null) ...[
                  // Pulsing ring behind mic button when recording
                  Stack(
                    alignment: Alignment.center,
                    children: [
                      if (isRecording)
                        TweenAnimationBuilder<double>(
                          tween: Tween(begin: 0.8, end: 1.0),
                          duration: const Duration(milliseconds: 1000),
                          builder: (_, val, __) => Container(
                            width: 100 * val,
                            height: 100 * val,
                            decoration: BoxDecoration(
                              shape: BoxShape.circle,
                              border: Border.all(color: Colors.red.withValues(alpha: 0.3 * (2 - val)), width: 3),
                            ),
                          ),
                        ),
                      // Record / Stop button
                      GestureDetector(
                        onTap: () async {
                          if (isRecording) {
                            timer?.cancel();
                            recorderStateSub?.cancel();
                            final path = await recorder.stop();
                            recordedPath = path;
                            setSheetState(() => isRecording = false);
                          } else {
                            String path = '';
                            if (!kIsWeb) {
                              try {
                                final tempDir = await getTemporaryDirectory();
                                path = '${tempDir.path}/audio_${DateTime.now().millisecondsSinceEpoch}.m4a';
                              } catch (_) {
                                path = 'audio_${DateTime.now().millisecondsSinceEpoch}.m4a';
                              }
                            }
                            await recorder.start(const RecordConfig(
                              encoder: AudioEncoder.aacLc,
                              bitRate: 128000,
                              sampleRate: 44100,
                            ), path: path);
                            elapsedSeconds = 0;
                            // Listen for unexpected recorder stops (OS killed MediaRecorder)
                            recorderStateSub?.cancel();
                            recorderStateSub = recorder.onStateChanged().listen((state) {
                              if (state == RecordState.stop && isRecording) {
                                timer?.cancel();
                                debugPrint('Recorder stopped unexpectedly at ${elapsedSeconds}s');
                                recordedPath = path;
                                isRecording = false;
                                setSheetState(() {});
                              }
                            });
                            timer = Timer.periodic(const Duration(seconds: 1), (_) async {
                              elapsedSeconds++;
                              // Periodic health check: verify recorder is still active
                              if (elapsedSeconds % 10 == 0) {
                                final stillRecording = await recorder.isRecording();
                                if (!stillRecording && isRecording) {
                                  timer?.cancel();
                                  debugPrint('Recorder health check failed at ${elapsedSeconds}s');
                                  recordedPath = path;
                                  isRecording = false;
                                  setSheetState(() {});
                                  return;
                                }
                              }
                              setSheetState(() {});
                              if (maxDuration > 0 && elapsedSeconds >= maxDuration) {
                                timer?.cancel();
                                recorder.stop().then((p) {
                                  recordedPath = p;
                                  setSheetState(() => isRecording = false);
                                });
                              }
                            });
                            setSheetState(() => isRecording = true);
                          }
                        },
                        child: AnimatedContainer(
                          duration: const Duration(milliseconds: 300),
                          curve: Curves.easeOutCubic,
                          width: isRecording ? 64 : 80,
                          height: isRecording ? 64 : 80,
                          decoration: BoxDecoration(
                            color: isRecording ? Colors.red : accentColor,
                            shape: isRecording ? BoxShape.rectangle : BoxShape.circle,
                            borderRadius: isRecording ? BorderRadius.circular(16) : null,
                            boxShadow: [
                              BoxShadow(
                                color: (isRecording ? Colors.red : accentColor).withValues(alpha: 0.3),
                                blurRadius: 16,
                                offset: const Offset(0, 4),
                              ),
                            ],
                          ),
                          child: Icon(
                            isRecording ? Icons.stop_rounded : Icons.mic,
                            color: Colors.white,
                            size: 36,
                          ),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  // Progress bar (recording progress to 2 min max)
                  if (isRecording)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 32),
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(4),
                        child: LinearProgressIndicator(
                          value: elapsedSeconds / maxDuration,
                          backgroundColor: colorScheme.outlineVariant.withValues(alpha: 0.2),
                          valueColor: AlwaysStoppedAnimation<Color>(Colors.red.withValues(alpha: 0.7)),
                          minHeight: 3,
                        ),
                      ),
                    ),
                  if (isRecording) const SizedBox(height: 8),
                  Text(
                    isRecording ? tr('tap_to_stop') : tr('tap_to_record'),
                    style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant),
                  ),
                  if (isRecording)
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: Text(
                        maxDuration >= 60 ? 'max ${maxDuration ~/ 60} min' : 'max $maxDuration ${tr('seconds')}',
                        style: TextStyle(fontSize: 11, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.6)),
                      ),
                    ),
                ] else ...[
                  // Optional title
                  Padding(
                    padding: const EdgeInsets.only(bottom: 16),
                    child: TextField(
                      controller: voiceTitleController,
                      decoration: InputDecoration(
                        hintText: tr('optional_title'),
                        prefixIcon: const Icon(Icons.title, size: 20),
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                        isDense: true,
                      ),
                    ),
                  ),
                  // Preview controls
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      // Play/Stop preview
                      IconButton.filled(
                        onPressed: () async {
                          if (isPlayingPreview) {
                            await previewPlayer?.stop();
                            setSheetState(() => isPlayingPreview = false);
                          } else {
                            if (previewPlayer == null) {
                              previewPlayer = ap.AudioPlayer();
                              previewPlayer!.onPlayerComplete.listen((_) {
                                setSheetState(() => isPlayingPreview = false);
                              });
                            }
                            try {
                              if (kIsWeb) {
                                await previewPlayer!.play(ap.UrlSource(recordedPath!));
                              } else {
                                await previewPlayer!.play(ap.DeviceFileSource(recordedPath!));
                              }
                              setSheetState(() => isPlayingPreview = true);
                            } catch (_) {
                              setSheetState(() => isPlayingPreview = false);
                            }
                          }
                        },
                        icon: Icon(isPlayingPreview ? Icons.stop_rounded : Icons.play_arrow_rounded, size: 32),
                        style: IconButton.styleFrom(
                          backgroundColor: accentColor,
                          foregroundColor: Colors.white,
                          fixedSize: const Size(64, 64),
                        ),
                      ),
                      const SizedBox(width: 16),
                      // Re-record
                      IconButton.filled(
                        onPressed: () async {
                          await previewPlayer?.stop();
                          isPlayingPreview = false;
                          recordedPath = null;
                          elapsedSeconds = 0;
                          setSheetState(() {});
                        },
                        icon: const Icon(Icons.refresh_rounded, size: 28),
                        style: IconButton.styleFrom(
                          backgroundColor: colorScheme.surfaceContainerHighest,
                          foregroundColor: colorScheme.onSurface,
                          fixedSize: const Size(52, 52),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                  // Save button
                  SizedBox(
                    width: double.infinity,
                    child: FilledButton.icon(
                      onPressed: () {
                        setState(() {
                          _notes.add(FlashNote(
                            content: voiceTitleController.text.isNotEmpty
                                ? voiceTitleController.text
                                : '🎤 Nota vocale (${_formatAudioDuration(elapsedSeconds)})',
                            audioPath: recordedPath,
                            audioDurationMs: elapsedSeconds * 1000,
                          ));
                        });
                        _saveNotes();
                        Navigator.pop(ctx);
                      },
                      icon: const Icon(Icons.check, size: 18),
                      label: Text(tr('save')),
                      style: FilledButton.styleFrom(
                        backgroundColor: accentColor,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                      ),
                    ),
                  ),
                ],

                const SizedBox(height: 12),
                if (!isRecording)
                  TextButton(
                    onPressed: () {
                      timer?.cancel();
                      previewPlayer?.stop();
                      Navigator.pop(ctx);
                    },
                    child: Text(recordedPath != null ? tr('cancel') : tr('close')),
                  ),
              ],
            ),
          );
        },
      ),
    ).then((_) {
      timer?.cancel();
      recorderStateSub?.cancel();
      recorder.dispose();
      previewPlayer?.dispose();
      voiceTitleController.dispose();
      _isAudioSheetOpen = false;
    });
  }

  Widget _buildCellAction(IconData icon, Color color, VoidCallback onTap) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.all(4),
        decoration: BoxDecoration(
          color: color.withValues(alpha: 0.08),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Icon(icon, size: 15, color: color),
      ),
    );
  }

}

// NOTE PRO
class FolderStyle {
  final IconData icon;
  final Color color;
  final bool isCustom;
  final bool isShared;
  final bool isPrivate;
  final List<String> sharedEmails;
  final String? emojiIcon;
  const FolderStyle(this.icon, this.color, {this.isCustom = false, this.isShared = false, this.isPrivate = false, this.sharedEmails = const [], this.emojiIcon});

  Widget buildIcon({double size = 22, Color? iconColor}) {
    if (emojiIcon != null) {
      return Text(emojiIcon!, style: TextStyle(fontSize: size));
    }
    return Icon(icon, size: size, color: iconColor);
  }

  Map<String, dynamic> toJson() => {
    'iconCode': icon.codePoint,
    'colorValue': color.value,
    'isCustom': isCustom,
    'isShared': isShared,
    'isPrivate': isPrivate,
    'sharedEmails': sharedEmails,
    if (emojiIcon != null) 'emojiIcon': emojiIcon,
  };

  factory FolderStyle.fromJson(Map<String, dynamic> json) => FolderStyle(
    IconData(json['iconCode'], fontFamily: 'MaterialIcons'),
    Color(json['colorValue']),
    isCustom: json['isCustom'] ?? false,
    isShared: json['isShared'] ?? false,
    isPrivate: json['isPrivate'] ?? false,
    sharedEmails: (json['sharedEmails'] as List?)?.cast<String>() ?? [],
    emojiIcon: json['emojiIcon'],
  );

  Map<String, dynamic> toDbMap(String name) => {
    'name': name,
    'icon_code': icon.codePoint,
    'color_value': color.value,
    'is_custom': isCustom ? 1 : 0,
    'is_shared': isShared ? 1 : 0,
    'is_private': isPrivate ? 1 : 0,
    'shared_emails': sharedEmails.isNotEmpty ? json.encode(sharedEmails) : null,
    'emoji_icon': emojiIcon,
  };

  factory FolderStyle.fromDbMap(Map<String, dynamic> m) => FolderStyle(
    IconData(m['icon_code'] as int, fontFamily: 'MaterialIcons'),
    Color(m['color_value'] as int),
    isCustom: (m['is_custom'] as int?) == 1,
    isShared: (m['is_shared'] as int?) == 1,
    isPrivate: (m['is_private'] as int?) == 1,
    sharedEmails: m['shared_emails'] != null ? (json.decode(m['shared_emails'] as String) as List).cast<String>() : [],
    emojiIcon: m['emoji_icon'] as String?,
  );
}

class ProNote {
  final int? id;
  final String title;
  final String content;
  final String? contentDelta;
  final String? headerText;
  final String? footerText;
  final String? templatePreset;
  final DateTime createdAt;
  final DateTime? updatedAt;
  final String folder;
  final DateTime? linkedDate;
  final String? imageBase64;
  final String? imagePath;
  final bool isPinned;

  ProNote({
    this.id,
    required this.title,
    required this.content,
    this.contentDelta,
    this.headerText,
    this.footerText,
    this.templatePreset,
    this.folder = 'Generale',
    this.linkedDate,
    this.imageBase64,
    this.imagePath,
    this.updatedAt,
    this.isPinned = false,
    DateTime? createdAt,
  }) : createdAt = createdAt ?? DateTime.now();

  /// The effective sort date: updatedAt if available, otherwise createdAt.
  DateTime get sortDate => updatedAt ?? createdAt;

  ProNote copyWith({
    int? id,
    String? title,
    String? content,
    String? contentDelta,
    String? headerText,
    String? footerText,
    String? templatePreset,
    String? folder,
    DateTime? linkedDate,
    String? imageBase64,
    String? imagePath,
    DateTime? updatedAt,
    DateTime? createdAt,
    bool? isPinned,
  }) => ProNote(
    id: id ?? this.id,
    title: title ?? this.title,
    content: content ?? this.content,
    contentDelta: contentDelta ?? this.contentDelta,
    headerText: headerText ?? this.headerText,
    footerText: footerText ?? this.footerText,
    templatePreset: templatePreset ?? this.templatePreset,
    folder: folder ?? this.folder,
    linkedDate: linkedDate ?? this.linkedDate,
    imageBase64: imageBase64 ?? this.imageBase64,
    imagePath: imagePath ?? this.imagePath,
    updatedAt: updatedAt ?? this.updatedAt,
    createdAt: createdAt ?? this.createdAt,
    isPinned: isPinned ?? this.isPinned,
  );

  Map<String, dynamic> toJson() => {
    'title': title,
    'content': content,
    'contentDelta': contentDelta,
    'headerText': headerText,
    'footerText': footerText,
    'templatePreset': templatePreset,
    'folder': folder,
    'linkedDate': linkedDate?.toIso8601String(),
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt?.toIso8601String(),
    'imageBase64': imageBase64,
    if (imagePath != null) 'imagePath': imagePath,
    'isPinned': isPinned,
  };

  factory ProNote.fromJson(Map<String, dynamic> json) => ProNote(
    title: json['title'] ?? '',
    content: json['content'] ?? '',
    contentDelta: json['contentDelta'],
    headerText: json['headerText'],
    footerText: json['footerText'],
    templatePreset: json['templatePreset'],
    folder: json['folder'] ?? 'Generale',
    linkedDate: json['linkedDate'] != null ? DateTime.tryParse(json['linkedDate'] ?? '') : null,
    createdAt: DateTime.tryParse(json['createdAt'] ?? '') ?? DateTime.now(),
    updatedAt: json['updatedAt'] != null ? DateTime.tryParse(json['updatedAt'] ?? '') : null,
    imageBase64: json['imageBase64'],
    imagePath: json['imagePath'],
    isPinned: json['isPinned'] == true,
  );

  Map<String, dynamic> toDbMap() => {
    'title': title,
    'content': content,
    'content_delta': contentDelta,
    'header_text': headerText,
    'footer_text': footerText,
    'template_preset': templatePreset,
    'folder': folder,
    'linked_date': linkedDate?.millisecondsSinceEpoch,
    'created_at': createdAt.millisecondsSinceEpoch,
    'updated_at': updatedAt?.millisecondsSinceEpoch,
    'image_base64': imageBase64,
    'image_path': imagePath,
    'is_pinned': isPinned ? 1 : 0,
  };

  factory ProNote.fromDbMap(Map<String, dynamic> m) => ProNote(
    id: m['id'] as int?,
    title: (m['title'] as String?) ?? '',
    content: (m['content'] as String?) ?? '',
    contentDelta: m['content_delta'] as String?,
    headerText: m['header_text'] as String?,
    footerText: m['footer_text'] as String?,
    templatePreset: m['template_preset'] as String?,
    folder: (m['folder'] as String?) ?? 'Generale',
    linkedDate: m['linked_date'] != null ? DateTime.fromMillisecondsSinceEpoch(m['linked_date'] as int) : null,
    createdAt: DateTime.fromMillisecondsSinceEpoch((m['created_at'] as int?) ?? 0),
    updatedAt: m['updated_at'] != null ? DateTime.fromMillisecondsSinceEpoch(m['updated_at'] as int) : null,
    imageBase64: m['image_base64'] as String?,
    imagePath: m['image_path'] as String?,
    isPinned: (m['is_pinned'] as int?) == 1,
  );
}

class BusinessTemplate {
  final String header;
  final List<Map<String, dynamic>> contentDelta;
  final String footer;

  const BusinessTemplate({
    required this.header,
    required this.contentDelta,
    required this.footer,
  });
}

class NoteProSettings {
  final String? securityPin;
  final bool showPrivateFolder;
  final bool biometricEnabled;
  final String pdfSaveMode; // 'local' or 'google_drive'
  final List<Map<String, dynamic>> customTemplates;
  final List<String> downloadedFonts;
  final bool trashEnabled;
  final int trashRetentionDays;
  final bool pdfShowLogo;

  const NoteProSettings({
    this.securityPin,
    this.showPrivateFolder = false,
    this.biometricEnabled = false,
    this.pdfSaveMode = 'local',
    this.customTemplates = const [],
    this.downloadedFonts = const [],
    this.trashEnabled = true,
    this.trashRetentionDays = 30,
    this.pdfShowLogo = false,
  });

  NoteProSettings copyWith({
    String? securityPin,
    bool? clearPin,
    bool? showPrivateFolder,
    bool? biometricEnabled,
    String? pdfSaveMode,
    List<Map<String, dynamic>>? customTemplates,
    List<String>? downloadedFonts,
    bool? trashEnabled,
    int? trashRetentionDays,
    bool? pdfShowLogo,
  }) {
    return NoteProSettings(
      securityPin: clearPin == true ? null : (securityPin ?? this.securityPin),
      showPrivateFolder: showPrivateFolder ?? this.showPrivateFolder,
      biometricEnabled: biometricEnabled ?? this.biometricEnabled,
      pdfSaveMode: pdfSaveMode ?? this.pdfSaveMode,
      customTemplates: customTemplates ?? this.customTemplates,
      downloadedFonts: downloadedFonts ?? this.downloadedFonts,
      trashEnabled: trashEnabled ?? this.trashEnabled,
      trashRetentionDays: trashRetentionDays ?? this.trashRetentionDays,
      pdfShowLogo: pdfShowLogo ?? this.pdfShowLogo,
    );
  }

  Map<String, dynamic> toJson() => {
    'securityPin': securityPin,
    'showPrivateFolder': showPrivateFolder,
    'biometricEnabled': biometricEnabled,
    'pdfSaveMode': pdfSaveMode,
    'customTemplates': customTemplates,
    'downloadedFonts': downloadedFonts,
    'trashEnabled': trashEnabled,
    'trashRetentionDays': trashRetentionDays,
    'pdfShowLogo': pdfShowLogo,
  };

  factory NoteProSettings.fromJson(Map<String, dynamic> json) => NoteProSettings(
    securityPin: json['securityPin'],
    showPrivateFolder: json['showPrivateFolder'] ?? false,
    biometricEnabled: json['biometricEnabled'] ?? false,
    pdfSaveMode: json['pdfSaveMode'] ?? 'local',
    customTemplates: (json['customTemplates'] as List?)?.cast<Map<String, dynamic>>() ?? [],
    downloadedFonts: (json['downloadedFonts'] as List?)?.cast<String>() ?? [],
    trashEnabled: json['trashEnabled'] ?? true,
    trashRetentionDays: json['trashRetentionDays'] ?? 30,
    pdfShowLogo: json['pdfShowLogo'] ?? false,
  );

  static Future<NoteProSettings> load() async {
    final jsonStr = await DatabaseHelper().getSetting('note_pro_settings');
    if (jsonStr != null) {
      return NoteProSettings.fromJson(json.decode(jsonStr));
    }
    return const NoteProSettings();
  }

  Future<void> save() async {
    await DatabaseHelper().saveSetting('note_pro_settings', json.encode(toJson()));
  }
}

class TrashedNote {
  final int? id;
  final String type; // 'pro' or 'flash'
  final Map<String, dynamic> noteJson;
  final DateTime deletedAt;

  const TrashedNote({
    this.id,
    required this.type,
    required this.noteJson,
    required this.deletedAt,
  });

  Map<String, dynamic> toJson() => {
    'type': type,
    'noteJson': noteJson,
    'deletedAt': deletedAt.toIso8601String(),
  };

  factory TrashedNote.fromJson(Map<String, dynamic> j) => TrashedNote(
    type: j['type'] ?? 'flash',
    noteJson: Map<String, dynamic>.from(j['noteJson'] ?? {}),
    deletedAt: DateTime.tryParse(j['deletedAt'] ?? '') ?? DateTime.now(),
  );

  Map<String, dynamic> toDbMap() => {
    'type': type,
    'note_json': json.encode(noteJson),
    'deleted_at': deletedAt.millisecondsSinceEpoch,
  };

  factory TrashedNote.fromDbMap(Map<String, dynamic> m) => TrashedNote(
    id: m['id'] as int?,
    type: (m['type'] as String?) ?? 'flash',
    noteJson: Map<String, dynamic>.from(json.decode((m['note_json'] as String?) ?? '{}')),
    deletedAt: DateTime.fromMillisecondsSinceEpoch((m['deleted_at'] as int?) ?? 0),
  );

  int daysRemaining(int retentionDays) {
    final expiresAt = deletedAt.add(Duration(days: retentionDays));
    return expiresAt.difference(DateTime.now()).inDays;
  }

  static Future<List<TrashedNote>> load() async {
    return await DatabaseHelper().getAllTrashedNotes();
  }

  static Future<void> saveAll(List<TrashedNote> notes) async {
    await DatabaseHelper().saveAllTrashedNotes(notes);
  }

  static Future<void> cleanExpired(int retentionDays) async {
    await DatabaseHelper().cleanExpiredTrash(retentionDays);
  }
}

class NotesProPage extends StatefulWidget {
  const NotesProPage({super.key});

  @override
  State<NotesProPage> createState() => _NotesProPageState();
}

class _NotesProPageState extends State<NotesProPage> {
  List<ProNote> _proNotes = [];
  Map<String, FolderStyle> _folders = {
    'Generale': const FolderStyle(Icons.folder, Colors.blue),
    tr('work'): const FolderStyle(Icons.work, Colors.orange),
    tr('personal'): const FolderStyle(Icons.person, Colors.green),
    'Flash Notes': const FolderStyle(Icons.flash_on, Color(0xFFFFA726)),
    tr('private_folder'): const FolderStyle(Icons.lock, Color(0xFF7B1FA2)),
  };
  String _selectedFolder = tr('all_items');
  NoteProSettings _settings = const NoteProSettings();
  bool _privateUnlocked = false;
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';
  bool _isGridView = false;
  bool _showFolderSidebar = false;
  bool _cycleDiaryBadge = false;
  bool _selectionMode = false;
  Set<int> _selectedNoteIds = {};
  String _sortMode = 'newest';

  static const _availableIcons = [
    Icons.folder, Icons.work, Icons.person, Icons.school,
    Icons.star, Icons.favorite, Icons.bookmark, Icons.lightbulb,
    Icons.music_note, Icons.sports, Icons.code, Icons.palette,
  ];

  static const _availableColors = [
    Colors.blue, Colors.red, Colors.green, Colors.orange,
    Colors.purple, Colors.teal, Colors.pink, Colors.indigo,
    Colors.amber, Colors.cyan,
  ];

  @override
  void initState() {
    super.initState();
    _loadNotes();
    _loadCustomFolders();
    _loadSettings();
    _loadSortMode();
    _loadViewMode();
    _checkCycleDiaryBadge();
  }

  Future<void> _loadSortMode() async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() => _sortMode = prefs.getString('deep_sort_mode') ?? 'newest');
  }

  Future<void> _saveSortMode(String mode) async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() => _sortMode = mode);
    await prefs.setString('deep_sort_mode', mode);
  }
  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadViewMode() async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() => _isGridView = prefs.getBool('notes_view_mode_grid') ?? false);
  }

  Future<void> _checkCycleDiaryBadge() async {
    final val = await DatabaseHelper().getCache('cycle_diary_active');
    final active = val != null && val.isNotEmpty;
    if (mounted && active != _cycleDiaryBadge) {
      setState(() => _cycleDiaryBadge = active);
    }
  }

  Future<void> _toggleViewMode() async {
    final prefs = await SharedPreferences.getInstance();
    if (!mounted) return;
    setState(() => _isGridView = !_isGridView);
    await prefs.setBool('notes_view_mode_grid', _isGridView);
  }

  Future<void> _loadSettings() async {
    final settings = await NoteProSettings.load();
    if (!mounted) return;
    setState(() => _settings = settings);
  }

  Future<void> _loadCustomFolders() async {
    final customFolders = await DatabaseHelper().getAllFolders();
    if (!mounted) return;
    setState(() {
      _folders.addAll(customFolders);
    });
  }

  Future<void> _saveCustomFolders() async {
    final customOnly = Map.fromEntries(
      _folders.entries.where((e) => e.value.isCustom),
    );
    await DatabaseHelper().saveAllFolders(customOnly);
  }

  Future<void> _loadNotes() async {
    final notes = await DatabaseHelper().getAllProNotes();
    if (!mounted) return;
    setState(() {
      _proNotes = notes;
    });
  }

  Future<void> _saveNotes() async {
    await DatabaseHelper().replaceAllProNotes(_proNotes);
  }

  Future<void> _toggleProNotePin(ProNote note) async {
    if (note.id == null) return;
    final updated = note.copyWith(isPinned: !note.isPinned);
    await DatabaseHelper().updateProNote(note.id!, updated);
    _loadNotes();
  }

  void _createNewNote() {
    // In "Diario del Ciclo" folder, open cycle questionnaire instead
    if (_selectedFolder == 'Diario del Ciclo') {
      _createNewCycleDiary();
      return;
    }
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => NoteEditorPage(
          folders: _folders,
          onSave: (note) async {
            await DatabaseHelper().insertProNote(note);
            if (mounted) await _loadNotes();
          },
        ),
      ),
    );
  }

  void _createNewCycleDiary() {
    final months = localizedMonths();
    final now = DateTime.now();
    final month = months[now.month] ?? '';
    final data = <String, dynamic>{
      'type': 'cycle_diary',
      'periodStart': '',
      'periodEnd': '',
      'month': month,
      'timing': null,
      'flow': null,
      'symptoms': <String>[],
      'energy': null,
      'cravings': <String>[],
      'cravingsCustom': '',
      'sleep': null,
      'sleepCustom': '',
      'emotions': <String>[],
      'emotionsCustom': '',
      'notes': '',
      'missingReason': null,
      'missingReasonCustom': '',
    };
    Navigator.push(context, MaterialPageRoute(
      builder: (_) => CycleDiaryPage(
        data: data,
        onSave: (updatedData) async {
          final note = ProNote(
            title: '${tr('cycle_report')} $month',
            content: _CalendarPageState.buildCycleDiaryPlainText(updatedData),
            contentDelta: json.encode(updatedData),
            folder: 'Diario del Ciclo',
            createdAt: DateTime.now(),
          );
          await DatabaseHelper().insertProNote(note);
          if (mounted) await _loadNotes();
        },
        onComplete: (updatedData) async {
          final note = ProNote(
            title: '${tr('cycle_report')} $month',
            content: _CalendarPageState.buildCycleDiaryPlainText(updatedData),
            contentDelta: json.encode(updatedData),
            folder: 'Diario del Ciclo',
            createdAt: DateTime.now(),
          );
          await DatabaseHelper().insertProNote(note);
          await DatabaseHelper().deleteCache('cycle_diary_active');
          if (mounted) await _loadNotes();
        },
      ),
    ));
  }

  bool _isCycleDiaryNote(ProNote note) {
    if (note.folder != 'Diario del Ciclo' || note.contentDelta == null) return false;
    try {
      final data = json.decode(note.contentDelta!) as Map<String, dynamic>;
      return data['type'] == 'cycle_diary' || data['type'] == 'cycle_missing';
    } catch (_) {
      return false;
    }
  }

  void _editNote(int index) {
    final note = _proNotes[index];
    // Cycle diary notes open in interactive questionnaire
    if (_isCycleDiaryNote(note)) {
      _editCycleDiaryNote(note);
      return;
    }
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => NoteReadPage(
          note: note,
          folders: _folders,
          onSave: (updatedNote) async {
            final withTimestamp = ProNote(
              title: updatedNote.title,
              content: updatedNote.content,
              contentDelta: updatedNote.contentDelta,
              headerText: updatedNote.headerText,
              footerText: updatedNote.footerText,
              templatePreset: updatedNote.templatePreset,
              folder: updatedNote.folder,
              linkedDate: updatedNote.linkedDate,
              imageBase64: updatedNote.imageBase64,
              createdAt: note.createdAt,
              updatedAt: DateTime.now(),
            );
            if (note.id != null) {
              await DatabaseHelper().updateProNote(note.id!, withTimestamp);
            } else {
              await DatabaseHelper().insertProNote(withTimestamp);
            }
            if (mounted) await _loadNotes();
          },
        ),
      ),
    );
  }

  void _editCycleDiaryNote(ProNote note) {
    final data = json.decode(note.contentDelta!) as Map<String, dynamic>;
    Navigator.push(context, MaterialPageRoute(
      builder: (_) => CycleDiaryPage(
        data: data,
        noteId: note.id,
        onSave: (updatedData) async {
          if (note.id != null) {
            final updated = ProNote(
              title: note.title,
              content: _CalendarPageState.buildCycleDiaryPlainText(updatedData),
              contentDelta: json.encode(updatedData),
              folder: 'Diario del Ciclo',
              createdAt: note.createdAt,
              updatedAt: DateTime.now(),
            );
            await DatabaseHelper().updateProNote(note.id!, updated);
            await _loadNotes();
          }
        },
        onComplete: (updatedData) async {
          if (note.id != null) {
            final updated = ProNote(
              title: note.title,
              content: _CalendarPageState.buildCycleDiaryPlainText(updatedData),
              contentDelta: json.encode(updatedData),
              folder: 'Diario del Ciclo',
              createdAt: note.createdAt,
              updatedAt: DateTime.now(),
            );
            await DatabaseHelper().updateProNote(note.id!, updated);
            await DatabaseHelper().deleteCache('cycle_diary_active');
            await _loadNotes();
          }
        },
      ),
    ));
  }

  List<ProNote> get _filteredNotes {
    List<ProNote> notes;
    if (_selectedFolder == tr('all_items')) {
      notes = _proNotes.where((n) {
        if (n.folder == tr('private_folder')) return false;
        if (n.folder == 'Diario del Ciclo') return false;
        final fs = _folders[n.folder];
        if (fs != null && fs.isPrivate) return false;
        return true;
      }).toList();
    } else if ((_selectedFolder == tr('private_folder') || (_folders[_selectedFolder]?.isPrivate ?? false) || _selectedFolder == 'Diario del Ciclo') && !_privateUnlocked) {
      notes = [];
    } else {
      notes = _proNotes.where((note) => note.folder == _selectedFolder).toList();
    }
    if (_searchQuery.isNotEmpty) {
      final q = _searchQuery.toLowerCase();
      notes = notes.where((n) =>
        n.title.toLowerCase().contains(q) ||
        n.content.toLowerCase().contains(q)
      ).toList();
    }
    switch (_sortMode) {
      case 'oldest':
        notes.sort((a, b) => a.sortDate.compareTo(b.sortDate));
        break;
      case 'az':
        notes.sort((a, b) => a.title.toLowerCase().compareTo(b.title.toLowerCase()));
        break;
      case 'za':
        notes.sort((a, b) => b.title.toLowerCase().compareTo(a.title.toLowerCase()));
        break;
      case 'newest':
      default:
        notes.sort((a, b) => b.sortDate.compareTo(a.sortDate));
        break;
    }
    // Stable sort: pinned notes first
    final pinnedNotes = notes.where((n) => n.isPinned).toList();
    final unpinnedNotes = notes.where((n) => !n.isPinned).toList();
    notes = [...pinnedNotes, ...unpinnedNotes];
    return notes;
  }

  Map<String, FolderStyle> get _visibleFolders {
    final visible = Map<String, FolderStyle>.from(_folders);
    if (!_settings.showPrivateFolder) {
      visible.remove(tr('private_folder'));
    }
    return visible;
  }

  Future<void> _onFolderTap(String folder) async {
    final folderStyle = _folders[folder];
    final isPrivateFolder = folder == tr('private_folder') || (folderStyle?.isPrivate ?? false);
    final isCycleDiaryFolder = folder == 'Diario del Ciclo';

    if (isPrivateFolder || isCycleDiaryFolder) {
      // Reload settings from DB to pick up any biometric changes
      final freshSettings = await NoteProSettings.load();
      if (!mounted) return;
      setState(() => _settings = freshSettings);

      if (_settings.securityPin == null) {
        _showCreatePinDialog(onSuccess: () {
          setState(() {
            _privateUnlocked = true;
            _selectedFolder = folder;
          });
        });
      } else if (_settings.biometricEnabled) {
        _authenticateWithBiometric(onSuccess: () {
          setState(() {
            _privateUnlocked = true;
            _selectedFolder = folder;
          });
        });
      } else {
        _showEnterPinDialog(onSuccess: () {
          setState(() {
            _privateUnlocked = true;
            _selectedFolder = folder;
          });
        });
      }
    } else {
      setState(() {
        _selectedFolder = folder;
        _privateUnlocked = false;
      });
    }
  }

  Future<void> _authenticateWithBiometric({required VoidCallback onSuccess}) async {
    final localAuth = LocalAuthentication();
    try {
      final didAuthenticate = await localAuth.authenticate(
        localizedReason: tr('biometric_reason'),
        options: const AuthenticationOptions(
          stickyAuth: true,
          biometricOnly: false,
        ),
      );
      if (didAuthenticate) {
        onSuccess();
      } else {
        // Biometric cancelled/failed → fallback to PIN
        _showEnterPinDialog(onSuccess: onSuccess);
      }
    } catch (_) {
      // Biometric error → fallback to PIN
      _showEnterPinDialog(onSuccess: onSuccess);
    }
  }

  void _showEnterPinDialog({required VoidCallback onSuccess}) {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('enter_pin')),
        content: TextField(
          controller: controller,
          obscureText: true,
          keyboardType: TextInputType.number,
          maxLength: 4,
          decoration: InputDecoration(hintText: tr('pin_exactly_4')),
          autofocus: true,
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () {
              if (controller.text == _settings.securityPin) {
                Navigator.pop(ctx);
                onSuccess();
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(tr('wrong_pin')),
                    behavior: SnackBarBehavior.floating,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  ),
                );
              }
            },
            child: Text(tr('confirm')),
          ),
        ],
      ),
    );
  }

  void _showCreatePinDialog({required VoidCallback onSuccess}) {
    final pinController = TextEditingController();
    final confirmController = TextEditingController();
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('set_pin')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(tr('pin_exactly_4'), style: TextStyle(
              fontSize: 13,
              color: Theme.of(ctx).colorScheme.onSurfaceVariant,
            )),
            const SizedBox(height: 12),
            TextField(
              controller: pinController,
              obscureText: true,
              keyboardType: TextInputType.number,
              maxLength: 4,
              decoration: const InputDecoration(labelText: 'PIN'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: confirmController,
              obscureText: true,
              keyboardType: TextInputType.number,
              maxLength: 4,
              decoration: InputDecoration(labelText: tr('confirm')),
            ),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () {
              if (pinController.text.length == 4 && pinController.text == confirmController.text) {
                final newSettings = _settings.copyWith(securityPin: pinController.text);
                newSettings.save();
                setState(() => _settings = newSettings);
                Navigator.pop(ctx);
                _proposeEnableBiometric();
                onSuccess();
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(pinController.text.length != 4
                        ? tr('pin_exactly_4')
                        : tr('wrong_pin')),
                    behavior: SnackBarBehavior.floating,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  ),
                );
              }
            },
            child: Text(tr('create')),
          ),
        ],
      ),
    );
  }

  Future<void> _proposeEnableBiometric() async {
    final localAuth = LocalAuthentication();
    final canAuth = await localAuth.canCheckBiometrics || await localAuth.isDeviceSupported();
    if (!canAuth || !mounted) return;

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        icon: const Icon(Icons.fingerprint, size: 48),
        title: Text(tr('enable_biometric')),
        content: Text(tr('biometric_desc')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: Text(tr('no_thanks')),
          ),
          FilledButton(
            onPressed: () {
              final newSettings = _settings.copyWith(biometricEnabled: true);
              newSettings.save();
              setState(() => _settings = newSettings);
              Navigator.pop(ctx);
            },
            child: Text(tr('enable')),
          ),
        ],
      ),
    );
  }

  void _showFolderOptionsSheet(String folderName) {
    final colorScheme = Theme.of(context).colorScheme;
    final isPrivate = folderName == tr('private_folder');
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (ctx) => SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(width: 40, height: 4, decoration: BoxDecoration(color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3), borderRadius: BorderRadius.circular(2))),
              const SizedBox(height: 20),
              Text(tr('folder_options'), style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              Text(folderName, style: TextStyle(color: colorScheme.onSurfaceVariant)),
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: FilledButton.icon(
                  onPressed: () {
                    Navigator.pop(ctx);
                    _showEditFolderDialog(folderName);
                  },
                  icon: const Icon(Icons.edit),
                  label: Text(tr('edit_folder')),
                  style: FilledButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  ),
                ),
              ),
              if (!isPrivate) ...[
                const SizedBox(height: 12),
                SizedBox(
                  width: double.infinity,
                  child: OutlinedButton.icon(
                    onPressed: () {
                      Navigator.pop(ctx);
                      _showDeleteFolderDialog(folderName);
                    },
                    icon: const Icon(Icons.delete_outline),
                    label: Text(tr('delete')),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: colorScheme.error,
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  void _showEditFolderDialog(String folderName) async {
    final style = _folders[folderName];
    if (style == null) return;
    final isBuiltInName = !style.isCustom && folderName != tr('private_folder');
    final nameController = TextEditingController(text: folderName);
    IconData selectedIcon = style.icon;
    Color selectedColor = style.color;
    bool isPrivate = style.isPrivate || folderName == tr('private_folder');
    String? selectedEmoji = style.emojiIcon;

    if (!mounted) return;
    showDialog(
      context: context,
      builder: (ctx) => StatefulBuilder(
        builder: (ctx, setDialogState) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('edit_folder')),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                TextField(
                  controller: nameController,
                  enabled: !isBuiltInName,
                  decoration: InputDecoration(
                    labelText: tr('folder_name'),
                    hintText: tr('folder_name'),
                  ),
                ),
                const SizedBox(height: 16),
                Text(tr('image'), style: const TextStyle(fontWeight: FontWeight.w600)),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    ..._availableIcons.map((icon) {
                      final isSelected = selectedEmoji == null && selectedIcon == icon;
                      return GestureDetector(
                        onTap: () => setDialogState(() { selectedIcon = icon; selectedEmoji = null; }),
                        child: Container(
                          width: 40,
                          height: 40,
                          decoration: BoxDecoration(
                            color: isSelected ? selectedColor.withValues(alpha: 0.2) : Colors.transparent,
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(
                              color: isSelected ? selectedColor : Colors.grey.withValues(alpha: 0.3),
                              width: isSelected ? 2 : 1,
                            ),
                          ),
                          child: Icon(icon, size: 22, color: isSelected ? selectedColor : Colors.grey),
                        ),
                      );
                    }),
                    // Emoji picker button
                    GestureDetector(
                      onTap: () async {
                        final emoji = await _showEmojiPickerDialog();
                        if (emoji != null) {
                          setDialogState(() => selectedEmoji = emoji);
                        }
                      },
                      child: Container(
                        width: 40,
                        height: 40,
                        decoration: BoxDecoration(
                          color: selectedEmoji != null ? selectedColor.withValues(alpha: 0.2) : Colors.transparent,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(
                            color: selectedEmoji != null ? selectedColor : Colors.grey.withValues(alpha: 0.3),
                            width: selectedEmoji != null ? 2 : 1,
                          ),
                        ),
                        child: Center(
                          child: selectedEmoji != null
                              ? Text(selectedEmoji!, style: const TextStyle(fontSize: 22))
                              : const Text('😀', style: TextStyle(fontSize: 18)),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(tr('color'), style: const TextStyle(fontWeight: FontWeight.w600)),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    ..._availableColors.map((color) {
                      final isSelected = selectedColor == color;
                      return GestureDetector(
                        onTap: () => setDialogState(() => selectedColor = color),
                        child: Container(
                          width: 36,
                          height: 36,
                          decoration: BoxDecoration(
                            color: color,
                            shape: BoxShape.circle,
                            border: Border.all(
                              color: isSelected ? Colors.white : Colors.transparent,
                              width: 3,
                            ),
                            boxShadow: isSelected
                                ? [BoxShadow(color: color.withValues(alpha: 0.5), blurRadius: 8)]
                                : null,
                          ),
                          child: isSelected ? const Icon(Icons.check, color: Colors.white, size: 18) : null,
                        ),
                      );
                    }),
                    GestureDetector(
                      onTap: () {
                        showDialog(
                          context: ctx,
                          builder: (_) => _ColorPickerDialog(
                            isBackground: false,
                            quickColors: const [],
                            colorScheme: Theme.of(ctx).colorScheme,
                            onColorSelected: (color) {
                              setDialogState(() => selectedColor = color);
                              Navigator.pop(ctx);
                            },
                            onReset: () => Navigator.pop(ctx),
                          ),
                        );
                      },
                      child: Container(
                        width: 36,
                        height: 36,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          gradient: const SweepGradient(
                            colors: [Colors.red, Colors.yellow, Colors.green, Colors.cyan, Colors.blue, Colors.purple, Colors.red],
                          ),
                          border: Border.all(
                            color: !_availableColors.contains(selectedColor) ? Colors.white : Colors.transparent,
                            width: 3,
                          ),
                        ),
                        child: !_availableColors.contains(selectedColor)
                            ? const Icon(Icons.check, color: Colors.white, size: 18)
                            : const Icon(Icons.colorize, color: Colors.white, size: 16),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                if (folderName != tr('private_folder'))
                  SwitchListTile(
                    contentPadding: EdgeInsets.zero,
                    title: Text(tr('make_private')),
                    subtitle: Text(tr('folder_is_private')),
                    secondary: const Icon(Icons.lock_outline),
                    value: isPrivate,
                    onChanged: (v) => setDialogState(() => isPrivate = v),
                  ),
              ],
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
            FilledButton(
              onPressed: () async {
                final newName = nameController.text.trim();
                if (newName.isEmpty) return;
                Navigator.pop(ctx);

                final oldName = folderName;
                final newStyle = FolderStyle(
                  selectedIcon,
                  selectedColor,
                  isCustom: true,
                  isShared: style.isShared,
                  isPrivate: isPrivate,
                  sharedEmails: style.sharedEmails,
                  emojiIcon: selectedEmoji,
                );

                // If name changed, rename folder and move notes
                if (newName != oldName) {
                  for (int i = 0; i < _proNotes.length; i++) {
                    if (_proNotes[i].folder == oldName) {
                      _proNotes[i] = ProNote(
                        id: _proNotes[i].id,
                        title: _proNotes[i].title,
                        content: _proNotes[i].content,
                        contentDelta: _proNotes[i].contentDelta,
                        headerText: _proNotes[i].headerText,
                        footerText: _proNotes[i].footerText,
                        templatePreset: _proNotes[i].templatePreset,
                        createdAt: _proNotes[i].createdAt,
                        folder: newName,
                        linkedDate: _proNotes[i].linkedDate,
                      );
                    }
                  }
                  await _saveNotes();
                  if (!mounted) return;
                  setState(() {
                    _folders.remove(oldName);
                    _folders[newName] = newStyle;
                    if (_selectedFolder == oldName) _selectedFolder = newName;
                  });
                  await DatabaseHelper().deleteFolder(oldName);
                } else {
                  setState(() {
                    _folders[folderName] = newStyle;
                  });
                }
                await _saveCustomFolders();
              },
              child: Text(tr('save')),
            ),
          ],
        ),
      ),
    );
  }

  void _showDeleteFolderDialog(String folderName) {
    final colorScheme = Theme.of(context).colorScheme;
    final count = _proNotes.where((n) => n.folder == folderName).length;
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('confirm_delete')),
        content: Text(
          count > 0
              ? '${tr('delete_folder_confirm')} "$folderName"?\n${tr('notes_moved_to_general').replaceAll('{n}', '$count')}'
              : '${tr('delete_folder_confirm')} "$folderName"?',
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () async {
              Navigator.pop(ctx);
              // Move notes to "Generale"
              for (int i = 0; i < _proNotes.length; i++) {
                if (_proNotes[i].folder == folderName) {
                  final updated = ProNote(
                    id: _proNotes[i].id,
                    title: _proNotes[i].title,
                    content: _proNotes[i].content,
                    contentDelta: _proNotes[i].contentDelta,
                    headerText: _proNotes[i].headerText,
                    footerText: _proNotes[i].footerText,
                    templatePreset: _proNotes[i].templatePreset,
                    createdAt: _proNotes[i].createdAt,
                    folder: 'Generale',
                    linkedDate: _proNotes[i].linkedDate,
                  );
                  _proNotes[i] = updated;
                }
              }
              await _saveNotes();
              if (!mounted) return;
              setState(() {
                _folders.remove(folderName);
                if (_selectedFolder == folderName) _selectedFolder = tr('all_items');
                _showFolderSidebar = false;
              });
              await DatabaseHelper().deleteFolder(folderName);
              await _saveCustomFolders();
            },
            style: FilledButton.styleFrom(backgroundColor: colorScheme.error),
            child: Text(tr('delete')),
          ),
        ],
      ),
    );
  }

  Future<String?> _showEmojiPickerDialog() async {
    final emojiController = TextEditingController();
    return showDialog<String>(
      context: context,
      builder: (emojiCtx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text(tr('emoji_icon')),
        content: TextField(
          controller: emojiController,
          autofocus: true,
          textAlign: TextAlign.center,
          style: const TextStyle(fontSize: 32),
          decoration: InputDecoration(
            hintText: '😀',
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
          ),
          onChanged: (val) {
            if (val.isNotEmpty) {
              final chars = val.characters;
              if (chars.isNotEmpty) {
                emojiController.text = chars.last;
                emojiController.selection = TextSelection.fromPosition(TextPosition(offset: emojiController.text.length));
              }
            }
          },
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(emojiCtx), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () {
              if (emojiController.text.isNotEmpty) {
                Navigator.pop(emojiCtx, emojiController.text);
              } else {
                Navigator.pop(emojiCtx);
              }
            },
            child: Text(tr('save')),
          ),
        ],
      ),
    );
  }

  void _showCreateFolderDialog() async {
    final nameController = TextEditingController();
    IconData selectedIcon = Icons.folder;
    Color selectedColor = Colors.blue;
    bool isShared = false;
    bool isPrivate = false;
    String? selectedEmoji;
    final emailController = TextEditingController();
    List<String> sharedEmails = [];
    final profile = await DatabaseHelper().getProfile();
    final friends = profile?.friends ?? <String>[];
    List<String> selectedFriends = [];

    if (!mounted) return;
    showDialog(
      context: context,
      builder: (ctx) => StatefulBuilder(
        builder: (ctx, setDialogState) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('new_folder')),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                TextField(
                  controller: nameController,
                  decoration: InputDecoration(
                    labelText: tr('folder_name'),
                    hintText: tr('folder_name'),
                  ),
                ),
                const SizedBox(height: 16),
                Text(tr('image'), style: const TextStyle(fontWeight: FontWeight.w600)),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    ..._availableIcons.map((icon) {
                      final isSelected = selectedEmoji == null && selectedIcon == icon;
                      return GestureDetector(
                        onTap: () => setDialogState(() { selectedIcon = icon; selectedEmoji = null; }),
                        child: Container(
                          width: 40,
                          height: 40,
                          decoration: BoxDecoration(
                            color: isSelected ? selectedColor.withValues(alpha: 0.2) : Colors.transparent,
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(
                              color: isSelected ? selectedColor : Colors.grey.withValues(alpha: 0.3),
                              width: isSelected ? 2 : 1,
                            ),
                          ),
                          child: Icon(icon, size: 22, color: isSelected ? selectedColor : Colors.grey),
                        ),
                      );
                    }),
                    // Emoji picker button
                    GestureDetector(
                      onTap: () async {
                        final emoji = await _showEmojiPickerDialog();
                        if (emoji != null) {
                          setDialogState(() => selectedEmoji = emoji);
                        }
                      },
                      child: Container(
                        width: 40,
                        height: 40,
                        decoration: BoxDecoration(
                          color: selectedEmoji != null ? selectedColor.withValues(alpha: 0.2) : Colors.transparent,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(
                            color: selectedEmoji != null ? selectedColor : Colors.grey.withValues(alpha: 0.3),
                            width: selectedEmoji != null ? 2 : 1,
                          ),
                        ),
                        child: Center(
                          child: selectedEmoji != null
                              ? Text(selectedEmoji!, style: const TextStyle(fontSize: 22))
                              : const Text('😀', style: TextStyle(fontSize: 18)),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(tr('color'), style: const TextStyle(fontWeight: FontWeight.w600)),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    ..._availableColors.map((color) {
                      final isSelected = selectedColor == color;
                      return GestureDetector(
                        onTap: () => setDialogState(() => selectedColor = color),
                        child: Container(
                          width: 36,
                          height: 36,
                          decoration: BoxDecoration(
                            color: color,
                            shape: BoxShape.circle,
                            border: Border.all(
                              color: isSelected ? Colors.white : Colors.transparent,
                              width: 3,
                            ),
                            boxShadow: isSelected
                                ? [BoxShadow(color: color.withValues(alpha: 0.5), blurRadius: 8)]
                                : null,
                          ),
                          child: isSelected ? const Icon(Icons.check, color: Colors.white, size: 18) : null,
                        ),
                      );
                    }),
                    // Custom color picker
                    GestureDetector(
                      onTap: () {
                        showDialog(
                          context: ctx,
                          builder: (_) => _ColorPickerDialog(
                            isBackground: false,
                            quickColors: const [],
                            colorScheme: Theme.of(ctx).colorScheme,
                            onColorSelected: (color) {
                              setDialogState(() => selectedColor = color);
                              Navigator.pop(ctx);
                            },
                            onReset: () => Navigator.pop(ctx),
                          ),
                        );
                      },
                      child: Container(
                        width: 36,
                        height: 36,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          gradient: const SweepGradient(
                            colors: [Colors.red, Colors.yellow, Colors.green, Colors.cyan, Colors.blue, Colors.purple, Colors.red],
                          ),
                          border: Border.all(
                            color: !_availableColors.contains(selectedColor) ? Colors.white : Colors.transparent,
                            width: 3,
                          ),
                        ),
                        child: !_availableColors.contains(selectedColor)
                            ? const Icon(Icons.check, color: Colors.white, size: 18)
                            : const Icon(Icons.colorize, color: Colors.white, size: 16),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                SwitchListTile(
                  contentPadding: EdgeInsets.zero,
                  title: Text(tr('make_private')),
                  subtitle: Text(tr('folder_is_private')),
                  secondary: const Icon(Icons.lock_outline),
                  value: isPrivate,
                  onChanged: (v) => setDialogState(() => isPrivate = v),
                ),
                SwitchListTile(
                  contentPadding: EdgeInsets.zero,
                  title: Text(tr('share_with')),
                  subtitle: Text(tr('add_person')),
                  value: isShared,
                  onChanged: (v) => setDialogState(() => isShared = v),
                ),
                if (isShared) ...[
                  Row(
                    children: [
                      Expanded(
                        child: TextField(
                          controller: emailController,
                          decoration: InputDecoration(
                            hintText: tr('email'),
                            prefixIcon: const Icon(Icons.email, size: 20),
                          ),
                          keyboardType: TextInputType.emailAddress,
                        ),
                      ),
                      const SizedBox(width: 8),
                      IconButton(
                        icon: const Icon(Icons.add_circle),
                        onPressed: () {
                          if (emailController.text.contains('@')) {
                            setDialogState(() {
                              sharedEmails.add(emailController.text);
                              emailController.clear();
                            });
                          }
                        },
                      ),
                    ],
                  ),
                  if (sharedEmails.isNotEmpty) ...[
                    const SizedBox(height: 8),
                    Wrap(
                      spacing: 4,
                      children: sharedEmails.map((e) => Chip(
                        label: Text(e, style: const TextStyle(fontSize: 12)),
                        deleteIcon: const Icon(Icons.close, size: 16),
                        onDeleted: () => setDialogState(() => sharedEmails.remove(e)),
                      )).toList(),
                    ),
                  ],
                  if (friends.isNotEmpty) ...[
                    const SizedBox(height: 12),
                    Text(tr('friends'), style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 13)),
                    const SizedBox(height: 4),
                    ...friends.map((friend) => CheckboxListTile(
                      contentPadding: EdgeInsets.zero,
                      dense: true,
                      value: selectedFriends.contains(friend),
                      onChanged: (v) {
                        setDialogState(() {
                          if (v == true) {
                            selectedFriends.add(friend);
                          } else {
                            selectedFriends.remove(friend);
                          }
                        });
                      },
                      title: Text(friend, style: const TextStyle(fontSize: 13)),
                      secondary: const Icon(Icons.person_outline, size: 20),
                      controlAffinity: ListTileControlAffinity.leading,
                    )),
                  ],
                ],
              ],
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(ctx), child: Text(tr('cancel'))),
            FilledButton(
              onPressed: () {
                final name = nameController.text.trim();
                if (name.isNotEmpty && !_folders.containsKey(name)) {
                  final allShared = [...sharedEmails, ...selectedFriends];
                  setState(() {
                    _folders[name] = FolderStyle(
                      selectedIcon,
                      selectedColor,
                      isCustom: true,
                      isShared: isShared,
                      isPrivate: isPrivate,
                      sharedEmails: allShared,
                      emojiIcon: selectedEmoji,
                    );
                  });
                  _saveCustomFolders();
                  Navigator.pop(ctx);
                }
              },
              child: Text(tr('create')),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final visibleFolders = _visibleFolders;

    final accentColor = _sectionAccent(context, 0);

    return Scaffold(
      body: Stack(
        children: [
          // MAIN CONTENT (full width)
          Column(
            children: [
              // SELECTION BAR
              if (_selectionMode)
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  color: accentColor.withValues(alpha: 0.08),
                  child: Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.close),
                        onPressed: () => setState(() { _selectionMode = false; _selectedNoteIds.clear(); }),
                      ),
                      Text(
                        '${_selectedNoteIds.length} ${tr('selected')}',
                        style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600, color: accentColor),
                      ),
                      const Spacer(),
                      TextButton(
                        onPressed: () {
                          setState(() {
                            if (_selectedNoteIds.length == _filteredNotes.length) {
                              _selectedNoteIds.clear();
                            } else {
                              _selectedNoteIds = _filteredNotes.where((n) => n.id != null).map((n) => n.id!).toSet();
                            }
                          });
                        },
                        child: Text(_selectedNoteIds.length == _filteredNotes.length ? tr('deselect_all') : tr('select_all')),
                      ),
                      IconButton(
                        onPressed: _selectedNoteIds.isEmpty ? null : () => _deleteSelectedNotes(),
                        icon: Icon(Icons.delete_outline, color: _selectedNoteIds.isEmpty ? null : colorScheme.error),
                        tooltip: tr('delete'),
                      ),
                      PopupMenuButton<String>(
                        icon: const Icon(Icons.more_vert),
                        enabled: _selectedNoteIds.isNotEmpty,
                        onSelected: (v) {
                          if (v == 'share') _shareSelectedNotes();
                          if (v == 'pdf') _exportSelectedNotePdf();
                          if (v == 'folder') _changeSelectedFolder();
                        },
                        itemBuilder: (_) => [
                          PopupMenuItem(value: 'share', child: Row(children: [const Icon(Icons.share, size: 20), const SizedBox(width: 12), Text(tr('share'))])),
                          if (_selectedNoteIds.length == 1)
                            PopupMenuItem(value: 'pdf', child: Row(children: [const Icon(Icons.picture_as_pdf, size: 20), const SizedBox(width: 12), Text(tr('pdf'))])),
                          PopupMenuItem(value: 'folder', child: Row(children: [const Icon(Icons.folder_outlined, size: 20), const SizedBox(width: 12), Text(tr('change_folder'))])),
                        ],
                      ),
                    ],
                  ),
                ),
              // SEARCH BAR + VIEW TOGGLE
              if (!_selectionMode)
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 8, 8, 4),
                  child: Row(
                    children: [
                      // Folder sidebar toggle
                      Padding(
                        padding: const EdgeInsets.only(right: 8),
                        child: Badge(
                          isLabelVisible: _cycleDiaryBadge,
                          backgroundColor: Colors.red,
                          smallSize: 8,
                          child: () {
                            final folderColor = _selectedFolder != tr('all_items')
                                ? (_folders[_selectedFolder]?.color ?? accentColor)
                                : colorScheme.onSurfaceVariant;
                            final isActive = _selectedFolder != tr('all_items');
                            return AnimatedContainer(
                              duration: const Duration(milliseconds: 300),
                              curve: Curves.easeInOut,
                              width: 40,
                              height: 40,
                              decoration: BoxDecoration(
                                color: isActive ? folderColor.withValues(alpha: 0.12) : colorScheme.surfaceContainerLowest,
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: Material(
                                color: Colors.transparent,
                                child: InkWell(
                                  borderRadius: BorderRadius.circular(12),
                                  onTap: () => setState(() => _showFolderSidebar = !_showFolderSidebar),
                                  child: Center(
                                    child: Icon(
                                      isActive ? (_folders[_selectedFolder]?.icon ?? Icons.folder) : Icons.folder_outlined,
                                      size: 20,
                                      color: isActive ? folderColor : colorScheme.onSurfaceVariant,
                                    ),
                                  ),
                                ),
                              ),
                            );
                          }(),
                        ),
                      ),
                      Expanded(
                        child: TextField(
                          controller: _searchController,
                          decoration: InputDecoration(
                            hintText: tr('search_notes'),
                            prefixIcon: const Icon(Icons.search, size: 20),
                            suffixIcon: _searchQuery.isNotEmpty
                                ? IconButton(
                                    icon: const Icon(Icons.clear, size: 18),
                                    onPressed: () {
                                      _searchController.clear();
                                      setState(() => _searchQuery = '');
                                    },
                                  )
                                : null,
                            isDense: true,
                            contentPadding: const EdgeInsets.symmetric(vertical: 10),
                          ),
                          onChanged: (value) => setState(() => _searchQuery = value),
                        ),
                      ),
                      const SizedBox(width: 4),
                      PopupMenuButton<String>(
                        icon: const Icon(Icons.sort, size: 22),
                        tooltip: tr('sort'),
                        onSelected: (mode) => _saveSortMode(mode),
                        itemBuilder: (context) => [
                          PopupMenuItem(value: 'newest', child: Text(tr('newest_first'))),
                          PopupMenuItem(value: 'oldest', child: Text(tr('oldest_first'))),
                          PopupMenuItem(value: 'az', child: Text(tr('alphabetical_az'))),
                          PopupMenuItem(value: 'za', child: Text(tr('alphabetical_za'))),
                        ],
                      ),
                      IconButton(
                        icon: Icon(_isGridView ? Icons.view_list : Icons.grid_view, size: 22),
                        tooltip: _isGridView ? tr('list_view_tooltip') : tr('grid_view_tooltip'),
                        onPressed: _toggleViewMode,
                      ),
                    ],
                  ),
                ),
                // NOTE LIST / GRID
                Expanded(
                  child: _filteredNotes.isEmpty
                      ? Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(Icons.note_outlined, size: 64, color: colorScheme.outlineVariant),
                              const SizedBox(height: 12),
                              Text(
                                _searchQuery.isNotEmpty
                                    ? '${tr('no_results_for')} "$_searchQuery"'
                                    : _selectedFolder == tr('all_items')
                                        ? tr('no_deep_notes')
                                        : '${tr('no_notes')} - $_selectedFolder',
                                style: TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w600,
                                  color: colorScheme.onSurfaceVariant,
                                ),
                              ),
                              if (_searchQuery.isEmpty) ...[
                                const SizedBox(height: 4),
                                Text(
                                  tr('create_first_note'),
                                  style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7)),
                                ),
                                const SizedBox(height: 16),
                                FilledButton.icon(
                                  onPressed: _createNewNote,
                                  icon: const Icon(Icons.add, size: 18),
                                  label: Text(tr('new_note')),
                                ),
                              ],
                            ],
                          ),
                        )
                      : _isGridView
                          ? GridView.builder(
                              padding: const EdgeInsets.fromLTRB(12, 8, 8, 12),
                              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                                crossAxisCount: MediaQuery.of(context).size.width > 840 ? 4 : MediaQuery.of(context).size.width > 600 ? 3 : 2,
                                crossAxisSpacing: 6,
                                mainAxisSpacing: 6,
                                childAspectRatio: 1.0,
                              ),
                              itemCount: _filteredNotes.length,
                              itemBuilder: (context, index) {
                                final note = _filteredNotes[index];
                                final folderColor = _folders[note.folder]?.color ?? Colors.grey;
                                final noteIndex = _proNotes.indexOf(note);
                                final isSelected = note.id != null && _selectedNoteIds.contains(note.id);
                                return GestureDetector(
                                  onTap: () {
                                    if (_selectionMode) {
                                      setState(() {
                                        if (note.id != null) {
                                          if (_selectedNoteIds.contains(note.id)) {
                                            _selectedNoteIds.remove(note.id);
                                            if (_selectedNoteIds.isEmpty) _selectionMode = false;
                                          } else {
                                            _selectedNoteIds.add(note.id!);
                                          }
                                        }
                                      });
                                    } else {
                                      _editNote(noteIndex);
                                    }
                                  },
                                  onLongPress: () {
                                    if (!_selectionMode && note.folder != tr('private_folder')) {
                                      setState(() {
                                        _selectionMode = true;
                                        if (note.id != null) _selectedNoteIds.add(note.id!);
                                      });
                                    }
                                  },
                                  child: AnimatedContainer(
                                    duration: const Duration(milliseconds: 200),
                                    margin: const EdgeInsets.all(2),
                                    decoration: BoxDecoration(
                                      color: isSelected ? accentColor.withValues(alpha: 0.08) : colorScheme.surfaceContainerLowest,
                                      borderRadius: BorderRadius.circular((_isYellowNoteTheme(context) || _isBlockNoteTheme(context)) ? 2 : 16),
                                      border: Border.all(
                                        color: isSelected ? accentColor : colorScheme.outlineVariant.withValues(alpha: 0.3),
                                        width: isSelected ? 2 : 1,
                                      ),
                                    ),
                                    child: Padding(
                                      padding: const EdgeInsets.all(10),
                                      child: Column(
                                        crossAxisAlignment: CrossAxisAlignment.start,
                                        children: [
                                          Row(
                                            children: [
                                              _folders[note.folder]?.buildIcon(size: 15, iconColor: folderColor) ?? Icon(Icons.folder, color: folderColor, size: 15),
                                              const SizedBox(width: 5),
                                              Expanded(
                                                child: Text(note.title,
                                                    maxLines: 1,
                                                    overflow: TextOverflow.ellipsis,
                                                    style: TextStyle(
                                                      fontWeight: FontWeight.w600,
                                                      fontSize: 13,
                                                      fontFamily: _themedFont(context),
                                                      color: _hasCustomTheme(context) ? _sectionAccent(context, 0) : colorScheme.onSurface,
                                                    )),
                                              ),
                                              if (note.isPinned)
                                                Padding(
                                                  padding: const EdgeInsets.only(right: 2),
                                                  child: Icon(Icons.push_pin, size: 14, color: accentColor),
                                                ),
                                              if (!_selectionMode && note.id != null)
                                                SizedBox(
                                                  width: 24,
                                                  height: 24,
                                                  child: PopupMenuButton<String>(
                                                    icon: Icon(Icons.more_vert, size: 16, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.5)),
                                                    padding: EdgeInsets.zero,
                                                    iconSize: 16,
                                                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                                                    onSelected: (value) {
                                                      switch (value) {
                                                        case 'pin':
                                                          _toggleProNotePin(note);
                                                          break;
                                                        case 'share':
                                                          SharePlus.instance.share(ShareParams(text: '${note.title}\n\n${note.content}', subject: note.title));
                                                          break;
                                                        case 'pdf':
                                                          _exportNotePdfById(note.id!);
                                                          break;
                                                        case 'move':
                                                          _moveNoteById(note.id!);
                                                          break;
                                                        case 'delete':
                                                          _deleteNoteById(note.id!);
                                                          break;
                                                      }
                                                    },
                                                    itemBuilder: (ctx) => [
                                                      PopupMenuItem(value: 'pin', child: Row(children: [Icon(note.isPinned ? Icons.push_pin : Icons.push_pin_outlined, size: 20, color: accentColor), const SizedBox(width: 12), Text(note.isPinned ? tr('unpin') : tr('pin'))])),
                                                      PopupMenuItem(value: 'share', child: Row(children: [Icon(Icons.share, size: 20, color: colorScheme.onSurfaceVariant), const SizedBox(width: 12), Text(tr('share'))])),
                                                      PopupMenuItem(value: 'pdf', child: Row(children: [Icon(Icons.picture_as_pdf, size: 20, color: colorScheme.onSurfaceVariant), const SizedBox(width: 12), Text(tr('create_pdf'))])),
                                                      PopupMenuItem(value: 'move', child: Row(children: [Icon(Icons.folder_outlined, size: 20, color: colorScheme.onSurfaceVariant), const SizedBox(width: 12), Text(tr('change_folder'))])),
                                                      PopupMenuItem(value: 'delete', child: Row(children: [Icon(Icons.delete_outline, size: 20, color: colorScheme.error), const SizedBox(width: 12), Text(tr('delete'), style: TextStyle(color: colorScheme.error))])),
                                                    ],
                                                  ),
                                                ),
                                            ],
                                          ),
                                          const SizedBox(height: 6),
                                          Expanded(
                                            child: Text(note.content,
                                                maxLines: 5,
                                                overflow: TextOverflow.ellipsis,
                                                style: TextStyle(
                                                  color: colorScheme.onSurfaceVariant,
                                                  fontSize: 11,
                                                  height: 1.4,
                                                )),
                                          ),
                                          const SizedBox(height: 4),
                                          Row(
                                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                            children: [
                                              Container(
                                                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                                                decoration: BoxDecoration(
                                                  color: folderColor.withValues(alpha: 0.08),
                                                  borderRadius: BorderRadius.circular(8),
                                                ),
                                                child: Text(folderLabel(note.folder),
                                                    style: TextStyle(fontSize: 9, color: folderColor, fontWeight: FontWeight.w600)),
                                              ),
                                              const Spacer(),
                                              Text(
                                                '${note.createdAt.day.toString().padLeft(2, '0')}/${note.createdAt.month.toString().padLeft(2, '0')}/${note.createdAt.year}',
                                                style: TextStyle(fontSize: 9, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.5)),
                                              ),
                                            ],
                                          ),
                                        ],
                                      ),
                                    ),
                                  ),
                                );
                              },
                            )
                          : ListView.builder(
                              padding: const EdgeInsets.fromLTRB(16, 8, 0, 16),
                              itemCount: _filteredNotes.length,
                              itemBuilder: (context, index) {
                                final note = _filteredNotes[index];
                                final folderColor = _folders[note.folder]?.color ?? Colors.grey;
                                final noteIndex = _proNotes.indexOf(note);
                                final isSelected = note.id != null && _selectedNoteIds.contains(note.id);
                                return _SlideInItem(
                                  index: index,
                                  child: GestureDetector(
                                    onTap: () {
                                      if (_selectionMode) {
                                        setState(() {
                                          if (note.id != null) {
                                            if (_selectedNoteIds.contains(note.id)) {
                                              _selectedNoteIds.remove(note.id);
                                              if (_selectedNoteIds.isEmpty) _selectionMode = false;
                                            } else {
                                              _selectedNoteIds.add(note.id!);
                                            }
                                          }
                                        });
                                      } else {
                                        _editNote(noteIndex);
                                      }
                                    },
                                    onLongPress: () {
                                      if (!_selectionMode && note.folder != tr('private_folder')) {
                                        setState(() {
                                          _selectionMode = true;
                                          if (note.id != null) _selectedNoteIds.add(note.id!);
                                        });
                                      }
                                    },
                                    child: AnimatedContainer(
                                        duration: const Duration(milliseconds: 200),
                                        margin: const EdgeInsets.only(bottom: 8),
                                        padding: const EdgeInsets.all(16),
                                        decoration: BoxDecoration(
                                          color: isSelected ? accentColor.withValues(alpha: 0.08) : colorScheme.surfaceContainerLowest,
                                          borderRadius: BorderRadius.circular((_isYellowNoteTheme(context) || _isBlockNoteTheme(context)) ? 2 : 16),
                                          border: Border.all(
                                            color: isSelected ? accentColor : colorScheme.outlineVariant.withValues(alpha: 0.3),
                                            width: isSelected ? 2 : 1,
                                          ),
                                        ),
                                        child: Row(
                                          children: [
                                            CircleAvatar(
                                              radius: 22,
                                              backgroundColor: folderColor.withValues(alpha: 0.12),
                                              child: _folders[note.folder]?.buildIcon(size: 22, iconColor: folderColor) ?? Icon(Icons.folder, color: folderColor, size: 22),
                                            ),
                                            const SizedBox(width: 16),
                                            Expanded(
                                              child: Column(
                                                crossAxisAlignment: CrossAxisAlignment.start,
                                                children: [
                                                  Row(
                                                    children: [
                                                      Expanded(
                                                        child: Text(note.title,
                                                            maxLines: 1,
                                                            overflow: TextOverflow.ellipsis,
                                                            style: TextStyle(fontWeight: FontWeight.w600, fontSize: 16, fontFamily: _themedFont(context), color: _hasCustomTheme(context) ? _sectionAccent(context, 0) : null)),
                                                      ),
                                                      if (note.isPinned)
                                                        Padding(
                                                          padding: const EdgeInsets.only(left: 8),
                                                          child: Icon(Icons.push_pin, size: 14, color: accentColor),
                                                        ),
                                                      if (note.linkedDate != null)
                                                        Padding(
                                                          padding: const EdgeInsets.only(left: 8),
                                                          child: Icon(Icons.calendar_today, size: 14, color: colorScheme.primary),
                                                        ),
                                                    ],
                                                  ),
                                                  const SizedBox(height: 4),
                                                  Text(note.content, maxLines: 2, overflow: TextOverflow.ellipsis,
                                                      style: TextStyle(color: colorScheme.onSurfaceVariant, fontSize: 13)),
                                                  const SizedBox(height: 8),
                                                  Row(
                                                    children: [
                                                      Container(
                                                        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 3),
                                                        decoration: BoxDecoration(
                                                          color: folderColor.withValues(alpha: 0.1),
                                                          borderRadius: BorderRadius.circular(12),
                                                        ),
                                                        child: Row(
                                                          mainAxisSize: MainAxisSize.min,
                                                          children: [
                                                            _folders[note.folder]?.buildIcon(size: 12, iconColor: folderColor) ?? Icon(Icons.folder, size: 12, color: folderColor),
                                                            const SizedBox(width: 4),
                                                            Text(folderLabel(note.folder),
                                                                style: TextStyle(fontSize: 11, color: folderColor, fontWeight: FontWeight.w600)),
                                                          ],
                                                        ),
                                                      ),
                                                      if (note.linkedDate != null) ...[
                                                        const SizedBox(width: 8),
                                                        Text(
                                                          '${note.linkedDate!.day}/${note.linkedDate!.month}/${note.linkedDate!.year}',
                                                          style: TextStyle(fontSize: 11, color: colorScheme.primary),
                                                        ),
                                                      ],
                                                      const Spacer(),
                                                      Text(
                                                        '${tr('created_on')} ${note.createdAt.day.toString().padLeft(2, '0')}/${note.createdAt.month.toString().padLeft(2, '0')}/${note.createdAt.year}',
                                                        style: TextStyle(fontSize: 10, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.5)),
                                                      ),
                                                    ],
                                                  ),
                                                ],
                                              ),
                                            ),
                                            if (!_selectionMode && note.id != null)
                                              PopupMenuButton<String>(
                                                icon: Icon(Icons.more_vert, size: 20, color: colorScheme.onSurfaceVariant.withValues(alpha: 0.5)),
                                                padding: EdgeInsets.zero,
                                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                                                onSelected: (value) {
                                                  switch (value) {
                                                    case 'pin':
                                                      _toggleProNotePin(note);
                                                      break;
                                                    case 'share':
                                                      SharePlus.instance.share(ShareParams(text: '${note.title}\n\n${note.content}', subject: note.title));
                                                      break;
                                                    case 'pdf':
                                                      _exportNotePdfById(note.id!);
                                                      break;
                                                    case 'move':
                                                      _moveNoteById(note.id!);
                                                      break;
                                                    case 'delete':
                                                      _deleteNoteById(note.id!);
                                                      break;
                                                  }
                                                },
                                                itemBuilder: (ctx) => [
                                                  PopupMenuItem(value: 'pin', child: Row(children: [Icon(note.isPinned ? Icons.push_pin : Icons.push_pin_outlined, size: 20, color: accentColor), const SizedBox(width: 12), Text(note.isPinned ? tr('unpin') : tr('pin'))])),
                                                  PopupMenuItem(value: 'share', child: Row(children: [Icon(Icons.share, size: 20, color: colorScheme.onSurfaceVariant), const SizedBox(width: 12), Text(tr('share'))])),
                                                  PopupMenuItem(value: 'pdf', child: Row(children: [Icon(Icons.picture_as_pdf, size: 20, color: colorScheme.onSurfaceVariant), const SizedBox(width: 12), Text(tr('create_pdf'))])),
                                                  PopupMenuItem(value: 'move', child: Row(children: [Icon(Icons.folder_outlined, size: 20, color: colorScheme.onSurfaceVariant), const SizedBox(width: 12), Text(tr('change_folder'))])),
                                                  PopupMenuItem(value: 'delete', child: Row(children: [Icon(Icons.delete_outline, size: 20, color: colorScheme.error), const SizedBox(width: 12), Text(tr('delete'), style: TextStyle(color: colorScheme.error))])),
                                                ],
                                              ),
                                          ],
                                        ),
                                      ),
                                  ),
                                );
                              },
                            ),
                ),
              ],
          ),
          // OVERLAY FOLDER SIDEBAR
          if (_showFolderSidebar) ...[
            // Dark barrier
            Positioned.fill(
              child: GestureDetector(
                onTap: () => setState(() => _showFolderSidebar = false),
                child: AnimatedOpacity(
                  opacity: _showFolderSidebar ? 1.0 : 0.0,
                  duration: const Duration(milliseconds: 200),
                  child: Container(color: Colors.black26),
                ),
              ),
            ),
            // Dropdown panel (vertical drop from top)
            Positioned(
              left: 12, top: 56, right: 12,
              child: AnimatedSlide(
                offset: _showFolderSidebar ? Offset.zero : const Offset(0, -0.3),
                duration: const Duration(milliseconds: 350),
                curve: Curves.easeOutCubic,
                child: AnimatedOpacity(
                  opacity: _showFolderSidebar ? 1.0 : 0.0,
                  duration: const Duration(milliseconds: 250),
                  child: Container(
                    width: 220,
                    constraints: BoxConstraints(maxHeight: MediaQuery.of(context).size.height * 0.6),
                    decoration: BoxDecoration(
                      color: colorScheme.surfaceContainerLowest,
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(color: colorScheme.outlineVariant.withValues(alpha: 0.3)),
                      boxShadow: [BoxShadow(color: Colors.black.withValues(alpha: 0.15), blurRadius: 20, offset: const Offset(0, 4))],
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Padding(
                          padding: const EdgeInsets.fromLTRB(16, 12, 8, 8),
                          child: Row(
                            children: [
                              Icon(Icons.folder_outlined, size: 20, color: colorScheme.primary),
                              const SizedBox(width: 8),
                              Expanded(child: Text(tr('folders'), style: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold))),
                              IconButton(
                                icon: const Icon(Icons.close, size: 20),
                                onPressed: () => setState(() => _showFolderSidebar = false),
                                visualDensity: VisualDensity.compact,
                              ),
                            ],
                          ),
                        ),
                        const Divider(height: 1),
                        // "Tutte" item
                        ListTile(
                          dense: true,
                          leading: Icon(Icons.apps, size: 20, color: _selectedFolder == tr('all_items') ? colorScheme.primary : colorScheme.onSurfaceVariant),
                          title: Text(tr('all_items'), style: TextStyle(fontWeight: _selectedFolder == tr('all_items') ? FontWeight.w700 : FontWeight.normal, color: _selectedFolder == tr('all_items') ? colorScheme.primary : null)),
                          trailing: Text('${_proNotes.length}', style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                          selected: _selectedFolder == tr('all_items'),
                          selectedTileColor: colorScheme.primary.withValues(alpha: 0.08),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                          onTap: () => setState(() { _selectedFolder = tr('all_items'); _showFolderSidebar = false; }),
                        ),
                        const Divider(height: 1, indent: 16, endIndent: 16),
                        // Folder items
                        Flexible(
                          child: ListView(
                            shrinkWrap: true,
                            padding: const EdgeInsets.symmetric(vertical: 4),
                            children: visibleFolders.entries.map((entry) {
                              final isSelected = _selectedFolder == entry.key;
                              final count = _proNotes.where((n) => n.folder == entry.key).length;
                              final showDiaryBadge = entry.key == 'Diario del Ciclo' && _cycleDiaryBadge;
                              return ListTile(
                                dense: true,
                                leading: Badge(
                                  isLabelVisible: showDiaryBadge,
                                  backgroundColor: Colors.red,
                                  smallSize: 8,
                                  child: entry.value.buildIcon(size: 20, iconColor: isSelected ? entry.value.color : colorScheme.onSurfaceVariant),
                                ),
                                title: Text(folderLabel(entry.key), style: TextStyle(fontWeight: isSelected ? FontWeight.w700 : FontWeight.normal, color: isSelected ? entry.value.color : null)),
                                trailing: (entry.value.isPrivate || entry.key == tr('private_folder'))
                                    ? Row(mainAxisSize: MainAxisSize.min, children: [
                                        Icon(Icons.lock, size: 14, color: colorScheme.onSurfaceVariant),
                                        const SizedBox(width: 4),
                                        Text('$count', style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                                      ])
                                    : entry.key == 'Diario del Ciclo'
                                        ? Row(mainAxisSize: MainAxisSize.min, children: [
                                            Icon(Icons.lock, size: 14, color: colorScheme.onSurfaceVariant),
                                            const SizedBox(width: 4),
                                            Text('$count', style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                                          ])
                                        : Text('$count', style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant)),
                                selected: isSelected,
                                selectedTileColor: entry.value.color.withValues(alpha: 0.08),
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                onTap: () {
                                  _onFolderTap(entry.key);
                                  setState(() => _showFolderSidebar = false);
                                },
                                onLongPress: () => _showFolderOptionsSheet(entry.key),
                              );
                            }).toList(),
                          ),
                        ),
                        const Divider(height: 1, indent: 16, endIndent: 16),
                        ListTile(
                          dense: true,
                          leading: Icon(Icons.add_circle_outline, size: 20, color: colorScheme.primary),
                          title: Text(tr('new_folder'), style: TextStyle(color: colorScheme.primary)),
                          onTap: () { setState(() => _showFolderSidebar = false); _showCreateFolderDialog(); },
                        ),
                        const SizedBox(height: 8),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _createNewNote,
        child: const Icon(Icons.add),
      ),
    );
  }

  Future<void> _exportSelectedNotePdf() async {
    if (_selectedNoteIds.length != 1) return;
    final noteId = _selectedNoteIds.first;
    final idx = _proNotes.indexWhere((n) => n.id == noteId);
    if (idx == -1) return;
    final note = _proNotes[idx];

    // Detect images and text
    final (hasImages, hasText) = _analyzeContentDelta(note.contentDelta);
    bool photosFullPage = false;
    if (hasImages && hasText) {
      final choice = await showDialog<String>(
        context: context,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('photo_in_pdf')),
          content: Text(tr('photo_in_pdf_question')),
          actions: [
            OutlinedButton(
              onPressed: () => Navigator.pop(ctx, 'inline'),
              child: Text(tr('same_page')),
            ),
            const SizedBox(width: 8),
            FilledButton(
              onPressed: () => Navigator.pop(ctx, 'separate'),
              child: Text(tr('separate_page')),
            ),
          ],
        ),
      );
      if (choice == null) return;
      if (!mounted) return;
      photosFullPage = choice == 'separate';
    } else if (hasImages && !hasText) {
      photosFullPage = true;
    }

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => Center(child: Card(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 16),
              Text(tr('exporting_pdf')),
            ],
          ),
        ),
      )),
    );

    try {
      final pdfBytes = await generateNotePdfFromProNote(note, photosFullPage: photosFullPage);
      if (!mounted) return;
      Navigator.pop(context); // dismiss loading
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (_) => _PdfViewerPage(
            pdfBytes: pdfBytes,
            title: '${note.title}.pdf',
          ),
        ),
      );
    } catch (e) {
      if (!mounted) return;
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('error')}: $e'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  void _shareSelectedNotes() {
    final selectedNotes = _proNotes
        .where((n) => n.id != null && _selectedNoteIds.contains(n.id))
        .toList();
    if (selectedNotes.isEmpty) return;
    final text = selectedNotes.map((n) => '${n.title}\n\n${n.content}').join('\n\n---\n\n');
    SharePlus.instance.share(ShareParams(text: text, subject: selectedNotes.length == 1 ? selectedNotes.first.title : 'Deep Notes'));
  }

  Future<void> _deleteSelectedNotes() async {
    final count = _selectedNoteIds.length;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('delete_note_confirm')),
        content: Text('${tr('delete')} $count ${tr('selected')}?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () => Navigator.pop(ctx, true),
            style: FilledButton.styleFrom(backgroundColor: Theme.of(context).colorScheme.error),
            child: Text(tr('delete')),
          ),
        ],
      ),
    );
    if (confirmed != true || !mounted) return;
    final db = DatabaseHelper();
    final deletedNotes = <ProNote>[];
    final trashedIds = <int>[];
    for (final noteId in _selectedNoteIds) {
      final idx = _proNotes.indexWhere((n) => n.id == noteId);
      if (idx == -1) continue;
      final note = _proNotes[idx];
      deletedNotes.add(note);
      if (_settings.trashEnabled) {
        final tid = await db.insertTrashedNote(TrashedNote(
          type: 'pro',
          noteJson: note.toJson(),
          deletedAt: DateTime.now(),
        ));
        trashedIds.add(tid);
      } else {
        await ImageStorageHelper().deleteImageFile(note.imagePath);
      }
      await db.deleteProNote(noteId);
    }
    final deletedCount = deletedNotes.length;
    if (!mounted) return;
    setState(() {
      _selectionMode = false;
      _selectedNoteIds.clear();
    });
    await _loadNotes();
    if (!mounted) return;
    ScaffoldMessenger.of(context).clearSnackBars();
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text('${tr('notes_deleted')} ($deletedCount)'),
      action: SnackBarAction(
        label: tr('undo'),
        onPressed: () async {
          for (final note in deletedNotes) {
            await db.insertProNote(note);
          }
          for (final tid in trashedIds) {
            await db.deleteTrashedNote(tid);
          }
          _loadNotes();
        },
      ),
      behavior: SnackBarBehavior.floating,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    ));
  }

  Future<void> _changeSelectedFolder() async {
    final targetFolder = await showModalBottomSheet<String>(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (ctx) => Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(width: 40, height: 4, decoration: BoxDecoration(color: Colors.grey.shade300, borderRadius: BorderRadius.circular(2))),
            const SizedBox(height: 12),
            Text(tr('change_folder'), style: const TextStyle(fontSize: 15, fontWeight: FontWeight.w600)),
            const SizedBox(height: 8),
            ..._folders.entries.map((entry) => ListTile(
              leading: entry.value.buildIcon(size: 20, iconColor: entry.value.color),
              title: Text(folderLabel(entry.key)),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              onTap: () => Navigator.pop(ctx, entry.key),
            )),
          ],
        ),
      ),
    );
    if (targetFolder == null || !mounted) return;
    final db = DatabaseHelper();
    for (final noteId in _selectedNoteIds) {
      final idx = _proNotes.indexWhere((n) => n.id == noteId);
      if (idx == -1) continue;
      final note = _proNotes[idx];
      final updated = ProNote(
        title: note.title,
        content: note.content,
        contentDelta: note.contentDelta,
        headerText: note.headerText,
        footerText: note.footerText,
        templatePreset: note.templatePreset,
        folder: targetFolder,
        createdAt: note.createdAt,
        updatedAt: DateTime.now(),
        linkedDate: note.linkedDate,
        imageBase64: note.imageBase64,
        imagePath: note.imagePath,
      );
      await db.updateProNote(noteId, updated);
    }
    if (!mounted) return;
    setState(() {
      _selectionMode = false;
      _selectedNoteIds.clear();
    });
    await _loadNotes();
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('move_to_folder')}: ${folderLabel(targetFolder)}'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  /// Export a single note as PDF (used by 3-dot menu on card).
  Future<void> _exportNotePdfById(int noteId) async {
    final idx = _proNotes.indexWhere((n) => n.id == noteId);
    if (idx == -1) return;
    final note = _proNotes[idx];

    final (hasImages, hasText) = _analyzeContentDelta(note.contentDelta);
    bool photosFullPage = false;
    if (hasImages && hasText) {
      final choice = await showDialog<String>(
        context: context,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('photo_in_pdf')),
          content: Text(tr('photo_in_pdf_question')),
          actions: [
            OutlinedButton(
              onPressed: () => Navigator.pop(ctx, 'inline'),
              child: Text(tr('same_page')),
            ),
            const SizedBox(width: 8),
            FilledButton(
              onPressed: () => Navigator.pop(ctx, 'separate'),
              child: Text(tr('separate_page')),
            ),
          ],
        ),
      );
      if (choice == null || !mounted) return;
      photosFullPage = choice == 'separate';
    }

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );
    try {
      final pdfBytes = await generateNotePdfFromProNote(note, photosFullPage: photosFullPage);
      if (!mounted) return;
      Navigator.pop(context); // close loading
      Navigator.push(context, MaterialPageRoute(
        builder: (_) => _PdfViewerPage(pdfBytes: pdfBytes, title: note.title),
      ));
    } catch (e) {
      if (!mounted) return;
      Navigator.pop(context); // close loading
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Errore PDF: $e'), behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12))),
      );
    }
  }

  /// Move a single note to a different folder (used by 3-dot menu on card).
  Future<void> _moveNoteById(int noteId) async {
    final targetFolder = await showModalBottomSheet<String>(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (ctx) => Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(width: 40, height: 4, decoration: BoxDecoration(color: Colors.grey.shade300, borderRadius: BorderRadius.circular(2))),
            const SizedBox(height: 12),
            Text(tr('change_folder'), style: const TextStyle(fontSize: 15, fontWeight: FontWeight.w600)),
            const SizedBox(height: 8),
            ..._folders.entries.map((entry) => ListTile(
              leading: entry.value.buildIcon(size: 20, iconColor: entry.value.color),
              title: Text(folderLabel(entry.key)),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              onTap: () => Navigator.pop(ctx, entry.key),
            )),
          ],
        ),
      ),
    );
    if (targetFolder == null || !mounted) return;
    final idx = _proNotes.indexWhere((n) => n.id == noteId);
    if (idx == -1) return;
    final note = _proNotes[idx];
    final updated = ProNote(
      title: note.title,
      content: note.content,
      contentDelta: note.contentDelta,
      headerText: note.headerText,
      footerText: note.footerText,
      templatePreset: note.templatePreset,
      folder: targetFolder,
      createdAt: note.createdAt,
      updatedAt: DateTime.now(),
      linkedDate: note.linkedDate,
      imageBase64: note.imageBase64,
      imagePath: note.imagePath,
    );
    await DatabaseHelper().updateProNote(noteId, updated);
    await _loadNotes();
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('move_to_folder')}: ${folderLabel(targetFolder)}'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  /// Delete a single note (used by 3-dot menu on card).
  Future<void> _deleteNoteById(int noteId) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: Text(tr('delete_note_confirm')),
        content: Text('${tr('delete')}?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: Text(tr('cancel'))),
          FilledButton(
            onPressed: () => Navigator.pop(ctx, true),
            style: FilledButton.styleFrom(backgroundColor: Theme.of(context).colorScheme.error),
            child: Text(tr('delete')),
          ),
        ],
      ),
    );
    if (confirmed != true || !mounted) return;
    final idx = _proNotes.indexWhere((n) => n.id == noteId);
    if (idx == -1) return;
    final note = _proNotes[idx];
    final db = DatabaseHelper();
    int? trashedId;
    if (_settings.trashEnabled) {
      trashedId = await db.insertTrashedNote(TrashedNote(
        type: 'pro',
        noteJson: note.toJson(),
        deletedAt: DateTime.now(),
      ));
    } else {
      await ImageStorageHelper().deleteImageFile(note.imagePath);
    }
    await db.deleteProNote(noteId);
    await _loadNotes();
    if (!mounted) return;
    ScaffoldMessenger.of(context).clearSnackBars();
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text(tr('note_deleted')),
      action: SnackBarAction(
        label: tr('undo'),
        onPressed: () async {
          await db.insertProNote(note);
          if (trashedId != null) {
            await db.deleteTrashedNote(trashedId);
          }
          _loadNotes();
        },
      ),
      behavior: SnackBarBehavior.floating,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    ));
  }

}

// ── Note Read Page (Reading View) ──

class NoteReadPage extends StatefulWidget {
  final ProNote note;
  final Map<String, FolderStyle> folders;
  final Function(ProNote) onSave;

  const NoteReadPage({
    super.key,
    required this.note,
    required this.folders,
    required this.onSave,
  });

  @override
  State<NoteReadPage> createState() => _NoteReadPageState();
}

class _NoteReadPageState extends State<NoteReadPage> {
  late ProNote _currentNote;
  quill.QuillController? _quillReadController;
  final FocusNode _readFocusNode = FocusNode(canRequestFocus: false);
  final ScrollController _readScrollController = ScrollController();
  bool _isAiLoading = false;

  static final _googleFontBuilders = <String, TextStyle Function()>{
    'Press Start 2P': () => GoogleFonts.pressStart2p(),
    'Dancing Script': () => GoogleFonts.dancingScript(),
    'Poppins': () => GoogleFonts.poppins(),
  };

  TextStyle _customStyleBuilder(quill.Attribute attribute) {
    if (attribute.key == 'font' && attribute.value != null) {
      final fontValue = attribute.value as String;
      final builder = _googleFontBuilders[fontValue];
      if (builder != null) return builder();
      return TextStyle(fontFamily: fontValue);
    }
    return const TextStyle();
  }

  @override
  void initState() {
    super.initState();
    _currentNote = widget.note;
    _buildQuillController();
  }

  @override
  void dispose() {
    _quillReadController?.dispose();
    _readFocusNode.dispose();
    _readScrollController.dispose();
    super.dispose();
  }

  void _buildQuillController() {
    _quillReadController?.dispose();
    _quillReadController = null;
    if (_currentNote.contentDelta != null) {
      try {
        final deltaJson = jsonDecode(_currentNote.contentDelta!) as List;
        final doc = quill.Document.fromJson(deltaJson);
        _quillReadController = quill.QuillController(
          document: doc,
          selection: const TextSelection.collapsed(offset: 0),
          readOnly: true,
        );
      } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
    }
  }

  void _openEditor() async {
    final result = await Navigator.push<ProNote>(
      context,
      MaterialPageRoute(
        builder: (context) => NoteEditorPage(
          folders: widget.folders,
          existingNote: _currentNote,
          onSave: (updatedNote) {
            widget.onSave(updatedNote);
            setState(() {
              _currentNote = updatedNote;
              _buildQuillController();
            });
          },
        ),
      ),
    );
    if (result != null) {
      if (!mounted) return;
      setState(() {
        _currentNote = result;
        _buildQuillController();
      });
    }
  }

  Future<void> _callGeminiAI(String action) async {
    final settings = await FlashNotesSettings.load();
    final apiKey = settings.geminiApiKey;
    if (apiKey.isEmpty) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('api_key')),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
      return;
    }

    setState(() => _isAiLoading = true);

    try {
      final text = _quillReadController?.document.toPlainText().trim() ?? _currentNote.content;
      if (text.isEmpty) {
        setState(() => _isAiLoading = false);
        return;
      }

      final String prompt;
      final String title;
      if (action == 'riassumi') {
        prompt = 'Crea un breve riassunto in italiano del seguente testo:\n\n$text';
        title = tr('smart_summary');
      } else if (action == 'correggi') {
        prompt = 'Correggi errori ortografici, grammaticali e di punteggiatura nel seguente testo italiano. Migliora la formattazione mantenendo il significato originale:\n\n$text';
        title = tr('correct_and_format');
      } else {
        prompt = 'Estrai i punti chiave più importanti dal seguente testo in italiano, come lista puntata:\n\n$text';
        title = tr('ai_key_points');
      }

      final model = gemini.GenerativeModel(model: 'gemini-2.5-flash-lite', apiKey: apiKey);
      final response = await model.generateContent([gemini.Content.text(prompt)]).timeout(const Duration(seconds: 60));
      final result = response.text ?? tr('no_results');

      if (!mounted) return;
      setState(() => _isAiLoading = false);

      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
        ),
        builder: (ctx) {
          final colorScheme = Theme.of(ctx).colorScheme;
          return DraggableScrollableSheet(
            initialChildSize: 0.5,
            minChildSize: 0.3,
            maxChildSize: 0.85,
            expand: false,
            builder: (_, scrollController) => Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Center(
                    child: Container(
                      width: 40, height: 4,
                      decoration: BoxDecoration(
                        color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                        borderRadius: BorderRadius.circular(2),
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Icon(Icons.auto_awesome, color: colorScheme.primary),
                      const SizedBox(width: 8),
                      Text(title, style: Theme.of(ctx).textTheme.titleLarge),
                    ],
                  ),
                  const SizedBox(height: 16),
                  Expanded(
                    child: SingleChildScrollView(
                      controller: scrollController,
                      child: Card(
                        elevation: 0,
                        color: colorScheme.surfaceContainerLowest,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        child: Padding(
                          padding: const EdgeInsets.all(16),
                          child: SelectableText(result, style: const TextStyle(fontSize: 14, height: 1.5)),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  SizedBox(
                    width: double.infinity,
                    child: FilledButton.icon(
                      onPressed: () => Navigator.pop(ctx),
                      icon: const Icon(Icons.close, size: 18),
                      label: Text(tr('close')),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      );
    } catch (e) {
      if (!mounted) return;
      setState(() => _isAiLoading = false);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('error')}: $e'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  Future<void> _exportAsPdf() async {
    // Detect images and text
    final (hasImages, hasText) = _analyzeContentDelta(_currentNote.contentDelta);
    bool photosFullPage = false;
    if (hasImages && hasText) {
      final choice = await showDialog<String>(
        context: context,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('photo_in_pdf')),
          content: Text(tr('photo_in_pdf_question')),
          actions: [
            OutlinedButton(
              onPressed: () => Navigator.pop(ctx, 'inline'),
              child: Text(tr('same_page')),
            ),
            const SizedBox(width: 8),
            FilledButton(
              onPressed: () => Navigator.pop(ctx, 'separate'),
              child: Text(tr('separate_page')),
            ),
          ],
        ),
      );
      if (choice == null) return;
      if (!mounted) return;
      photosFullPage = choice == 'separate';
    } else if (hasImages && !hasText) {
      photosFullPage = true;
    }

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => Center(child: Card(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 16),
              Text(tr('exporting_pdf')),
            ],
          ),
        ),
      )),
    );

    try {
      final pdfBytes = await generateNotePdfFromProNote(_currentNote, isFlashNote: true, photosFullPage: photosFullPage);
      if (!mounted) return;
      Navigator.pop(context); // dismiss loading
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (_) => _PdfViewerPage(
            pdfBytes: pdfBytes,
            title: '${_currentNote.title}.pdf',
          ),
        ),
      );
    } catch (e) {
      if (!mounted) return;
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('error')}: $e'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final folderStyle = widget.folders[_currentNote.folder];

    return Scaffold(
      appBar: AppBar(
        title: Text(_currentNote.title.isEmpty ? tr('note_label') : _currentNote.title),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
        actions: [
          IconButton(
            onPressed: _exportAsPdf,
            icon: Icon(Icons.picture_as_pdf, color: colorScheme.onSurfaceVariant),
            tooltip: tr('export_pdf'),
          ),
          if (_isAiLoading)
            const Padding(
              padding: EdgeInsets.all(12),
              child: SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2)),
            )
          else
            PopupMenuButton<String>(
              icon: Icon(Icons.auto_awesome, color: colorScheme.onSurfaceVariant),
              tooltip: 'AI',
              onSelected: (value) => _callGeminiAI(value),
              itemBuilder: (context) => [
                PopupMenuItem(value: 'riassumi', child: Row(children: [Icon(Icons.auto_awesome, size: 20, color: Theme.of(context).colorScheme.onSurfaceVariant), const SizedBox(width: 12), Text(tr('summary_label'))])),
                PopupMenuItem(value: 'correggi', child: Row(children: [Icon(Icons.spellcheck, size: 20, color: Theme.of(context).colorScheme.onSurfaceVariant), const SizedBox(width: 12), Text(tr('correct'))])),
                PopupMenuItem(value: 'punti_chiave', child: Row(children: [Icon(Icons.format_list_bulleted, size: 20, color: Theme.of(context).colorScheme.onSurfaceVariant), const SizedBox(width: 12), Text(tr('key_points'))])),
              ],
            ),
          FilledButton.icon(
            onPressed: _openEditor,
            icon: const Icon(Icons.edit, size: 18),
            label: Text(tr('edit')),
            style: FilledButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            ),
          ),
          const SizedBox(width: 12),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Folder chip + date chip
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                if (folderStyle != null)
                  Chip(
                    avatar: folderStyle.buildIcon(size: 16, iconColor: folderStyle.color),
                    label: Text(_currentNote.folder),
                    backgroundColor: folderStyle.color.withValues(alpha: 0.1),
                    side: BorderSide.none,
                  ),
                if (_currentNote.linkedDate != null)
                  Chip(
                    avatar: Icon(Icons.calendar_today, size: 16, color: colorScheme.primary),
                    label: Text('${_currentNote.linkedDate!.day}/${_currentNote.linkedDate!.month}/${_currentNote.linkedDate!.year}'),
                    side: BorderSide.none,
                  ),
              ],
            ),
            const SizedBox(height: 16),
            // Title
            Text(
              _currentNote.title,
              style: TextStyle(
                fontSize: 26,
                fontWeight: FontWeight.bold,
                fontFamily: _themedFont(context),
                color: _hasCustomTheme(context) ? colorScheme.primary : null,
              ),
            ),
            Divider(height: 24, thickness: 0.5, color: colorScheme.outlineVariant),
            // Image (from flash note move)
            if ((_currentNote.imagePath != null && _currentNote.imagePath!.isNotEmpty) || (_currentNote.imageBase64 != null && _currentNote.imageBase64!.isNotEmpty)) ...[
              StoredImage(
                imagePath: _currentNote.imagePath,
                imageBase64: _currentNote.imageBase64,
                fit: BoxFit.contain,
                width: double.infinity,
                borderRadius: BorderRadius.circular(12),
              ),
              const SizedBox(height: 16),
            ],
            // Header
            if (_currentNote.headerText != null && _currentNote.headerText!.isNotEmpty) ...[
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  _currentNote.headerText!,
                  style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant),
                ),
              ),
              const SizedBox(height: 16),
            ],
            // Content (Quill read-only)
            if (_quillReadController != null)
              quill.QuillEditor(
                controller: _quillReadController!,
                focusNode: _readFocusNode,
                scrollController: _readScrollController,
                config: quill.QuillEditorConfig(
                  showCursor: false,
                  autoFocus: false,
                  padding: EdgeInsets.zero,
                  customStyleBuilder: _customStyleBuilder,
                  embedBuilders: [_DividerEmbedBuilder(), _ImageEmbedBuilder()],
                  onLaunchUrl: (url) async {
                    final uri = Uri.parse(url);
                    if (await canLaunchUrl(uri)) {
                      await launchUrl(uri, mode: LaunchMode.externalApplication);
                    }
                  },
                ),
              )
            else if (_currentNote.content.isNotEmpty)
              Text(
                _currentNote.content,
                style: TextStyle(fontSize: 16, height: 1.6, color: colorScheme.onSurface),
              ),
            // Footer
            if (_currentNote.footerText != null && _currentNote.footerText!.isNotEmpty) ...[
              Divider(height: 32, color: colorScheme.outlineVariant),
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  _currentNote.footerText!,
                  style: TextStyle(fontSize: 13, color: colorScheme.onSurfaceVariant),
                ),
              ),
            ],
            const SizedBox(height: 16),
            // Created date
            Text(
              '${tr('created_on')} ${_currentNote.createdAt.day}/${_currentNote.createdAt.month}/${_currentNote.createdAt.year} ${tr('at_time')} ${_currentNote.createdAt.hour.toString().padLeft(2, '0')}:${_currentNote.createdAt.minute.toString().padLeft(2, '0')}',
              style: TextStyle(fontSize: 12, color: colorScheme.onSurfaceVariant),
            ),
          ],
        ),
      ),
    );
  }
}

class NoteEditorPage extends StatefulWidget {
  final Function(ProNote) onSave;
  final Map<String, FolderStyle> folders;
  final ProNote? existingNote;
  final String? heroTag;

  const NoteEditorPage({
    super.key,
    required this.onSave,
    required this.folders,
    this.existingNote,
    this.heroTag,
  });

  @override
  State<NoteEditorPage> createState() => _NoteEditorPageState();
}

class _NoteEditorPageState extends State<NoteEditorPage> {
  late TextEditingController _titleController;
  late TextEditingController _headerController;
  late TextEditingController _footerController;
  late quill.QuillController _quillController;
  late FocusNode _editorFocusNode;
  late FocusNode _titleFocusNode;
  late ScrollController _editorScrollController;
  String _selectedFolder = 'Generale';
  bool _showHeader = false;
  bool _showFooter = false;
  String? _selectedTemplate;
  DateTime? _linkedDate;
  bool _isTitleFocused = false;
  TextAlign _titleAlignment = TextAlign.start;
  String _selectedFontFamily = 'Sans Serif';
  bool _showLinkGallery = true;
  List<String> _documentLinks = [];
  bool _isAiLoading = false;
  List<Map<String, dynamic>> _customTemplates = [];

  // Format state tracking
  bool _fmtBold = false;
  bool _fmtItalic = false;
  bool _fmtUnderline = false;
  bool _fmtStrike = false;
  bool _fmtH1 = false;
  bool _fmtH2 = false;
  bool _fmtUl = false;
  bool _fmtOl = false;
  bool _fmtChecklist = false;
  String _fmtAlign = 'left';

  void _updateFormatState() {
    if (!mounted) return;
    final style = _quillController.getSelectionStyle();
    setState(() {
      _fmtBold = style.attributes.containsKey('bold');
      _fmtItalic = style.attributes.containsKey('italic');
      _fmtUnderline = style.attributes.containsKey('underline');
      _fmtStrike = style.attributes.containsKey('strike');
      final header = style.attributes['header'];
      _fmtH1 = header?.value == 1;
      _fmtH2 = header?.value == 2;
      final list = style.attributes['list'];
      _fmtUl = list?.value == 'bullet';
      _fmtOl = list?.value == 'ordered';
      _fmtChecklist = list?.value == 'unchecked' || list?.value == 'checked';
      final align = style.attributes['align'];
      _fmtAlign = (align?.value as String?) ?? 'left';
    });
  }

  static const _fontFamilies = {
    'Sans Serif': 'sans-serif',
    'Arcade': 'Press Start 2P',
    'Corsivo': 'Dancing Script',
    'Poppins': 'Poppins',
  };

  static final _googleFontBuilders = <String, TextStyle Function()>{
    'Press Start 2P': () => GoogleFonts.pressStart2p(),
    'Dancing Script': () => GoogleFonts.dancingScript(),
    'Poppins': () => GoogleFonts.poppins(),
  };

  TextStyle _customStyleBuilder(quill.Attribute attribute) {
    if (attribute.key == 'font' && attribute.value != null) {
      final fontValue = attribute.value as String;
      final builder = _googleFontBuilders[fontValue];
      if (builder != null) return builder();
      return TextStyle(fontFamily: fontValue);
    }
    return const TextStyle();
  }


  static final _businessTemplates = {
    'Lettera Formale': BusinessTemplate(
      header: 'Nome Cognome\nIndirizzo\nCAP Città\nTel: \nEmail: ',
      contentDelta: [
        {'insert': '\n\nSpett.le\n[Destinatario]\n[Indirizzo]\n\n'},
        {'insert': 'Oggetto: ', 'attributes': {'bold': true}},
        {'insert': '[Oggetto della lettera]\n\n'},
        {'insert': 'Egregio/a,\n\n[Corpo della lettera]\n\n'},
        {'insert': 'Distinti saluti,\n[Firma]\n'},
      ],
      footer: 'P.IVA: | CF: | PEC: ',
    ),
    'Lettera Commerciale': BusinessTemplate(
      header: 'Ragione Sociale S.r.l.\nVia Roma, 1\n00100 Roma (RM)\nTel: +39 06 1234567\nEmail: info@azienda.it',
      contentDelta: [
        {'insert': '\n\nSpett.le\n[Nome Azienda Destinataria]\n[Indirizzo]\n\n'},
        {'insert': 'Alla c.a. di ', 'attributes': {'bold': true}},
        {'insert': '[Nome Referente]\n\n'},
        {'insert': 'Oggetto: ', 'attributes': {'bold': true}},
        {'insert': '[Oggetto]\n\n'},
        {'insert': 'Con la presente siamo a comunicarVi che [corpo della lettera].\n\n'},
        {'insert': 'Restando a disposizione per ulteriori chiarimenti, porgiamo cordiali saluti.\n\n'},
        {'insert': '[Nome e Cognome]\n[Qualifica]\n'},
      ],
      footer: 'P.IVA: 01234567890 | REA: RM-123456 | Cap. Soc. € 10.000,00 i.v.',
    ),
    'Preventivo': BusinessTemplate(
      header: 'Ragione Sociale S.r.l.\nVia Roma, 1\n00100 Roma (RM)\nP.IVA: 01234567890',
      contentDelta: [
        {'insert': '\n\n'},
        {'insert': 'PREVENTIVO N. [Numero]', 'attributes': {'bold': true, 'size': '24'}},
        {'insert': '\nData: [GG/MM/AAAA]\n\n'},
        {'insert': 'Cliente: ', 'attributes': {'bold': true}},
        {'insert': '[Nome Cliente]\n[Indirizzo Cliente]\n\n'},
        {'insert': 'Descrizione dei servizi/prodotti:\n\n', 'attributes': {'bold': true}},
        {'insert': '1. [Voce 1] — € [Importo]\n'},
        {'insert': '2. [Voce 2] — € [Importo]\n'},
        {'insert': '3. [Voce 3] — € [Importo]\n\n'},
        {'insert': 'Totale imponibile: € [Totale]\nIVA 22%: € [IVA]\n', 'attributes': {'bold': true}},
        {'insert': 'TOTALE: € [Totale con IVA]\n\n', 'attributes': {'bold': true, 'size': '20'}},
        {'insert': 'Condizioni di pagamento: [Modalità]\nValidità offerta: 30 giorni dalla data del presente preventivo.\n\n'},
        {'insert': 'Cordiali saluti,\n[Firma]\n'},
      ],
      footer: 'P.IVA: 01234567890 | IBAN: IT00 X000 0000 0000 0000 0000 000',
    ),
    'Sollecito Pagamento': BusinessTemplate(
      header: 'Ragione Sociale S.r.l.\nVia Roma, 1\n00100 Roma (RM)\nP.IVA: 01234567890',
      contentDelta: [
        {'insert': '\n\n'},
        {'insert': 'SOLLECITO DI PAGAMENTO', 'attributes': {'bold': true, 'size': '24'}},
        {'insert': '\n\nSpett.le\n[Nome Debitore]\n[Indirizzo]\n\n'},
        {'insert': 'Oggetto: ', 'attributes': {'bold': true}},
        {'insert': 'Sollecito pagamento fattura n. [Numero] del [Data]\n\n'},
        {'insert': 'Con la presente ci permettiamo di segnalarVi che, alla data odierna, non risulta ancora pervenuto il pagamento della fattura in oggetto, '},
        {'insert': 'per un importo di € [Importo]', 'attributes': {'bold': true}},
        {'insert': ', con scadenza al [Data Scadenza].\n\n'},
        {'insert': 'Vi preghiamo cortesemente di provvedere al saldo entro e non oltre [Data Limite], tramite bonifico bancario al seguente IBAN:\n'},
        {'insert': '[IBAN]\n\n', 'attributes': {'bold': true}},
        {'insert': 'Qualora il pagamento fosse già stato effettuato, Vi preghiamo di considerare nulla la presente comunicazione.\n\n'},
        {'insert': 'Cordiali saluti,\n[Nome e Cognome]\n[Qualifica]\n'},
      ],
      footer: 'P.IVA: 01234567890 | PEC: azienda@pec.it',
    ),
  };

  @override
  void initState() {
    super.initState();
    _titleController = TextEditingController();
    _headerController = TextEditingController();
    _footerController = TextEditingController();
    _editorFocusNode = FocusNode();
    _titleFocusNode = FocusNode();
    _titleFocusNode.addListener(() {
      setState(() => _isTitleFocused = _titleFocusNode.hasFocus);
    });
    _editorScrollController = ScrollController();

    if (widget.existingNote != null) {
      final note = widget.existingNote!;
      _titleController.text = note.title;
      _selectedFolder = note.folder;
      _headerController.text = note.headerText ?? '';
      _footerController.text = note.footerText ?? '';
      _showHeader = (note.headerText ?? '').isNotEmpty;
      _showFooter = (note.footerText ?? '').isNotEmpty;
      _selectedTemplate = note.templatePreset;
      _linkedDate = note.linkedDate;

      if (note.contentDelta != null) {
        final deltaJson = json.decode(note.contentDelta!) as List;
        _quillController = quill.QuillController(
          document: quill.Document.fromJson(deltaJson),
          selection: const TextSelection.collapsed(offset: 0),
        );
      } else {
        _quillController = quill.QuillController(
          document: quill.Document()..insert(0, note.content),
          selection: const TextSelection.collapsed(offset: 0),
        );
      }
    } else {
      _quillController = quill.QuillController.basic();
    }
    _quillController.addListener(_updateDocumentLinks);
    _quillController.addListener(_updateFormatState);
    _updateDocumentLinks();
    _loadCustomTemplates();
  }

  Future<void> _loadCustomTemplates() async {
    final settings = await NoteProSettings.load();
    if (mounted) {
      setState(() => _customTemplates = settings.customTemplates);
    }
  }

  void _updateDocumentLinks() {
    final links = _extractLinksFromDocument();
    if (links.length != _documentLinks.length || links.join() != _documentLinks.join()) {
      setState(() => _documentLinks = links);
    }
  }

  List<String> _extractLinksFromDocument() {
    final delta = _quillController.document.toDelta();
    final links = <String>[];
    for (final op in delta.toList()) {
      if (op.attributes != null && op.attributes!.containsKey('link')) {
        final url = op.attributes!['link'] as String;
        if (url.isNotEmpty && !links.contains(url)) {
          links.add(url);
        }
      }
    }
    return links;
  }

  Future<void> _callGeminiAI(String action) async {
    final settings = await FlashNotesSettings.load();
    final apiKey = settings.geminiApiKey;
    if (apiKey.isEmpty) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(tr('api_key')),
          behavior: SnackBarBehavior.floating,
        ),
      );
      return;
    }

    setState(() => _isAiLoading = true);

    try {
      final text = _quillController.document.toPlainText().trim();
      if (text.isEmpty) {
        setState(() => _isAiLoading = false);
        return;
      }

      final String prompt;
      final String title;
      if (action == 'riassumi') {
        prompt = 'Crea un breve riassunto in italiano del seguente testo:\n\n$text';
        title = tr('smart_summary');
      } else if (action == 'correggi') {
        prompt = 'Correggi errori ortografici, grammaticali e di punteggiatura nel seguente testo italiano. Migliora la formattazione mantenendo il significato originale:\n\n$text';
        title = tr('correct_and_format');
      } else {
        prompt = 'Estrai i punti chiave più importanti dal seguente testo in italiano, come lista puntata:\n\n$text';
        title = tr('ai_key_points');
      }

      final model = gemini.GenerativeModel(model: 'gemini-2.5-flash-lite', apiKey: apiKey);
      final response = await model.generateContent([gemini.Content.text(prompt)]);
      final result = response.text ?? tr('no_results');

      if (!mounted) return;
      setState(() => _isAiLoading = false);

      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
        ),
        builder: (ctx) {
          final colorScheme = Theme.of(ctx).colorScheme;
          return DraggableScrollableSheet(
            initialChildSize: 0.5,
            minChildSize: 0.3,
            maxChildSize: 0.85,
            expand: false,
            builder: (_, scrollController) => Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Center(
                    child: Container(
                      width: 40, height: 4,
                      decoration: BoxDecoration(
                        color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                        borderRadius: BorderRadius.circular(2),
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Icon(Icons.auto_awesome, color: colorScheme.primary),
                      const SizedBox(width: 8),
                      Text(title, style: Theme.of(ctx).textTheme.titleLarge),
                    ],
                  ),
                  const SizedBox(height: 16),
                  Expanded(
                    child: SingleChildScrollView(
                      controller: scrollController,
                      child: Card(
                        elevation: 0,
                        color: colorScheme.surfaceContainerLowest,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        child: Padding(
                          padding: const EdgeInsets.all(16),
                          child: SelectableText(result, style: const TextStyle(fontSize: 14, height: 1.5)),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  if (action == 'correggi')
                    SizedBox(
                      width: double.infinity,
                      child: FilledButton.icon(
                        onPressed: () {
                          Navigator.pop(ctx);
                          _quillController.document = quill.Document()..insert(0, result);
                        },
                        icon: const Icon(Icons.check, size: 18),
                        label: Text(tr('apply_correction')),
                      ),
                    )
                  else
                    SizedBox(
                      width: double.infinity,
                      child: FilledButton.icon(
                        onPressed: () {
                          Navigator.pop(ctx);
                          final doc = _quillController.document;
                          final length = doc.length;
                          doc.insert(length - 1, '\n\n--- $title ---\n$result\n');
                        },
                        icon: const Icon(Icons.add, size: 18),
                        label: Text(tr('insert')),
                      ),
                    ),
                ],
              ),
            ),
          );
        },
      );
    } catch (e) {
      if (!mounted) return;
      setState(() => _isAiLoading = false);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${tr('error')}: $e'),
          behavior: SnackBarBehavior.floating,
        ),
      );
    }
  }

  void _saveNote() {
    final plainText = _quillController.document.toPlainText().trim();
    if (_titleController.text.isNotEmpty && plainText.isNotEmpty) {
      final deltaJson = json.encode(_quillController.document.toDelta().toJson());
      widget.onSave(
        ProNote(
          title: _titleController.text,
          content: plainText,
          contentDelta: deltaJson,
          headerText: _showHeader ? _headerController.text : null,
          footerText: _showFooter ? _footerController.text : null,
          templatePreset: _selectedTemplate,
          folder: _selectedFolder,
          linkedDate: _linkedDate,
          imageBase64: widget.existingNote?.imageBase64,
          imagePath: widget.existingNote?.imagePath,
        ),
      );
      Navigator.pop(context);
    }
  }

  Future<Uint8List> _generateNotePdf({bool photosFullPage = false}) async {
    final doc = pw.Document();
    final title = _titleController.text;
    final headerText = _showHeader ? _headerController.text : null;
    final footerText = _showFooter ? _footerController.text : null;

    // Load logo for footer
    pw.MemoryImage? logoImage;
    try {
      final logoData = await rootBundle.load('assets/logo.png');
      logoImage = pw.MemoryImage(logoData.buffer.asUint8List());
    } catch (_) {}
    final noteSettings = await NoteProSettings.load();
    final showFooterLogo = noteSettings.pdfShowLogo;

    pw.Font regularFont;
    pw.Font boldFont;
    pw.Font italicFont;
    pw.Font boldItalicFont;
    try {
      regularFont = await PdfGoogleFonts.nunitoRegular();
      boldFont = await PdfGoogleFonts.nunitoBold();
      italicFont = await PdfGoogleFonts.nunitoItalic();
      boldItalicFont = await PdfGoogleFonts.nunitoBoldItalic();
    } catch (_) {
      regularFont = pw.Font.helvetica();
      boldFont = pw.Font.helveticaBold();
      italicFont = pw.Font.helveticaOblique();
      boldItalicFont = pw.Font.helveticaBoldOblique();
    }
    pw.Font? emojiFont;
    try { emojiFont = await PdfGoogleFonts.notoColorEmojiRegular(); } catch (_) {}
    final fontFallback = <pw.Font>[if (emojiFont != null) emojiFont];

    const pdfIndigo = PdfColor.fromInt(0xFF6366F1);
    const pdfIndigoLight = PdfColor.fromInt(0x336366F1);
    final baseStyle = pw.TextStyle(font: regularFont, fontSize: 12, fontFallback: fontFallback);
    final titleStyle = pw.TextStyle(font: boldFont, fontSize: 22, color: pdfIndigo, fontFallback: fontFallback);
    final footerStyle = pw.TextStyle(font: regularFont, fontSize: 9, color: PdfColors.grey500);
    final headerStyle = pw.TextStyle(font: regularFont, fontSize: 10, color: PdfColors.grey600);
    final generatedDate = '${DateTime.now().day.toString().padLeft(2, '0')}/${DateTime.now().month.toString().padLeft(2, '0')}/${DateTime.now().year}';

    pw.TextStyle pdfStyleFromAttributes(Map<String, dynamic>? attrs, {double? overrideFontSize}) {
      if (attrs == null && overrideFontSize == null) return baseStyle;
      var style = baseStyle;
      final isBold = attrs?['bold'] == true;
      final isItalic = attrs?['italic'] == true;
      if (isBold && isItalic) {
        style = style.copyWith(font: boldItalicFont, fontBold: boldItalicFont, fontItalic: boldItalicFont);
      } else if (isBold) {
        style = style.copyWith(font: boldFont, fontBold: boldFont);
      } else if (isItalic) {
        style = style.copyWith(font: italicFont, fontItalic: italicFont);
      }
      if (attrs?['underline'] == true) style = style.copyWith(decoration: pw.TextDecoration.underline);
      if (attrs?['strike'] == true) style = style.copyWith(decoration: pw.TextDecoration.lineThrough);
      if (attrs?['link'] != null) {
        style = style.copyWith(color: PdfColors.blue, decoration: pw.TextDecoration.underline);
      }
      final sizeVal = attrs?['size'];
      if (sizeVal != null) {
        final sz = double.tryParse(sizeVal.toString());
        if (sz != null) style = style.copyWith(fontSize: sz);
      }
      if (overrideFontSize != null) {
        style = style.copyWith(fontSize: overrideFontSize);
      }
      final colorVal = attrs?['color'];
      if (colorVal is String && colorVal.startsWith('#') && colorVal.length >= 7) {
        final hex = colorVal.replaceFirst('#', '');
        final c = int.tryParse(hex, radix: 16);
        if (c != null) style = style.copyWith(color: PdfColor.fromInt(0xFF000000 | c));
      }
      final bgVal = attrs?['background'];
      if (bgVal is String && bgVal.startsWith('#') && bgVal.length >= 7) {
        final hex = bgVal.replaceFirst('#', '');
        final c = int.tryParse(hex, radix: 16);
        if (c != null) style = style.copyWith(background: pw.BoxDecoration(color: PdfColor.fromInt(0xFF000000 | c)));
      }
      return style;
    }

    // Walk Delta inline — text and images in order (rich text aware)
    final delta = _quillController.document.toDelta();
    final List<pw.Widget> bodyWidgets = [];
    List<pw.InlineSpan> lineSpans = [];
    int orderedCounter = 0;

    void flushLine(Map<String, dynamic>? blockAttrs) {
      final headerLevel = blockAttrs?['header'];
      final listType = blockAttrs?['list'];
      final align = blockAttrs?['align'];

      if (lineSpans.isEmpty && listType == null) {
        bodyWidgets.add(pw.SizedBox(height: 6));
        lineSpans = [];
        if (listType == null) orderedCounter = 0;
        return;
      }

      // Apply header styling to all spans
      if (headerLevel == 1 || headerLevel == 2) {
        final hSize = headerLevel == 1 ? 24.0 : 20.0;
        lineSpans = lineSpans.map((span) {
          if (span is pw.TextSpan) {
            final s = (span.style ?? baseStyle).copyWith(fontSize: hSize, font: boldFont, fontBold: boldFont);
            return pw.TextSpan(text: span.text, style: s);
          }
          return span;
        }).toList();
      }

      // List prefix
      if (listType != null) {
        if (listType == 'bullet') {
          lineSpans.insert(0, pw.TextSpan(text: '\u2022 ', style: lineSpans.isNotEmpty && lineSpans.first is pw.TextSpan ? (lineSpans.first as pw.TextSpan).style : baseStyle));
          orderedCounter = 0;
        } else if (listType == 'ordered') {
          orderedCounter++;
          lineSpans.insert(0, pw.TextSpan(text: '$orderedCounter. ', style: lineSpans.isNotEmpty && lineSpans.first is pw.TextSpan ? (lineSpans.first as pw.TextSpan).style : baseStyle));
        } else if (listType == 'checked') {
          lineSpans.insert(0, pw.WidgetSpan(child: pw.Container(
            width: 13, height: 13,
            margin: const pw.EdgeInsets.only(right: 5),
            decoration: pw.BoxDecoration(color: pdfIndigo, borderRadius: pw.BorderRadius.circular(3)),
            child: pw.Center(child: pw.Text('\u2713', style: pw.TextStyle(font: boldFont, fontSize: 9, color: PdfColors.white))),
          )));
          orderedCounter = 0;
        } else if (listType == 'unchecked') {
          lineSpans.insert(0, pw.WidgetSpan(child: pw.Container(
            width: 13, height: 13,
            margin: const pw.EdgeInsets.only(right: 5),
            decoration: pw.BoxDecoration(borderRadius: pw.BorderRadius.circular(3), border: pw.Border.all(color: PdfColors.grey400, width: 1)),
          )));
          orderedCounter = 0;
        } else {
          orderedCounter = 0;
        }
      } else {
        orderedCounter = 0;
      }

      pw.Widget lineWidget = pw.Padding(
        padding: pw.EdgeInsets.only(bottom: 4, left: listType != null ? 16 : 0),
        child: pw.RichText(text: pw.TextSpan(children: List.of(lineSpans))),
      );

      // Alignment
      if (align == 'center') {
        lineWidget = pw.Align(alignment: pw.Alignment.center, child: lineWidget);
      } else if (align == 'right') {
        lineWidget = pw.Align(alignment: pw.Alignment.centerRight, child: lineWidget);
      }

      bodyWidgets.add(lineWidget);
      lineSpans = [];
    }

    for (final op in delta.toList()) {
      if (op.data is String) {
        final text = op.data as String;
        final attrs = op.attributes;
        final style = pdfStyleFromAttributes(attrs != null ? Map<String, dynamic>.from(attrs) : null);
        final lines = text.split('\n');
        for (int i = 0; i < lines.length; i++) {
          if (lines[i].isNotEmpty) {
            lineSpans.add(pw.TextSpan(text: lines[i], style: style));
          }
          if (i < lines.length - 1) {
            // The \n carries block-level attributes
            flushLine(attrs != null ? Map<String, dynamic>.from(attrs) : null);
          }
        }
      } else if (op.data is Map) {
        flushLine(null);
        final map = op.data as Map;
        if (map.containsKey('image')) {
          final imgStr = map['image'] as String;
          try {
            Uint8List? imgBytes;
            if (imgStr.startsWith('data:image/')) {
              imgBytes = base64Decode(imgStr.split(',').last);
            }
            if (imgBytes != null) {
              if (photosFullPage) {
                bodyWidgets.add(pw.Container(
                  width: 515,
                  height: 700,
                  alignment: pw.Alignment.centerLeft,
                  child: pw.ClipRRect(
                    horizontalRadius: 8,
                    verticalRadius: 8,
                    child: pw.Image(pw.MemoryImage(imgBytes), fit: pw.BoxFit.contain),
                  ),
                ));
              } else {
                final (imgW, imgH) = _pdfImageDisplaySize(imgBytes);
                bodyWidgets.add(pw.Padding(
                  padding: const pw.EdgeInsets.symmetric(vertical: 8),
                  child: pw.ClipRRect(
                    horizontalRadius: 8,
                    verticalRadius: 8,
                    child: pw.Image(pw.MemoryImage(imgBytes), width: imgW, height: imgH),
                  ),
                ));
              }
            }
          } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
        } else if (map.containsKey('divider')) {
          bodyWidgets.add(pw.Divider(thickness: 0.5, color: pdfIndigoLight));
        }
      }
    }
    flushLine(null);

    doc.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        margin: const pw.EdgeInsets.all(40),
        header: (headerText != null && headerText.isNotEmpty)
            ? (_) => pw.Column(
                crossAxisAlignment: pw.CrossAxisAlignment.start,
                children: [
                  pw.Text(headerText, style: headerStyle),
                  pw.SizedBox(height: 6),
                ],
              )
            : null,
        footer: (ctx) => pw.Row(
            children: [
              pw.Expanded(
                child: pw.Text(
                  footerText != null && footerText.isNotEmpty ? footerText : generatedDate,
                  style: footerStyle,
                ),
              ),
              pw.Expanded(
                child: pw.Center(
                  child: pw.Text('Pagina ${ctx.pageNumber} di ${ctx.pagesCount}', style: footerStyle),
                ),
              ),
              pw.Expanded(
                child: pw.Align(
                  alignment: pw.Alignment.centerRight,
                  child: showFooterLogo && logoImage != null
                      ? pw.Image(logoImage, width: 20, height: 20)
                      : pw.SizedBox(),
                ),
              ),
            ],
          ),
        build: (context) => [
          if (title.isNotEmpty) ...[
            pw.Text(title, style: titleStyle),
            pw.Divider(thickness: 0.5, color: pdfIndigoLight),
            pw.SizedBox(height: 8),
          ],
          ...bodyWidgets,
        ],
      ),
    );

    return doc.save();
  }

  Future<void> _exportAsPdf() async {
    // Detect images and text in current document
    bool hasImages = false;
    bool hasText = false;
    for (final op in _quillController.document.toDelta().toList()) {
      if (op.data is Map && (op.data as Map).containsKey('image')) hasImages = true;
      if (op.data is String && (op.data as String).trim().isNotEmpty) hasText = true;
    }

    bool photosFullPage = false;
    if (hasImages && hasText) {
      final choice = await showDialog<String>(
        context: context,
        builder: (ctx) => AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
          title: Text(tr('photo_in_pdf')),
          content: Text(tr('photo_in_pdf_question')),
          actions: [
            OutlinedButton(
              onPressed: () => Navigator.pop(ctx, 'inline'),
              child: Text(tr('same_page')),
            ),
            const SizedBox(width: 8),
            FilledButton(
              onPressed: () => Navigator.pop(ctx, 'separate'),
              child: Text(tr('separate_page')),
            ),
          ],
        ),
      );
      if (choice == null) return;
      if (!mounted) return;
      photosFullPage = choice == 'separate';
    } else if (hasImages && !hasText) {
      photosFullPage = true;
    }

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => Center(child: Card(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 16),
              Text(tr('exporting_pdf')),
            ],
          ),
        ),
      )),
    );

    try {
      final pdfBytes = await _generateNotePdf(photosFullPage: photosFullPage);
      if (!mounted) return;
      Navigator.pop(context); // dismiss loading
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (_) => _PdfViewerPage(
            pdfBytes: pdfBytes,
            title: '${_titleController.text}.pdf',
          ),
        ),
      );
    } catch (e) {
      if (mounted) {
        Navigator.pop(context); // dismiss loading
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${tr('error')}: $e'),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  void _pickLinkedDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _linkedDate ?? DateTime.now(),
      firstDate: DateTime(2020),
      lastDate: DateTime(2030),
    );
    if (picked != null) {
      if (!mounted) return;
      setState(() => _linkedDate = picked);
    }
  }

  void _applyTemplate(String name, BusinessTemplate template) {
    _quillController.removeListener(_updateDocumentLinks);
    _quillController.dispose();
    setState(() {
      _selectedTemplate = name;
      _headerController.text = template.header;
      _footerController.text = template.footer;
      _showHeader = true;
      _showFooter = true;
      _quillController = quill.QuillController(
        document: quill.Document.fromJson(template.contentDelta),
        selection: const TextSelection.collapsed(offset: 0),
      );
      _quillController.addListener(_updateDocumentLinks);
    });
  }

  Widget _buildLinkGallery() {
    if (!_showLinkGallery || _documentLinks.isEmpty) return const SizedBox.shrink();
    final colorScheme = Theme.of(context).colorScheme;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(height: 8),
        Row(
          children: [
            Icon(Icons.link, size: 16, color: colorScheme.primary),
            const SizedBox(width: 6),
            Text(
              'Link (${_documentLinks.length})',
              style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600, color: colorScheme.onSurface),
            ),
            const Spacer(),
            IconButton(
              icon: const Icon(Icons.close, size: 16),
              onPressed: () => setState(() => _showLinkGallery = false),
              padding: EdgeInsets.zero,
              constraints: const BoxConstraints(),
            ),
          ],
        ),
        const SizedBox(height: 4),
        ConstrainedBox(
          constraints: const BoxConstraints(maxHeight: 150),
          child: ListView.builder(
            shrinkWrap: true,
            itemCount: _documentLinks.length,
            itemBuilder: (context, index) {
              final url = _documentLinks[index];
              return _LinkPreviewCard(url: url);
            },
          ),
        ),
      ],
    );
  }

  void _insertLink() {
    final urlController = TextEditingController();
    final textController = TextEditingController();
    final selection = _quillController.selection;
    final hasSelection = !selection.isCollapsed;

    if (hasSelection) {
      textController.text = _quillController.document.getPlainText(
        selection.start,
        selection.end - selection.start,
      );
    }

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(tr('add_link')),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (!hasSelection)
              TextField(
                controller: textController,
                decoration: InputDecoration(
                  labelText: tr('text'),
                  hintText: tr('text'),
                ),
              ),
            if (!hasSelection) const SizedBox(height: 12),
            TextField(
              controller: urlController,
              decoration: const InputDecoration(
                labelText: 'URL',
                hintText: 'https://...',
              ),
              keyboardType: TextInputType.url,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: Text(tr('cancel')),
          ),
          ElevatedButton(
            onPressed: () {
              final url = urlController.text.trim();
              if (url.isEmpty) return;

              if (hasSelection) {
                _quillController.formatText(
                  selection.start,
                  selection.end - selection.start,
                  quill.LinkAttribute(url),
                );
              } else {
                final text = textController.text.trim().isEmpty
                    ? url
                    : textController.text.trim();
                final index = selection.baseOffset;
                _quillController.document.insert(index, text);
                _quillController.formatText(
                  index,
                  text.length,
                  quill.LinkAttribute(url),
                );
                _quillController.updateSelection(
                  TextSelection.collapsed(offset: index + text.length),
                  quill.ChangeSource.local,
                );
              }
              setState(() => _showLinkGallery = true);
              Navigator.pop(ctx);
            },
            child: Text(tr('insert')),
          ),
        ],
      ),
    );
  }

  void _insertHorizontalRule() {
    final index = _quillController.selection.baseOffset;
    _quillController.document.insert(index, quill.BlockEmbed('divider', 'hr'));
    _quillController.updateSelection(
      TextSelection.collapsed(offset: index + 1),
      quill.ChangeSource.local,
    );
  }

  void _insertImage() async {
    final colorScheme = Theme.of(context).colorScheme;
    final source = await showModalBottomSheet<ImageSource>(
      context: context,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (ctx) => SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(width: 40, height: 4, decoration: BoxDecoration(color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3), borderRadius: BorderRadius.circular(2))),
              const SizedBox(height: 20),
              Text(tr('insert_image'), style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: FilledButton.icon(
                  onPressed: () => Navigator.pop(ctx, ImageSource.camera),
                  icon: const Icon(Icons.camera_alt),
                  label: Text(tr('camera')),
                  style: FilledButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              SizedBox(
                width: double.infinity,
                child: OutlinedButton.icon(
                  onPressed: () => Navigator.pop(ctx, ImageSource.gallery),
                  icon: const Icon(Icons.photo_library),
                  label: Text(tr('gallery')),
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );

    if (source == null || !mounted) return;

    try {
      final picked = await ImagePicker().pickImage(
        source: source,
        preferredCameraDevice: CameraDevice.rear,
        maxWidth: 1024,
        maxHeight: 1024,
        imageQuality: 80,
      );
      if (picked == null) return;

      final bytes = await picked.readAsBytes();
      if (bytes.length > 2 * 1024 * 1024) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(tr('image_too_large')),
              behavior: SnackBarBehavior.floating,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
            ),
          );
        }
        return;
      }

      final ext = picked.name.split('.').last.toLowerCase();
      final mime = ext == 'png' ? 'image/png' : 'image/jpeg';
      final b64 = base64Encode(bytes);
      final dataUri = 'data:$mime;base64,$b64';

      final index = _quillController.selection.baseOffset;
      _quillController.document.insert(index, quill.BlockEmbed.image(dataUri));
      _quillController.updateSelection(
        TextSelection.collapsed(offset: index + 1),
        quill.ChangeSource.local,
      );
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${tr('error')}: $e'),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  void _applyColor(Color color, {required bool isBackground}) {
    final hex = '#${color.value.toRadixString(16).padLeft(8, '0').substring(2)}';
    if (isBackground) {
      _quillController.formatSelection(
        quill.Attribute.fromKeyValue('background', hex),
      );
    } else {
      _quillController.formatSelection(
        quill.Attribute.fromKeyValue('color', hex),
      );
    }
  }

  void _showColorPickerPopup({required bool isBackground}) {
    final colorScheme = Theme.of(context).colorScheme;

    const quickColors = [
      Color(0xFF000000),
      Color(0xFFE53935),
      Color(0xFF1E88E5),
      Color(0xFF43A047),
    ];

    showDialog(
      context: context,
      builder: (ctx) {
        return _ColorPickerDialog(
          isBackground: isBackground,
          quickColors: quickColors,
          colorScheme: colorScheme,
          onColorSelected: (color) {
            _applyColor(color, isBackground: isBackground);
          },
          onReset: () {
            if (isBackground) {
              _quillController.formatSelection(
                const quill.BackgroundAttribute(null),
              );
            } else {
              _quillController.formatSelection(
                const quill.ColorAttribute(null),
              );
            }
          },
        );
      },
    );
  }

  Widget _fmtBtn(IconData icon, {required bool active, required VoidCallback onTap, String? tooltip, Widget? child}) {
    final colorScheme = Theme.of(context).colorScheme;
    return Tooltip(
      message: tooltip ?? '',
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(8),
        child: Container(
          width: 36,
          height: 36,
          decoration: BoxDecoration(
            color: active ? colorScheme.primaryContainer : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
          ),
          child: child ?? Icon(icon, size: 20, color: active ? colorScheme.primary : colorScheme.onSurfaceVariant),
        ),
      ),
    );
  }

  Widget _toolbarDivider() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 4),
      child: SizedBox(
        height: 24,
        child: VerticalDivider(width: 1, thickness: 1, color: Theme.of(context).colorScheme.outlineVariant),
      ),
    );
  }

  Widget _buildSPenToolbar() {
    final colorScheme = Theme.of(context).colorScheme;

    // --- Row 1: Text formatting ---
    final row1 = Row(
      children: [
        // Undo / Redo
        _fmtBtn(Icons.undo, active: false, onTap: () { _quillController.undo(); setState(() {}); }, tooltip: tr('undo')),
        _fmtBtn(Icons.redo, active: false, onTap: () { _quillController.redo(); setState(() {}); }, tooltip: tr('redo')),
        _toolbarDivider(),
        // Bold, Italic, Underline, Strikethrough
        _fmtBtn(Icons.format_bold, active: _fmtBold, onTap: () => _quillController.formatSelection(quill.Attribute.bold), tooltip: tr('bold')),
        _fmtBtn(Icons.format_italic, active: _fmtItalic, onTap: () => _quillController.formatSelection(quill.Attribute.italic), tooltip: tr('italic')),
        _fmtBtn(Icons.format_underline, active: _fmtUnderline, onTap: () => _quillController.formatSelection(quill.Attribute.underline), tooltip: tr('underline')),
        _fmtBtn(Icons.format_strikethrough, active: _fmtStrike, onTap: () => _quillController.formatSelection(quill.Attribute.strikeThrough), tooltip: tr('strikethrough')),
        _toolbarDivider(),
        // Headings
        _fmtBtn(Icons.looks_one, active: _fmtH1, onTap: () {
          _quillController.formatSelection(_fmtH1 ? quill.Attribute.header : quill.Attribute.h1);
        }, tooltip: tr('title')),
        _fmtBtn(Icons.looks_two, active: _fmtH2, onTap: () {
          _quillController.formatSelection(_fmtH2 ? quill.Attribute.header : quill.Attribute.h2);
        }, tooltip: tr('subtitle')),
        _toolbarDivider(),
        // Highlight, Text color, Background color
        _fmtBtn(Icons.highlight, active: false, onTap: () {
          _quillController.formatSelection(
            quill.Attribute.fromKeyValue('background', _themedHighlight(context)),
          );
        }, tooltip: tr('highlight')),
        _fmtBtn(Icons.format_color_text, active: false, onTap: () => _showColorPickerPopup(isBackground: false), tooltip: tr('text_color')),
        _fmtBtn(Icons.format_color_fill, active: false, onTap: () => _showColorPickerPopup(isBackground: true), tooltip: tr('background_color')),
        _toolbarDivider(),
        // Alignment
        _fmtBtn(Icons.format_align_left, active: _fmtAlign == 'left', onTap: () => _quillController.formatSelection(quill.Attribute.leftAlignment), tooltip: tr('align_left_short')),
        _fmtBtn(Icons.format_align_center, active: _fmtAlign == 'center', onTap: () => _quillController.formatSelection(quill.Attribute.centerAlignment), tooltip: tr('align_center_short')),
        _fmtBtn(Icons.format_align_right, active: _fmtAlign == 'right', onTap: () => _quillController.formatSelection(quill.Attribute.rightAlignment), tooltip: tr('align_right_short')),
      ],
    );

    // --- Row 2: Inserts & tools (scrollable) ---
    final row2 = SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: [
          // Lists
          _fmtBtn(Icons.format_list_bulleted, active: _fmtUl, onTap: () => _quillController.formatSelection(quill.Attribute.ul), tooltip: tr('bullet_list')),
          _fmtBtn(Icons.format_list_numbered, active: _fmtOl, onTap: () => _quillController.formatSelection(quill.Attribute.ol), tooltip: tr('numbered_list')),
          _fmtBtn(Icons.checklist, active: _fmtChecklist, onTap: () => _quillController.formatSelection(quill.Attribute.unchecked), tooltip: tr('checklist')),
          _toolbarDivider(),
          // Link, Image, HR
          _fmtBtn(Icons.link, active: false, onTap: _insertLink, tooltip: tr('link')),
          _fmtBtn(Icons.image_outlined, active: false, onTap: _insertImage, tooltip: tr('insert_image')),
          _fmtBtn(Icons.horizontal_rule, active: false, onTap: _insertHorizontalRule, tooltip: tr('indent')),
          _toolbarDivider(),
          // Font
          _fmtBtn(Icons.font_download_outlined, active: false, onTap: () {
            showModalBottomSheet(context: context, builder: (_) => _buildFontFamilySheet());
          }, tooltip: tr('font')),
          _toolbarDivider(),
          // AI
          _isAiLoading
              ? const Padding(
                  padding: EdgeInsets.all(8),
                  child: SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2)),
                )
              : _fmtBtn(Icons.auto_awesome, active: false, onTap: () {
                  final RenderBox box = context.findRenderObject() as RenderBox;
                  final offset = box.localToGlobal(Offset.zero);
                  showMenu<String>(
                    context: context,
                    position: RelativeRect.fromLTRB(offset.dx, offset.dy, offset.dx + box.size.width, offset.dy + box.size.height),
                    items: [
                      PopupMenuItem(value: 'riassumi', child: Text(tr('smart_summary'))),
                      PopupMenuItem(value: 'correggi', child: Text(tr('correct_and_format'))),
                    ],
                  ).then((v) { if (v != null) _callGeminiAI(v); });
                }, tooltip: 'AI', child: Icon(Icons.auto_awesome, size: 20, color: colorScheme.primary)),
          _toolbarDivider(),
          // Template
          _fmtBtn(Icons.description_outlined, active: false, onTap: () {
            final RenderBox box = context.findRenderObject() as RenderBox;
            final offset = box.localToGlobal(Offset.zero);
            final items = <PopupMenuEntry<String>>[
              ..._businessTemplates.keys.map((name) {
                return PopupMenuItem<String>(
                  value: name,
                  child: Row(
                    children: [
                      Icon(name == _selectedTemplate ? Icons.check : Icons.description, size: 18),
                      const SizedBox(width: 8),
                      Text(name),
                    ],
                  ),
                );
              }),
              if (_customTemplates.isNotEmpty) ...[
                const PopupMenuDivider(),
                ..._customTemplates.map((t) {
                  final name = t['name'] as String? ?? 'Template';
                  return PopupMenuItem<String>(
                    value: 'custom:$name',
                    child: Row(
                      children: [
                        Icon(_selectedTemplate == name ? Icons.check : Icons.note_outlined, size: 18),
                        const SizedBox(width: 8),
                        Text(name),
                      ],
                    ),
                  );
                }),
              ],
            ];
            showMenu<String>(
              context: context,
              position: RelativeRect.fromLTRB(offset.dx, offset.dy, offset.dx + box.size.width, offset.dy + box.size.height),
              items: items,
            ).then((v) { if (v != null) _onTemplateSelected(v); });
          }, tooltip: tr('template')),
          // Folder
          _fmtBtn(Icons.folder_outlined, active: false, onTap: () {
            showModalBottomSheet(context: context, builder: (_) => _buildFolderSheet());
          }, tooltip: tr('folder')),
          // Calendar link
          _fmtBtn(
            _linkedDate != null ? Icons.calendar_today : Icons.calendar_today_outlined,
            active: _linkedDate != null,
            onTap: _pickLinkedDate,
            tooltip: tr('select_date'),
          ),
          // Header/Footer
          _fmtBtn(
            _showHeader || _showFooter ? Icons.article : Icons.article_outlined,
            active: _showHeader || _showFooter,
            onTap: () {
              setState(() {
                if (_showHeader || _showFooter) {
                  _showHeader = false;
                  _showFooter = false;
                } else {
                  _showHeader = true;
                  _showFooter = true;
                }
              });
            },
            tooltip: '${tr('header')}/${tr('footer')}',
          ),
        ],
      ),
    );

    return Material(
      elevation: 6,
      borderRadius: BorderRadius.circular(16),
      color: colorScheme.surfaceContainerLowest,
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: colorScheme.outlineVariant),
        ),
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: row1,
            ),
            Divider(height: 1, thickness: 1, color: colorScheme.outlineVariant.withValues(alpha: 0.5)),
            row2,
          ],
        ),
      ),
    );
  }

  Widget _buildFontFamilySheet() {
    return SafeArea(
      child: ListView(
        shrinkWrap: true,
        children: _fontFamilies.entries.map((entry) {
          final builder = _googleFontBuilders[entry.value];
          final previewStyle = builder != null ? builder() : TextStyle(fontFamily: entry.value);
          return ListTile(
            title: Text(entry.key, style: previewStyle),
            selected: _selectedFontFamily == entry.key,
            onTap: () {
              setState(() => _selectedFontFamily = entry.key);
              _quillController.formatSelection(
                quill.Attribute.fromKeyValue('font', _fontFamilies[entry.key]),
              );
              Navigator.pop(context);
            },
          );
        }).toList(),
      ),
    );
  }

  Widget _buildFolderSheet() {
    final colorScheme = Theme.of(context).colorScheme;
    return SafeArea(
      child: ListView(
        shrinkWrap: true,
        children: widget.folders.entries.map((entry) {
          final isSelected = _selectedFolder == entry.key;
          return ListTile(
            leading: Icon(entry.value.icon, color: entry.value.color),
            title: Text(entry.key),
            selected: isSelected,
            selectedColor: entry.value.color,
            trailing: isSelected ? Icon(Icons.check, color: colorScheme.primary) : null,
            onTap: () {
              setState(() => _selectedFolder = entry.key);
              Navigator.pop(context);
            },
          );
        }).toList(),
      ),
    );
  }

  void _onTemplateSelected(String value) {
    final isCustom = value.startsWith('custom:');
    final displayName = isCustom ? value.substring(7) : value;

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text('${tr('apply')} "$displayName"?'),
        content: const Text(
          'Il contenuto attuale verrà sostituito con il template selezionato.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: Text(tr('cancel')),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(ctx);
              if (isCustom) {
                _applyCustomTemplate(displayName);
              } else {
                final tpl = _businessTemplates[displayName];
                if (tpl != null) _applyTemplate(displayName, tpl);
              }
            },
            child: Text(tr('apply')),
          ),
        ],
      ),
    );
  }

  void _applyCustomTemplate(String name) {
    final t = _customTemplates.firstWhere(
      (t) => t['name'] == name,
      orElse: () => {},
    );
    final deltaStr = t['delta'] as String?;
    if (deltaStr == null) return;
    _quillController.removeListener(_updateDocumentLinks);
    _quillController.dispose();
    setState(() {
      _selectedTemplate = name;
      _quillController = quill.QuillController(
        document: quill.Document.fromJson(json.decode(deltaStr) as List),
        selection: const TextSelection.collapsed(offset: 0),
      );
      _quillController.addListener(_updateDocumentLinks);
    });
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    Widget scaffold = Scaffold(
      appBar: AppBar(
        title: Text(widget.existingNote != null ? 'Modifica Nota' : 'Nuova Deep Note'),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
        actions: [
          IconButton(
            onPressed: _exportAsPdf,
            icon: const Icon(Icons.picture_as_pdf, size: 22),
            tooltip: tr('export_as_pdf'),
          ),
          FilledButton.icon(
            onPressed: _saveNote,
            icon: const Icon(Icons.save, size: 18),
            label: Text(tr('save')),
            style: FilledButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            ),
          ),
          const SizedBox(width: 12),
        ],
      ),
      body: Stack(
        children: [
          // Ephemera paper texture overlay
          if (_themeOverlayColor(context) != null)
            Positioned.fill(
              child: Container(color: _themeOverlayColor(context)),
            ),
          // Yellow Note ruled lines
          if ((_isYellowNoteTheme(context) || _isBlockNoteTheme(context)))
            Positioned.fill(
              child: IgnorePointer(
                child: CustomPaint(painter: _LinedPaperPainter()),
              ),
            ),
          // Main editor column
          Padding(
            padding: const EdgeInsets.only(left: 16, right: 16, top: 16, bottom: 8),
            child: Column(
              children: [
                // TITLE — free, no box at all
                TextField(
                  controller: _titleController,
                  focusNode: _titleFocusNode,
                  textAlign: _titleAlignment,
                  decoration: InputDecoration(
                    hintText: tr('title'),
                    hintStyle: TextStyle(
                      fontSize: 26,
                      fontWeight: FontWeight.bold,
                      color: colorScheme.onSurfaceVariant.withValues(alpha: 0.3),
                    ),
                    filled: false,
                    border: InputBorder.none,
                    enabledBorder: InputBorder.none,
                    focusedBorder: InputBorder.none,
                    contentPadding: EdgeInsets.zero,
                    isDense: true,
                  ),
                  style: TextStyle(fontSize: 26, fontWeight: FontWeight.bold, fontFamily: _themedFont(context), color: _hasCustomTheme(context) ? colorScheme.primary : null),
                ),
                // (title toolbar moved to Positioned overlay below)
                Divider(height: 24, thickness: 0.5, color: colorScheme.outlineVariant),
                // HEADER (collapsible)
                if (_showHeader) ...[
                  TextField(
                    controller: _headerController,
                    maxLines: 3,
                    decoration: InputDecoration(
                      labelText: tr('header'),
                      hintText: tr('content'),
                      prefixIcon: Icon(Icons.vertical_align_top, color: colorScheme.tertiary),
                      suffixIcon: IconButton(
                        icon: const Icon(Icons.close, size: 18),
                        onPressed: () => setState(() => _showHeader = false),
                      ),
                    ),
                    style: const TextStyle(fontSize: 13),
                  ),
                  const SizedBox(height: 8),
                ],
                // QUILL EDITOR (Expanded) — free page, no border
                Expanded(
                  child: quill.QuillEditor(
                        controller: _quillController,
                        focusNode: _editorFocusNode,
                        scrollController: _editorScrollController,
                        config: quill.QuillEditorConfig(
                          placeholder: 'Scrivi qui la tua nota...',
                          padding: const EdgeInsets.fromLTRB(0, 8, 0, 80),
                          contextMenuBuilder: (context, rawEditorState) {
                            return AdaptiveTextSelectionToolbar.buttonItems(
                              anchors: rawEditorState.contextMenuAnchors,
                              buttonItems: <ContextMenuButtonItem>[
                                ContextMenuButtonItem(label: tr('cut'), onPressed: () => rawEditorState.cutSelection(SelectionChangedCause.toolbar)),
                                ContextMenuButtonItem(label: tr('copy'), onPressed: () => rawEditorState.copySelection(SelectionChangedCause.toolbar)),
                                ContextMenuButtonItem(label: tr('paste'), onPressed: () => rawEditorState.pasteText(SelectionChangedCause.toolbar)),
                                ContextMenuButtonItem(label: tr('select_all'), onPressed: () => rawEditorState.selectAll(SelectionChangedCause.toolbar)),
                              ],
                            );
                          },
                          customStyleBuilder: _customStyleBuilder,
                          embedBuilders: [_DividerEmbedBuilder(), _ImageEmbedBuilder()],
                          characterShortcutEvents: quill.standardCharactersShortcutEvents,
                          spaceShortcutEvents: [
                            ...quill.standardSpaceShorcutEvents,
                            quill.SpaceShortcutEvent(
                              character: '[]',
                              handler: (node, controller) {
                                final sel = controller.selection;
                                controller.replaceText(sel.baseOffset - 2, 2, '\n', null);
                                controller.updateSelection(
                                  TextSelection.collapsed(offset: sel.baseOffset - 2),
                                  quill.ChangeSource.local,
                                );
                                controller.formatSelection(quill.Attribute.unchecked);
                                controller.replaceText(controller.selection.baseOffset + 1, 1, '', null);
                                return true;
                              },
                            ),
                          ],
                          onLaunchUrl: (url) async {
                            final uri = Uri.parse(url);
                            if (await canLaunchUrl(uri)) {
                              await launchUrl(uri, mode: LaunchMode.externalApplication);
                            }
                          },
                        ),
                  ),
                ),
                // LINK GALLERY
                _buildLinkGallery(),
                // FOOTER (collapsible)
                if (_showFooter) ...[
                  const SizedBox(height: 8),
                  TextField(
                    controller: _footerController,
                    maxLines: 2,
                    decoration: InputDecoration(
                      labelText: tr('footer'),
                      hintText: tr('footer_hint'),
                      prefixIcon: Icon(Icons.vertical_align_bottom, color: colorScheme.tertiary),
                      suffixIcon: IconButton(
                        icon: const Icon(Icons.close, size: 18),
                        onPressed: () => setState(() => _showFooter = false),
                      ),
                    ),
                    style: const TextStyle(fontSize: 13),
                  ),
                ],
              ],
            ),
          ),
          // Title formatting toolbar (overlay, always visible when title focused)
          if (_isTitleFocused)
            Positioned(
              left: 16,
              right: 16,
              bottom: 12,
              child: Material(
                elevation: 6,
                borderRadius: BorderRadius.circular(16),
                color: colorScheme.surfaceContainerLowest,
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(color: colorScheme.outlineVariant),
                  ),
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
                  child: SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        ActionChip(
                          label: Text(tr('all_caps'), style: const TextStyle(fontSize: 11)),
                          avatar: const Icon(Icons.text_fields, size: 16),
                          onPressed: () {
                            _titleController.text = _titleController.text.toUpperCase();
                            _titleController.selection = TextSelection.fromPosition(TextPosition(offset: _titleController.text.length));
                          },
                        ),
                        const SizedBox(width: 6),
                        ActionChip(
                          label: Text(tr('capitalize_words'), style: const TextStyle(fontSize: 11)),
                          avatar: const Icon(Icons.title, size: 16),
                          onPressed: () {
                            _titleController.text = _titleController.text.split(' ').map((w) => w.isNotEmpty ? '${w[0].toUpperCase()}${w.substring(1).toLowerCase()}' : w).join(' ');
                            _titleController.selection = TextSelection.fromPosition(TextPosition(offset: _titleController.text.length));
                          },
                        ),
                        const SizedBox(width: 6),
                        SegmentedButton<TextAlign>(
                          segments: const [
                            ButtonSegment(value: TextAlign.start, icon: Icon(Icons.format_align_left, size: 16)),
                            ButtonSegment(value: TextAlign.center, icon: Icon(Icons.format_align_center, size: 16)),
                            ButtonSegment(value: TextAlign.end, icon: Icon(Icons.format_align_right, size: 16)),
                          ],
                          selected: {_titleAlignment},
                          onSelectionChanged: (v) => setState(() => _titleAlignment = v.first),
                          showSelectedIcon: false,
                          style: const ButtonStyle(
                            visualDensity: VisualDensity.compact,
                            tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          // Formatting toolbar (always visible when editor focused)
          if (!_isTitleFocused)
            Positioned(
              left: 16,
              right: 16,
              bottom: 12,
              child: _buildSPenToolbar(),
            ),
        ],
      ),
    );
    if (widget.heroTag != null) {
      scaffold = Hero(tag: widget.heroTag!, child: Material(type: MaterialType.transparency, child: scaffold));
    }
    return scaffold;
  }

  @override
  void dispose() {
    _quillController.removeListener(_updateDocumentLinks);
    _quillController.removeListener(_updateFormatState);
    _titleController.dispose();
    _headerController.dispose();
    _footerController.dispose();
    _quillController.dispose();
    _editorFocusNode.dispose();
    _titleFocusNode.dispose();
    _editorScrollController.dispose();
    super.dispose();
  }
}

// ── PDF Image Size Helper ──

/// Reads image dimensions from raw PNG/JPEG bytes without async decoding.
(int, int)? _pdfImageSize(Uint8List bytes) {
  // PNG: signature + IHDR
  if (bytes.length > 24 && bytes[0] == 0x89 && bytes[1] == 0x50 && bytes[2] == 0x4E && bytes[3] == 0x47) {
    final w = (bytes[16] << 24) | (bytes[17] << 16) | (bytes[18] << 8) | bytes[19];
    final h = (bytes[20] << 24) | (bytes[21] << 16) | (bytes[22] << 8) | bytes[23];
    if (w > 0 && h > 0) return (w, h);
  }
  // JPEG: find SOF0/SOF1/SOF2 marker
  if (bytes.length > 2 && bytes[0] == 0xFF && bytes[1] == 0xD8) {
    int i = 2;
    while (i < bytes.length - 9) {
      if (bytes[i] != 0xFF) { i++; continue; }
      final marker = bytes[i + 1];
      if (marker == 0xC0 || marker == 0xC1 || marker == 0xC2) {
        final h = (bytes[i + 5] << 8) | bytes[i + 6];
        final w = (bytes[i + 7] << 8) | bytes[i + 8];
        if (w > 0 && h > 0) return (w, h);
      }
      if (marker == 0xDA) break; // Start of scan — stop searching
      final len = (bytes[i + 2] << 8) | bytes[i + 3];
      i += 2 + len;
    }
  }
  return null;
}

/// Analyzes a delta JSON string to detect images and text content.
(bool, bool) _analyzeContentDelta(String? deltaJson) {
  if (deltaJson == null) return (false, false);
  try {
    final ops = json.decode(deltaJson) as List;
    bool hasImages = false;
    bool hasText = false;
    for (final op in ops) {
      if (op is Map) {
        final insert = op['insert'];
        if (insert is Map && insert.containsKey('image')) hasImages = true;
        if (insert is String && insert.trim().isNotEmpty) hasText = true;
      }
    }
    return (hasImages, hasText);
  } catch (_) {
    return (false, true);
  }
}

/// Calculates PDF image display dimensions, keeping it inline with text.
(double, double) _pdfImageDisplaySize(Uint8List bytes, {double maxW = 400, double maxH = 350}) {
  final dims = _pdfImageSize(bytes);
  if (dims == null) return (maxW.clamp(0, 300), maxH.clamp(0, 250));
  final (origW, origH) = dims;
  double w = origW.toDouble();
  double h = origH.toDouble();
  if (w > maxW) { h = h * (maxW / w); w = maxW; }
  if (h > maxH) { w = w * (maxH / h); h = maxH; }
  return (w, h);
}

// ── PDF Viewer Page ──

Future<Uint8List> generateNotePdfFromProNote(ProNote note, {bool isFlashNote = false, bool photosFullPage = false}) async {
  final doc = pw.Document();

  // Load logo for footer
  pw.MemoryImage? logoImage;
  try {
    final logoData = await rootBundle.load('assets/logo.png');
    logoImage = pw.MemoryImage(logoData.buffer.asUint8List());
  } catch (_) {}
  final noteSettings = await NoteProSettings.load();
  final showFooterLogo = noteSettings.pdfShowLogo;

  pw.Font regularFont;
  pw.Font boldFont;
  pw.Font italicFont;
  pw.Font boldItalicFont;
  try {
    regularFont = await PdfGoogleFonts.nunitoRegular();
    boldFont = await PdfGoogleFonts.nunitoBold();
    italicFont = await PdfGoogleFonts.nunitoItalic();
    boldItalicFont = await PdfGoogleFonts.nunitoBoldItalic();
  } catch (_) {
    regularFont = pw.Font.helvetica();
    boldFont = pw.Font.helveticaBold();
    italicFont = pw.Font.helveticaOblique();
    boldItalicFont = pw.Font.helveticaBoldOblique();
  }
  pw.Font? emojiFont;
  try { emojiFont = await PdfGoogleFonts.notoColorEmojiRegular(); } catch (_) {}
  final fontFallback = <pw.Font>[if (emojiFont != null) emojiFont];

  const pdfIndigo = PdfColor.fromInt(0xFF6366F1);
  const pdfOrange = PdfColor.fromInt(0xFFFFA726);
  final accentColor = isFlashNote ? pdfOrange : pdfIndigo;
  final accentColorLight = PdfColor.fromInt(isFlashNote ? 0x33FFA726 : 0x336366F1);
  final baseStyle = pw.TextStyle(font: regularFont, fontSize: 12, fontFallback: fontFallback);
  final titleStyle = pw.TextStyle(font: boldFont, fontSize: 22, color: accentColor, fontFallback: fontFallback);
  final footerStyle = pw.TextStyle(font: regularFont, fontSize: 9, color: PdfColors.grey500);
  final headerStyle = pw.TextStyle(font: regularFont, fontSize: 10, color: PdfColors.grey600);
  final generatedDate = '${DateTime.now().day.toString().padLeft(2, '0')}/${DateTime.now().month.toString().padLeft(2, '0')}/${DateTime.now().year}';

  pw.TextStyle pdfStyleFromAttributes(Map<String, dynamic>? attrs, {double? overrideFontSize}) {
    if (attrs == null && overrideFontSize == null) return baseStyle;
    var style = baseStyle;
    final isBold = attrs?['bold'] == true;
    final isItalic = attrs?['italic'] == true;
    if (isBold && isItalic) {
      style = style.copyWith(font: boldItalicFont, fontBold: boldItalicFont, fontItalic: boldItalicFont);
    } else if (isBold) {
      style = style.copyWith(font: boldFont, fontBold: boldFont);
    } else if (isItalic) {
      style = style.copyWith(font: italicFont, fontItalic: italicFont);
    }
    if (attrs?['underline'] == true) style = style.copyWith(decoration: pw.TextDecoration.underline);
    if (attrs?['strike'] == true) style = style.copyWith(decoration: pw.TextDecoration.lineThrough);
    if (attrs?['link'] != null) {
      style = style.copyWith(color: PdfColors.blue, decoration: pw.TextDecoration.underline);
    }
    final sizeVal = attrs?['size'];
    if (sizeVal != null) {
      final sz = double.tryParse(sizeVal.toString());
      if (sz != null) style = style.copyWith(fontSize: sz);
    }
    if (overrideFontSize != null) {
      style = style.copyWith(fontSize: overrideFontSize);
    }
    final colorVal = attrs?['color'];
    if (colorVal is String && colorVal.startsWith('#') && colorVal.length >= 7) {
      final hex = colorVal.replaceFirst('#', '');
      final c = int.tryParse(hex, radix: 16);
      if (c != null) style = style.copyWith(color: PdfColor.fromInt(0xFF000000 | c));
    }
    final bgVal = attrs?['background'];
    if (bgVal is String && bgVal.startsWith('#') && bgVal.length >= 7) {
      final hex = bgVal.replaceFirst('#', '');
      final c = int.tryParse(hex, radix: 16);
      if (c != null) style = style.copyWith(background: pw.BoxDecoration(color: PdfColor.fromInt(0xFF000000 | c)));
    }
    return style;
  }

  final List<pw.Widget> bodyWidgets = [];
  if (note.contentDelta != null) {
    try {
      final deltaJson = json.decode(note.contentDelta!) as List;
      List<pw.InlineSpan> lineSpans = [];
      int orderedCounter = 0;

      void flushLine(Map<String, dynamic>? blockAttrs) {
        final headerLevel = blockAttrs?['header'];
        final listType = blockAttrs?['list'];
        final align = blockAttrs?['align'];

        if (lineSpans.isEmpty && listType == null) {
          bodyWidgets.add(pw.SizedBox(height: 6));
          lineSpans = [];
          if (listType == null) orderedCounter = 0;
          return;
        }

        // Apply header styling to all spans
        if (headerLevel == 1 || headerLevel == 2) {
          final hSize = headerLevel == 1 ? 24.0 : 20.0;
          lineSpans = lineSpans.map((span) {
            if (span is pw.TextSpan) {
              final s = (span.style ?? baseStyle).copyWith(fontSize: hSize, font: boldFont, fontBold: boldFont);
              return pw.TextSpan(text: span.text, style: s);
            }
            return span;
          }).toList();
        }

        // List prefix
        if (listType != null) {
          if (listType == 'bullet') {
            lineSpans.insert(0, pw.TextSpan(text: '\u2022 ', style: lineSpans.isNotEmpty && lineSpans.first is pw.TextSpan ? (lineSpans.first as pw.TextSpan).style : baseStyle));
            orderedCounter = 0;
          } else if (listType == 'ordered') {
            orderedCounter++;
            lineSpans.insert(0, pw.TextSpan(text: '$orderedCounter. ', style: lineSpans.isNotEmpty && lineSpans.first is pw.TextSpan ? (lineSpans.first as pw.TextSpan).style : baseStyle));
          } else if (listType == 'checked') {
            lineSpans.insert(0, pw.WidgetSpan(child: pw.Container(
              width: 13, height: 13,
              margin: const pw.EdgeInsets.only(right: 5),
              decoration: pw.BoxDecoration(color: accentColor, borderRadius: pw.BorderRadius.circular(3)),
              child: pw.Center(child: pw.Text('\u2713', style: pw.TextStyle(font: boldFont, fontSize: 9, color: PdfColors.white))),
            )));
            orderedCounter = 0;
          } else if (listType == 'unchecked') {
            lineSpans.insert(0, pw.WidgetSpan(child: pw.Container(
              width: 13, height: 13,
              margin: const pw.EdgeInsets.only(right: 5),
              decoration: pw.BoxDecoration(borderRadius: pw.BorderRadius.circular(3), border: pw.Border.all(color: PdfColors.grey400, width: 1)),
            )));
            orderedCounter = 0;
          } else {
            orderedCounter = 0;
          }
        } else {
          orderedCounter = 0;
        }

        pw.Widget lineWidget = pw.Padding(
          padding: pw.EdgeInsets.only(bottom: 4, left: listType != null ? 16 : 0),
          child: pw.RichText(text: pw.TextSpan(children: List.of(lineSpans))),
        );

        // Alignment
        if (align == 'center') {
          lineWidget = pw.Align(alignment: pw.Alignment.center, child: lineWidget);
        } else if (align == 'right') {
          lineWidget = pw.Align(alignment: pw.Alignment.centerRight, child: lineWidget);
        }

        bodyWidgets.add(lineWidget);
        lineSpans = [];
      }

      for (final op in deltaJson) {
        if (op is Map) {
          final insert = op['insert'];
          final attrs = op['attributes'] as Map<String, dynamic>?;
          if (insert is String) {
            final style = pdfStyleFromAttributes(attrs);
            final lines = insert.split('\n');
            for (int i = 0; i < lines.length; i++) {
              if (lines[i].isNotEmpty) {
                lineSpans.add(pw.TextSpan(text: lines[i], style: style));
              }
              if (i < lines.length - 1) {
                flushLine(attrs);
              }
            }
          } else if (insert is Map) {
            flushLine(null);
            if (insert.containsKey('image')) {
              final imgStr = insert['image'] as String;
              try {
                Uint8List? imgBytes;
                if (imgStr.startsWith('data:image/')) {
                  imgBytes = base64Decode(imgStr.split(',').last);
                }
                if (imgBytes != null) {
                  if (photosFullPage) {
                    bodyWidgets.add(pw.Container(
                      width: 515,
                      height: 700,
                      alignment: pw.Alignment.centerLeft,
                      child: pw.ClipRRect(
                        horizontalRadius: 8,
                        verticalRadius: 8,
                        child: pw.Image(pw.MemoryImage(imgBytes), fit: pw.BoxFit.contain),
                      ),
                    ));
                  } else {
                    final (imgW, imgH) = _pdfImageDisplaySize(imgBytes);
                    bodyWidgets.add(pw.Padding(
                      padding: const pw.EdgeInsets.symmetric(vertical: 8),
                      child: pw.ClipRRect(
                        horizontalRadius: 8,
                        verticalRadius: 8,
                        child: pw.Image(pw.MemoryImage(imgBytes), width: imgW, height: imgH),
                      ),
                    ));
                  }
                }
              } catch (e) { if (kDebugMode) debugPrint('Silent error: $e'); }
            } else if (insert.containsKey('divider')) {
              bodyWidgets.add(pw.Divider(thickness: 0.5, color: accentColorLight));
            }
          }
        }
      }
      flushLine(null);
    } catch (_) {
      bodyWidgets.add(pw.Text(note.content, style: baseStyle));
    }
  } else {
    bodyWidgets.add(pw.Text(note.content, style: baseStyle));
  }

  final footerText = note.footerText;
  doc.addPage(
    pw.MultiPage(
      pageFormat: PdfPageFormat.a4,
      margin: const pw.EdgeInsets.all(40),
      header: (note.headerText != null && note.headerText!.isNotEmpty)
          ? (_) => pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Text(note.headerText!, style: headerStyle),
                pw.SizedBox(height: 6),
              ],
            )
          : null,
      footer: (ctx) => pw.Row(
            children: [
              pw.Expanded(
                child: pw.Text(
                  footerText != null && footerText.isNotEmpty ? footerText : generatedDate,
                  style: footerStyle,
                ),
              ),
              pw.Expanded(
                child: pw.Center(
                  child: pw.Text('Pagina ${ctx.pageNumber} di ${ctx.pagesCount}', style: footerStyle),
                ),
              ),
              pw.Expanded(
                child: pw.Align(
                  alignment: pw.Alignment.centerRight,
                  child: showFooterLogo && logoImage != null
                      ? pw.Image(logoImage, width: 20, height: 20)
                      : pw.SizedBox(),
                ),
              ),
            ],
          ),
      build: (context) => [
        if (note.title.isNotEmpty) ...[
          pw.Text(note.title, style: titleStyle),
          pw.Divider(thickness: 0.5, color: accentColorLight),
          pw.SizedBox(height: 8),
        ],
        ...bodyWidgets,
      ],
    ),
  );
  return doc.save();
}

class _PdfViewerPage extends StatelessWidget {
  final Uint8List pdfBytes;
  final String title;

  const _PdfViewerPage({required this.pdfBytes, required this.title});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(title, maxLines: 1, overflow: TextOverflow.ellipsis),
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: Colors.transparent,
      ),
      body: PdfPreview(
        build: (_) async => pdfBytes,
        canChangeOrientation: false,
        canChangePageFormat: false,
        canDebug: false,
        allowPrinting: false,
        allowSharing: true,
        pdfFileName: title,
      ),
    );
  }
}

// ── Divider Embed Builder ──

class _DividerEmbedBuilder extends quill.EmbedBuilder {
  @override
  String get key => 'divider';

  @override
  Widget build(BuildContext context, quill.EmbedContext embedContext) {
    return Divider(
      color: Theme.of(context).colorScheme.outlineVariant,
      height: 24,
      thickness: 1,
    );
  }
}

class _ImageEmbedBuilder extends quill.EmbedBuilder {
  @override
  String get key => 'image';

  @override
  Widget build(BuildContext context, quill.EmbedContext embedContext) {
    final imageUrl = embedContext.node.value.data as String;
    Widget imageWidget;

    if (imageUrl.startsWith('data:image/')) {
      try {
        final b64 = imageUrl.split(',').last;
        final bytes = base64Decode(b64);
        imageWidget = Image.memory(
          Uint8List.fromList(bytes),
          fit: BoxFit.contain,
          errorBuilder: (_, __, ___) => const Icon(Icons.broken_image, size: 48),
        );
      } catch (_) {
        imageWidget = const Icon(Icons.broken_image, size: 48);
      }
    } else {
      imageWidget = Image.network(
        imageUrl,
        fit: BoxFit.contain,
        errorBuilder: (_, __, ___) => const Icon(Icons.broken_image, size: 48),
      );
    }

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(12),
        child: imageWidget,
      ),
    );
  }
}

// ── Link Preview Card ──

class _LinkPreviewCard extends StatelessWidget {
  final String url;
  const _LinkPreviewCard({required this.url});

  IconData _getIcon() {
    final lower = url.toLowerCase();
    if (lower.contains('youtube.com') || lower.contains('youtu.be')) return Icons.play_circle_fill;
    if (lower.contains('github.com')) return Icons.code;
    if (lower.endsWith('.pdf')) return Icons.picture_as_pdf;
    if (lower.contains('drive.google')) return Icons.cloud;
    return Icons.link;
  }

  Color _getIconColor() {
    final lower = url.toLowerCase();
    if (lower.contains('youtube.com') || lower.contains('youtu.be')) return const Color(0xFFFF0000);
    if (lower.contains('github.com')) return const Color(0xFF333333);
    if (lower.endsWith('.pdf')) return const Color(0xFFE53935);
    if (lower.contains('drive.google')) return const Color(0xFF4285F4);
    return const Color(0xFF2196F3);
  }

  String _getLabel() {
    final lower = url.toLowerCase();
    if (lower.contains('drive.google')) return 'Google Drive';
    if (lower.contains('youtube.com') || lower.contains('youtu.be')) return 'YouTube';
    if (lower.contains('github.com')) return 'GitHub';
    if (lower.endsWith('.pdf')) return 'PDF';
    try {
      return Uri.parse(url).host;
    } catch (_) {
      return url;
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final iconColor = _getIconColor();
    return Card(
      margin: const EdgeInsets.only(bottom: 4),
      elevation: 0,
      color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        borderRadius: BorderRadius.circular(10),
        onTap: () async {
          final uri = Uri.parse(url);
          if (await canLaunchUrl(uri)) {
            await launchUrl(uri, mode: LaunchMode.externalApplication);
          }
        },
        child: Container(
          decoration: BoxDecoration(
            border: Border(left: BorderSide(color: iconColor, width: 3)),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          child: Row(
            children: [
              Icon(_getIcon(), color: iconColor, size: 22),
              const SizedBox(width: 10),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      url,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(fontSize: 12, color: colorScheme.primary),
                    ),
                    Text(
                      _getLabel(),
                      style: TextStyle(fontSize: 10, color: colorScheme.onSurfaceVariant, fontWeight: FontWeight.w500),
                    ),
                  ],
                ),
              ),
              Icon(Icons.open_in_new, size: 16, color: colorScheme.onSurfaceVariant),
            ],
          ),
        ),
      ),
    );
  }
}

// ── Color Picker Dialog with Hue Wheel ──

class _ColorPickerDialog extends StatefulWidget {
  final bool isBackground;
  final List<Color> quickColors;
  final ColorScheme colorScheme;
  final Function(Color) onColorSelected;
  final VoidCallback onReset;

  const _ColorPickerDialog({
    required this.isBackground,
    required this.quickColors,
    required this.colorScheme,
    required this.onColorSelected,
    required this.onReset,
  });

  @override
  State<_ColorPickerDialog> createState() => _ColorPickerDialogState();
}

class _ColorPickerDialogState extends State<_ColorPickerDialog> {
  double _hue = 0;
  double _saturation = 1;
  double _brightness = 1;
  late TextEditingController _hexController;

  Color get _currentColor =>
      HSVColor.fromAHSV(1, _hue, _saturation, _brightness).toColor();

  @override
  void initState() {
    super.initState();
    _hexController = TextEditingController();
  }

  @override
  void dispose() {
    _hexController.dispose();
    super.dispose();
  }

  void _updateHex() {
    final hex = _currentColor.value.toRadixString(16).padLeft(8, '0').substring(2).toUpperCase();
    _hexController.text = hex;
  }

  @override
  Widget build(BuildContext context) {
    final cs = widget.colorScheme;
    return AlertDialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
      title: Row(
        children: [
          Icon(
            widget.isBackground ? Icons.format_color_fill : Icons.format_color_text,
            size: 20, color: cs.primary,
          ),
          const SizedBox(width: 8),
          Text(
            widget.isBackground ? tr('background_color') : tr('text_color'),
            style: const TextStyle(fontSize: 18),
          ),
        ],
      ),
      content: SizedBox(
        width: 300,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Quick colors
            Text(tr('quick_colors'), style: TextStyle(
              fontSize: 12, fontWeight: FontWeight.w600,
              color: cs.onSurfaceVariant,
            )),
            const SizedBox(height: 8),
            Row(
              children: [
                GestureDetector(
                  onTap: () {
                    widget.onReset();
                    Navigator.pop(context);
                  },
                  child: Container(
                    width: 36, height: 36,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(10),
                      border: Border.all(color: cs.outlineVariant, width: 2),
                    ),
                    child: Icon(Icons.format_color_reset, size: 18, color: cs.onSurfaceVariant),
                  ),
                ),
                const SizedBox(width: 8),
                ...widget.quickColors.map((color) => Padding(
                  padding: const EdgeInsets.only(right: 8),
                  child: GestureDetector(
                    onTap: () {
                      widget.onColorSelected(color);
                      Navigator.pop(context);
                    },
                    child: Container(
                      width: 36, height: 36,
                      decoration: BoxDecoration(
                        color: color,
                        borderRadius: BorderRadius.circular(10),
                        border: Border.all(
                          color: color == const Color(0xFFFFFFFF)
                              ? cs.outlineVariant : Colors.transparent,
                          width: 1.5,
                        ),
                        boxShadow: [
                          BoxShadow(
                            color: color.withValues(alpha: 0.3),
                            blurRadius: 4, offset: const Offset(0, 2),
                          ),
                        ],
                      ),
                    ),
                  ),
                )),
              ],
            ),

            const SizedBox(height: 16),

            // Hue wheel + SatBright square
            Text(tr('pick_color'), style: TextStyle(
              fontSize: 12, fontWeight: FontWeight.w600,
              color: cs.onSurfaceVariant,
            )),
            const SizedBox(height: 8),
            SizedBox(
              height: 180,
              child: Row(
                children: [
                  // Hue wheel
                  SizedBox(
                    width: 180, height: 180,
                    child: GestureDetector(
                      onPanStart: (d) => _onWheelPan(d.localPosition, 180),
                      onPanUpdate: (d) => _onWheelPan(d.localPosition, 180),
                      onTapDown: (d) => _onWheelPan(d.localPosition, 180),
                      child: CustomPaint(
                        painter: _HueWheelPainter(
                          selectedHue: _hue,
                          centerColor: _currentColor,
                        ),
                        size: const Size(180, 180),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  // Saturation / Brightness square
                  Expanded(
                    child: SizedBox(
                      height: 180,
                      child: GestureDetector(
                        onPanStart: (d) => _onSatBrightPan(d.localPosition, 180),
                        onPanUpdate: (d) => _onSatBrightPan(d.localPosition, 180),
                        onTapDown: (d) => _onSatBrightPan(d.localPosition, 180),
                        child: CustomPaint(
                          painter: _SatBrightPainter(
                            hue: _hue,
                            saturation: _saturation,
                            brightness: _brightness,
                          ),
                          size: const Size(double.infinity, 180),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),

            const SizedBox(height: 16),

            // Preview + hex input
            Text(tr('hex_color'), style: TextStyle(
              fontSize: 12, fontWeight: FontWeight.w600,
              color: cs.onSurfaceVariant,
            )),
            const SizedBox(height: 8),
            Row(
              children: [
                // Color preview
                Container(
                  width: 40, height: 40,
                  decoration: BoxDecoration(
                    color: _currentColor,
                    borderRadius: BorderRadius.circular(10),
                    border: Border.all(color: cs.outlineVariant),
                  ),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: TextField(
                    controller: _hexController,
                    decoration: InputDecoration(
                      hintText: tr('color_hex_hint'),
                      prefixText: '#',
                      isDense: true,
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 12, vertical: 10,
                      ),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                    ),
                    style: const TextStyle(fontSize: 14, fontFamily: 'monospace'),
                    textCapitalization: TextCapitalization.characters,
                    maxLength: 6,
                    buildCounter: (_, {required currentLength, required isFocused, maxLength}) => null,
                    onChanged: (value) {
                      final hex = value.replaceAll('#', '').trim();
                      if (hex.length == 6) {
                        final cv = int.tryParse('FF$hex', radix: 16);
                        if (cv != null) {
                          final c = Color(cv);
                          final hsv = HSVColor.fromColor(c);
                          setState(() {
                            _hue = hsv.hue;
                            _saturation = hsv.saturation;
                            _brightness = hsv.value;
                          });
                        }
                      }
                    },
                  ),
                ),
                const SizedBox(width: 8),
                FilledButton(
                  onPressed: () {
                    widget.onColorSelected(_currentColor);
                    Navigator.pop(context);
                  },
                  style: FilledButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                    minimumSize: Size.zero,
                  ),
                  child: Text(tr('apply')),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  void _onWheelPan(Offset position, double size) {
    final center = Offset(size / 2, size / 2);
    final dx = position.dx - center.dx;
    final dy = position.dy - center.dy;
    final dist = math.sqrt(dx * dx + dy * dy);
    final radius = size / 2;
    final innerRadius = radius * 0.65;

    // Only respond to clicks on the ring area
    if (dist < innerRadius - 5 || dist > radius + 5) return;

    var angle = math.atan2(dy, dx);
    if (angle < 0) angle += 2 * math.pi;
    final hue = angle / (2 * math.pi) * 360;

    setState(() {
      _hue = hue;
      _updateHex();
    });
  }

  void _onSatBrightPan(Offset position, double height) {
    // The square width is the remaining space; we use height as reference
    final w = 108.0; // approximate expanded width
    setState(() {
      _saturation = (position.dx / w).clamp(0, 1);
      _brightness = (1.0 - position.dy / height).clamp(0, 1);
      _updateHex();
    });
  }
}

class _HueWheelPainter extends CustomPainter {
  final double selectedHue;
  final Color centerColor;

  _HueWheelPainter({required this.selectedHue, required this.centerColor});

  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2;
    final ringWidth = radius * 0.3;
    final innerRadius = radius - ringWidth;

    // Draw hue ring
    for (double angle = 0; angle < 360; angle += 1) {
      final paint = Paint()
        ..color = HSVColor.fromAHSV(1, angle, 1, 1).toColor()
        ..style = PaintingStyle.stroke
        ..strokeWidth = ringWidth + 1;
      final startAngle = (angle - 90) * math.pi / 180;
      final sweepAngle = 2 * math.pi / 360;
      canvas.drawArc(
        Rect.fromCircle(center: center, radius: innerRadius + ringWidth / 2),
        startAngle,
        sweepAngle,
        false,
        paint,
      );
    }

    // Draw center filled circle with current color
    final centerPaint = Paint()..color = centerColor;
    canvas.drawCircle(center, innerRadius - 4, centerPaint);

    // Draw center border
    final borderPaint = Paint()
      ..color = Colors.white.withValues(alpha: 0.5)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;
    canvas.drawCircle(center, innerRadius - 4, borderPaint);

    // Draw selector on hue ring
    final selectorAngle = (selectedHue - 90) * math.pi / 180;
    final selectorRadius = innerRadius + ringWidth / 2;
    final selectorPos = Offset(
      center.dx + selectorRadius * math.cos(selectorAngle),
      center.dy + selectorRadius * math.sin(selectorAngle),
    );
    // White circle selector
    canvas.drawCircle(selectorPos, ringWidth / 2 + 2,
        Paint()..color = Colors.white..style = PaintingStyle.stroke..strokeWidth = 3);
    canvas.drawCircle(selectorPos, ringWidth / 2 - 1,
        Paint()..color = HSVColor.fromAHSV(1, selectedHue, 1, 1).toColor());
  }

  @override
  bool shouldRepaint(covariant _HueWheelPainter old) =>
      old.selectedHue != selectedHue || old.centerColor != centerColor;
}

class _SatBrightPainter extends CustomPainter {
  final double hue;
  final double saturation;
  final double brightness;

  _SatBrightPainter({required this.hue, required this.saturation, required this.brightness});

  @override
  void paint(Canvas canvas, Size size) {
    final rect = Rect.fromLTWH(0, 0, size.width, size.height);
    final rRect = RRect.fromRectAndRadius(rect, const Radius.circular(12));

    canvas.save();
    canvas.clipRRect(rRect);

    // Base hue fill
    final basePaint = Paint()..color = HSVColor.fromAHSV(1, hue, 1, 1).toColor();
    canvas.drawRect(rect, basePaint);

    // Saturation gradient (white to transparent, left to right)
    final satGradient = LinearGradient(
      begin: Alignment.centerLeft,
      end: Alignment.centerRight,
      colors: [Colors.white, Colors.white.withValues(alpha: 0)],
    );
    canvas.drawRect(rect, Paint()..shader = satGradient.createShader(rect));

    // Brightness gradient (transparent to black, top to bottom)
    final brightGradient = LinearGradient(
      begin: Alignment.topCenter,
      end: Alignment.bottomCenter,
      colors: [Colors.black.withValues(alpha: 0), Colors.black],
    );
    canvas.drawRect(rect, Paint()..shader = brightGradient.createShader(rect));

    canvas.restore();

    // Border
    final borderPaint = Paint()
      ..color = Colors.grey.withValues(alpha: 0.3)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1;
    canvas.drawRRect(rRect, borderPaint);

    // Selector circle
    final sx = saturation * size.width;
    final sy = (1 - brightness) * size.height;
    canvas.drawCircle(Offset(sx, sy), 8,
        Paint()..color = Colors.white..style = PaintingStyle.stroke..strokeWidth = 3);
    canvas.drawCircle(Offset(sx, sy), 6,
        Paint()..color = HSVColor.fromAHSV(1, hue, saturation, brightness).toColor());
  }

  @override
  bool shouldRepaint(covariant _SatBrightPainter old) =>
      old.hue != hue || old.saturation != saturation || old.brightness != brightness;
}

